---
title: "Advanced Information Management"
output: html_document
---

```{r setup, message=FALSE, warning=FALSE, include=FALSE}
library(pointblank)
```

In the [*Intro to Information Management*](../articles/INFO-1.html) article, we learned all about how to synthesize information on a table, giving us a useful report that can be published and widely shared. We used a **pointblank** *informant* with a set of information functions to generate *info text* and put that text into the appropriate report sections. We're going to take this a few steps further and look into some more functionality makes *info text* more dynamic and also include a finalizing step in this workflow that accounts for evolving data. 

# Getting Snippets of Useful Text With the `info_snippet()` Function

A great source of information about the table can be the table itself. Suppose you want to show some categorical values from a particular column. Maybe you'd like to display the range of values in an important numeric column. Perhaps show some KPI values that can be calculated using data in the table? This can all be done with the `info_snippet()` function. You give the snippet a name and you give it a function call. Let's do this for the `small_table` dataset available in **pointblank**. This is what that table looks like:

```{r paged.print=FALSE}
small_table
```

If you wanted the mean value of data in column `d` rounded to one decimal place, one such we could do it is with this expression:

```{r}
small_table %>% .$d %>% mean() %>% round(1)
```

Inside of an `info_snippet()` call, which is used after creating the *informant* object, the expression would look like this:

```{r eval=FALSE}
informant <- 
  create_informant(
    read_fn = ~ small_table,
    tbl_name = "small_table",
    label = "Example No. 2"
  ) %>%
  info_snippet(
    snippet_name = "mean_d",
    fn = ~ . %>% .$d %>% mean() %>% round(1)
  )
```

The `small_table` dataset is associated with the `informant` as the target table, so, it's represented as the leading `.` in the functional sequence given to `fn`. It's important to note that there's a leading `~`, making this expression a RHS formula (we don't want to execute anything here, at this time). Lastly, the snippet has been given the name `"mean_d"`. We know that this snippet will produce the value `2304.7` so what can we do with that? We should put that value into some *info text* and use the `snippet_name` as the key. It works similarly to how the **glue** package does text interpolation, and here's the continuation of the above example:

```{r eval=FALSE}
informant <- 
  informant %>%
  info_columns(
    columns = vars(d),
    info = "This column contains fairly large numbers (much larger than
    those numbers in column `a`. The mean value is {mean_d}, which is
    far greater than any number in that other column."
  )
```

Within the text, there's the use of curly braces and the name of the snippet. That's where the `2304.7` value will be inserted. This methodology for inserting the computed values of snippets can be performed wherever *info text* is provided (in either of the `info_tabular()`, `info_columns()`, and `info_section()` functions). Let's take a look at the report by printing the `informant` object

```{r eval=FALSE}
informant
```

<div style="text-align: center;"><img src="https://silly-jackson-b3dec8.netlify.app/informant_report_7.png" width=80%></div>
<br>

Hmm. There is `"... {mean_d} ..."` text in the report that should have been replaced with the mean value of column `d`. What gives? Well, there's one finalizing step that needs to be done and should always be done to wrap up the *Information Management* workflow and that is the use of the `incorporate()` function. Let's write the whole thing again and finish it off with a call to `incorporate()`.

```{r eval=FALSE}
informant <- 
  create_informant(
    read_fn = ~ small_table,
    tbl_name = "small_table",
    label = "Example No. 2"
  ) %>%
  info_snippet(
    snippet_name = "mean_d",
    fn = ~ . %>% .$d %>% mean() %>% round(1)
  ) %>%
    info_columns(
    columns = vars(d),
    info = "This column contains fairly large numbers (much larger than
    those numbers in column `a`. The mean value is {mean_d}, which is
    far greater than any number in that other column."
  ) %>%
  incorporate()

informant
```

<div style="text-align: center;"><img src="https://silly-jackson-b3dec8.netlify.app/informant_report_8.png" width=80%></div>
<br>

This time, sweet success. The value appears and the overall formatting looks great! This is a very useful thing, so long as we remember to use the `incorporate()` function to make it happen (more on that in the next section). 

# Ensuring That Snippets (and Other Table Metadata Element) Are Up-to-Date

Tables can change with time. Whether that data source is a public dataset, an organization's data table, or a continually-updated Excel file (ðŸ˜±), we should be ready for change. In the previous example, we used the `incorporate()` function to finalize the report. Without it, our snippet didn't work. There are two major things that `incorporate()` does for you in the *Information Management* workflow.

1. Evaluation of text snippets in all `info_snippet()` calls, and, insertion of snippets in *info text* within `"{<snippet_name>}"`.

2. Updating of table row and column counts in the header of the report.

We really are incorporating aspects of the table into the report with `incorporate()` but might might also think of it as regenerating, refreshing, or renewing the table. It gives **pointblank** license to access the table the same way that `interrogate()` does in the [**VALID-I**]((../articles/VALID-I.html)) validation workflow. On the first use of `incorporate()`, all text snippets will be put in their places; subsequent uses of `incorporate()` will replace the appropriate text as necessary. Every use of `incorporate()` will update the row and column counts in the header.

Here's a short demo of the header changing, because it's pretty instructive. Let's use our `small_table` object as `target_table`. With `dim()` we can be totally sure of the table dimensions. 

```{r}
target_table <- small_table

dim(target_table)
```

Let's allow an informant to access the `target_table` through the `read_fn` argument. In this case, the expression is `~ target_table` (it simply gets the table from the global workspace). After using `incorporate()` and printing the `informant_tt` object, let's just examine the header.

```{r eval=FALSE}
informant_tt <- 
  create_informant(
    read_fn = ~ target_table,
    tbl_name = "target_table",
    label = "Example No. 3"
  ) %>%
  incorporate()

informant_tt
```

<div style="text-align: center;"><img src="https://silly-jackson-b3dec8.netlify.app/informant_report_9.png" width=80%></div>
<p align="center">This is an excerpt of the complete report, showing just the header.</p>
<br>

The number of rows and columns reported in the header checks out: 13 rows and 8 columns.

Now, let's manually enlarge the `target_table` and print the new row and column counts.

```{r}
target_table <- 
  dplyr::bind_rows(small_table, small_table) %>%
  dplyr::mutate(g = a + c)

dim(target_table)
```

We've got our informant object, let's see how `incorporate()` keeps pace with the change.

```{r eval=FALSE}
informant_tt %>% incorporate()
```

<div style="text-align: center;"><img src="https://silly-jackson-b3dec8.netlify.app/informant_report_10.png" width=80%></div>
<p align="center">This is an excerpt of the complete report, showing just the header.</p>
<br>

Great! Using `incorporate()` has accurately updated the reporting of row and column counts in the header. And it's also very much worth noting that the use of a `read_fn` is important here. Had `target_table` been given to the `tbl` argument of `create_informant()`, that table would be bound to the informant in its initial state (with 13 rows and 8 columns) and any updates to the table wouldn't be reflected in the reporting upon using `incorporate()`. The table-reading function is meant for obtaining the table each and every time the table is needed. 

In short, unless you have no uses of `info_snippet()` and the table isn't expected to change, it's recommended to use `incorporate()` as the final call in this workflow.

# Helpful **pointblank** Functions that Work Exceedingly Well with `info_snippet()`

There are a few functions available in **pointblank** that make it much easier to get commonly-used text snippets. All of them begin with the `snip_` prefix and they are:

- `snip_list()`: Gets a list of column categories
- `snip_lowest()`: Gets the lowest value from a column
- `snip_highest()`: Gets the highest value from a column

Each of these functions can be used directly as a `fn` value and we don't have to specify the table since its assumed that the target table is where we'll be snipping data from. Let's have a look at each of these in action.

## The `snip_list()` Function

When describing some aspect of the target table, we may want to extract some values from a column and include them as a piece of info text. We'd want the values to be nicely formatted as a list (with commas) and we'd probably prefer that this be constrained to a certain size (so as to not potentially generate massive amounts of text). This can be efficiently done with `snip_list()`. Let's experiment with the combination of `snip_list()` and `info_snippet()`, extending the **palmerpenguins** example from the [*Intro to Information Management*](../articles/INFO-I.html) article.

```{r eval=FALSE}
informant_pp <- 
  create_informant(
    read_fn = ~ palmerpenguins::penguins,
    tbl_name = "penguins",
    label = "The `penguins` dataset from the **palmerpenguins** ðŸ“¦."
  ) %>% 
  info_columns(
    columns = "species",
    `â„¹ï¸` = "A factor denoting penguin species ({species_snippet})."
  ) %>%
  info_columns(
    columns = "island",
    `â„¹ï¸` = "A factor denoting island in Palmer Archipelago, Antarctica
    ({island_snippet})."
  ) %>%
  info_snippet(
    snippet_name = "species_snippet",
    fn = snip_list(column = "species")
  ) %>%
  info_snippet(
    snippet_name = "island_snippet",
    fn = snip_list(column = "island")
  ) %>%
  incorporate()

informant_pp
```

<div style="text-align: center;"><img src="https://silly-jackson-b3dec8.netlify.app/informant_report_11.png" width=80%></div>
<p align="center">This is an excerpt of the complete report, showing just the header and part of the <strong>COLUMNS</strong> section.</p>
<br>

This seemed to work out quite well. No need for determining what these strings are and then hardcoding them to the *info text*, `snip_list()` did all the work here.

This also works for numeric values. Let's use `snip_list()` to provide a text snippet based on values in the `year` column (which is an `integer` column):

```{r eval=FALSE}
informant_pp <-
  informant_pp %>%
  info_columns(
    columns = "year",
    `â„¹ï¸` = "The study year ({year_snippet})."
  ) %>%
  info_snippet(
    snippet_name = "year_snippet",
    fn = snip_list(column = "year")
  ) %>%
  incorporate()

informant_pp
```

<div style="text-align: center;"><img src="https://silly-jackson-b3dec8.netlify.app/informant_report_12.png" width=80%></div>
<p align="center">This is an excerpt of the complete report, showing just the bottom of the <strong>COLUMNS</strong> section and the footer.</p>
<br>

Again, no issues with the formatting and display of values. We got the *info text* `"The study year ("2007", "2008", and "2009" )."` for our efforts here and it saved us from having to determine this, plus, should the data be updated with new `year` values, that will be reflected in this info text upon using `incorporate()`. Refreshed *info text* really provides huge benefits, especially when the data changes a lot (e.g., database tables).

## The `snip_lowest()` and `snip_highest()` Functions

We can get the lowest and highest values from a column and inject those formatted values into some *info_text*. Let's do that for some of the measured values in the `penguins` dataset with `snip_lowest()` and `snip_highest()`.

```{r eval=FALSE}
informant_pp <-
  informant_pp %>%
  info_columns(
    columns = "bill_length_mm",
    `â„¹ï¸` = "A number denoting bill length"
  ) %>%
  info_columns(
    columns = "bill_depth_mm",
    `â„¹ï¸` = "A number denoting bill depth (in the range of
    {min_depth} to {max_depth} millimeters)."
  ) %>%
  info_columns(
    columns = "flipper_length_mm",
    `â„¹ï¸` = "An integer denoting flipper length"
  ) %>%
  info_columns(
    columns = matches("length"),
    `â„¹ï¸` = "(in units of millimeters)."
  ) %>%
  info_columns(
    columns = "flipper_length_mm",
    `â„¹ï¸` = "Largest observed is {largest_flipper_length} mm."
  ) %>%
  info_snippet(
    snippet_name = "min_depth",
    fn = snip_lowest(column = "bill_depth_mm")
  ) %>%
  info_snippet(
    snippet_name = "max_depth",
    fn = snip_highest(column = "bill_depth_mm")
  ) %>%
  info_snippet(
    snippet_name = "largest_flipper_length",
    fn = snip_highest(column = "flipper_length_mm")
  ) %>%
  incorporate()

informant_pp
```

<div style="text-align: center;"><img src="https://silly-jackson-b3dec8.netlify.app/informant_report_13.png" width=80%></div>
<br>

We can see from the report output that we can creatively use the lowest and highest values obtained by `snip_lowest()` and `snip_highest()` to specify a range or simply show some maximum value. While the ordering of the `info_columns()` calls in the example affects the overall layout of the text (through the text appending behavior), the placement of `info_snippet()` calls *does not* matter. And, again, we must use `incorporate()` to update all of the text snippets and render them in their appropriate locations (inside each `{<snippet_name>}`).
