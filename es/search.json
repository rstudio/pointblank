[{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others‚Äô private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement riannone@.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.0, available https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines inspired Mozilla‚Äôs code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Information and Guidelines for Contributing to pointblank","title":"Information and Guidelines for Contributing to pointblank","text":"many ways contribute ongoing development pointblank package. contributions can rather easy (e.g., fixing typos, improving documentation, filing issues feature requests problems, etc.) whereas contributions can require time patience (like answering questions submitting pull requests code changes). Just know help provided capacity much appreciated. :)","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CONTRIBUTING.html","id":"filing-issues","dir":"","previous_headings":"","what":"Filing Issues","title":"Information and Guidelines for Contributing to pointblank","text":"believe found bug, create minimal reprex posting pointblank issue tracker. Try include anything unnecessary, just minimal amount code constitutes reproducible bug. try verify bug running code reprex provided. quality reprex reduce amount back--forth communication trying understand execute code systems.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CONTRIBUTING.html","id":"answering-questions","dir":"","previous_headings":"","what":"Answering questions","title":"Information and Guidelines for Contributing to pointblank","text":"great way help simply answering questions. ‚Äôs amazing little conversation lead better insights problem. Don‚Äôt quite know answer? ‚Äôs okay . ‚Äôre together. might answer user questions? forums Q&pointblank include RStudio community, Twitter (good search term pointblank #rstats), Stack Overflow. Good etiquette key interactions: good person ask questions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/CONTRIBUTING.html","id":"making-pull-requests","dir":"","previous_headings":"Answering questions","what":"Making Pull Requests","title":"Information and Guidelines for Contributing to pointblank","text":"consider making pull request (PR), please file issue first explain problem detail. PR enhancement, detail change make things better package users. Bugfix PRs also requre explanation bug proposed fix remove bug. great way illustrate bug include reprex. upfront work prior preparing PR can time-consuming opens line communication package authors community, perhaps leading better enhancement effective fixes! consensus PR based issue helpful, adhering following process make things proceed quickly: Create separate Git branch PR. Look GitHub Actions build status badges making changes; badges available package README. pointblank package follows tidyverse style guide please adopt style guidelines submitted code best possible. internal documentation uses roxygen2; contribution requires new revised documentation ensure roxygen comments added/modified (modify .Rd files man folder). use testthat code coverage; contributions test cases included helpful easier accept. Add bullet top NEWS.md current development version header describing user-facing changes made; include GitHub username, links relevant issue(s)/PR(s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2017-2021 Richard Iannone Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/PULL_REQUEST_TEMPLATE.html","id":null,"dir":"","previous_headings":"","what":"Summary","title":"Summary","text":"Thank contributing pointblank! make process easier everyone, please explain context purpose contribution. Also, list changes made existing code documentation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/PULL_REQUEST_TEMPLATE.html","id":"related-github-issues-and-prs","dir":"","previous_headings":"","what":"Related GitHub Issues and PRs","title":"Summary","text":"Ref: #","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/PULL_REQUEST_TEMPLATE.html","id":"checklist","dir":"","previous_headings":"","what":"Checklist","title":"Summary","text":"understand agree Code Conduct. listed major changes NEWS. added testthat unit tests tests/testthat new functionality.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-1.html","id":"starting-with-a-simple-example","dir":"Articles","previous_headings":"","what":"Starting with a Simple Example","title":"Intro to Information Management","text":"workflow somewhat similar concept usage Data Quality Reporting Workflow (VALID-). Instead agent, use informant get informant create_informant() function. point informant target table can data frame, tibble, database table (tbl_dbi object), Spark DataFrame (tbl_spark object). small_table dataset included pointblank package. ‚Äôs small, uninteresting dataset ‚Äôs useful simple examples. looks like: Let‚Äôs use small_table object see results introducing informant. Printing informant show us automatically-generated information small_table dataset, adding Columns section.  Alternatively can get report get_informant_report() access additional output options, like producing narrower version output.  Either way, get initial reporting basic. done next add information following set info_*() functions: info_tabular(): Add information focuses aspects data table whole info_columns(): Add information focuses aspects data table‚Äôs columns info_section(): Add information focuses key aspect data table Let‚Äôs try adding information functions look resulting report.  can seen, report bit filled information. TABLE COLUMNS sections prescribed order new section named INFORMATION follows (one subsection called EXAMPLES DOCUMENTATION). Let‚Äôs explore three different info_*() functions work.","code":"small_table ## # A tibble: 13 √ó 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Example No. 1\"   ) informant get_informant_report(informant, size = \"small\") informant <-   create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Example No. 2\"   ) %>%   info_tabular(     description = \"This table is included in the **pointblank** pkg.\"   ) %>%   info_columns(     columns = \"date_time\",     info = \"This column is full of timestamps.\"   ) %>%   info_section(     section_name = \"further information\",      `examples and documentation` = \"Examples for how to use the `info_*()` functions     (and many more) are available at the      [**pointblank** site](https://rich-iannone.github.io/pointblank/).\"   )  informant"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-1.html","id":"the-table-section-and-info_tabular","dir":"Articles","previous_headings":"","what":"The TABLE Section and info_tabular()","title":"Intro to Information Management","text":"info_tabular() function adds information TABLE section. use named arguments define subsection names content. previous example info_tabular(description = \"table included **pointblank** pkg.\") used make DESCRIPTION subsection (section titles automatically capitalized), info text Markdown text \"table included **pointblank** pkg.\". can define many subsections TABLE section need, either info_tabular() call across multiple calls. want use complicated subsection names single word, can enclose text back ticks. example, put emoji subsection name? excerpt complete report, showing just report header TABLE section.  TABLE section great place put information table needs front center. Examples useful topics section might include: high-level summary table, stating purpose importance row table represents main users table within organization description table generated information frequency updates","code":"informant %>%    info_tabular(`üîÑ updates` = \"This table is not regularly updated.\")"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-1.html","id":"the-columns-section-and-info_columns","dir":"Articles","previous_headings":"","what":"The COLUMNS Section and info_columns()","title":"Intro to Information Management","text":"section follows TABLE section COLUMNS. section provides opportunity describe table column much detail necessary. , individual columns serve subsections (automatically generated upon using create_informant()) can subsections within column well. interesting thing information provided via info_columns() information additive. can make multiple calls info_columns() disperse common pieces info text multiple columns append text existing. Let‚Äôs take look practice far interesting palmerpenguins::penguins dataset. , fill information column adapting documentation palmerpenguins package.  able provide subsections name ‚ÑπÔ∏è , furthermore, use tidyselect functions like ends_with() append info text common subsection exists across multiple columns. useful stating units common across three columns: bill_length_mm, bill_depth_mm, flipper_length_mm. following tidyselect functions available pointblank make process easier: starts_with(): Match columns start prefix. ends_with(): Match columns end suffix. contains(): Match columns contain literal string. matches(): Perform matching regular expression. everything(): Select columns.","code":"informant_pp <-    create_informant(     read_fn = ~ palmerpenguins::penguins,     tbl_name = \"penguins\",     label = \"The `penguins` dataset from the **palmerpenguins** üì¶.\"   ) %>%    info_columns(     columns = \"species\",     `‚ÑπÔ∏è` = \"A factor denoting penguin species (*Ad√©lie*, *Chinstrap*, and *Gentoo*).\"   ) %>%   info_columns(     columns = \"island\",     `‚ÑπÔ∏è` = \"A factor denoting island in Palmer Archipelago, Antarctica     (*Biscoe*, *Dream*, or *Torgersen*).\"   ) %>%   info_columns(     columns = \"bill_length_mm\",     `‚ÑπÔ∏è` = \"A number denoting bill length\"   ) %>%   info_columns(     columns = \"bill_depth_mm\",     `‚ÑπÔ∏è` = \"A number denoting bill depth\"   ) %>%   info_columns(     columns = \"flipper_length_mm\",     `‚ÑπÔ∏è` = \"An integer denoting flipper length\"   ) %>%   info_columns(     columns = ends_with(\"mm\"),     `‚ÑπÔ∏è` = \"(in units of millimeters).\"   ) %>%   info_columns(     columns = \"body_mass_g\",     `‚ÑπÔ∏è` = \"An integer denoting body mass (grams).\"   ) %>%   info_columns(     columns = \"sex\",     `‚ÑπÔ∏è` = \"A factor denoting penguin sex (`\\\"female\\\"`, `\\\"male\\\"`).\"   ) %>%   info_columns(     columns = \"year\",     `‚ÑπÔ∏è` = \"The study year (e.g., `2007`, `2008`, `2009`).\"   )  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-1.html","id":"extra-sections-and-info_section","dir":"Articles","previous_headings":"","what":"Extra Sections and info_section()","title":"Intro to Information Management","text":"information can‚Äôt don‚Äôt want put TABLE COLUMNS sections, can place extra sections (subsections) info_section() function. sections go aforementioned sections order creation. Let‚Äôs put together extra sections describe palmerpenguins::penguins dataset. excerpt complete report, showing just SOURCE section footer.  types information go well separate sections? ideas : info related source data table (e.g., references, background, etc.) definitions/explanations terms used persons responsible data table, perhaps contact information details table produced important issues table notes upcoming changes links information artifacts pertain table information report (meta!); might include things like update history, persons responsible, instructions contribute, etc. Really, sky limit ! can incorporate great deal useful information use process generate reports important tables within organization. ‚Äôs can done. go next phase (Advanced Information Management article). go way now, total transformation. think ‚Äôre ready?","code":"informant_pp <-    informant_pp %>%   info_section(     section_name = \"source\",     \"References\" = c( \"- Ad√©lie penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural  size measurements and isotopic signatures of foraging among adult male and female  Ad√©lie penguins (Pygoscelis adeliae) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental Data Initiative <https://doi.org/10.6073/pasta/98b16d7d563f265cb52372c8ca99e60f>\",  \"- Gentoo penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural size measurements and isotopic signatures of foraging among adult male and female Gentoo penguin (Pygoscelis papua) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental Data Initiative <https://doi.org/10.6073/pasta/7fca67fb28d56ee2ffa3d9370ebda689>\",  \"- Chinstrap penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural size measurements and isotopic signatures of foraging among adult male and female Chinstrap penguin (Pygoscelis antarcticus) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 6. Environmental Data Initiative <https://doi.org/10.6073/pasta/c14dfcfada8ea13a17536e73eb6fbe9e> \"     ),     \"Note\" = \" Originally published in: Gorman KB, Williams TD, Fraser WR (2014) Ecological Sexual Dimorphism and Environmental Variability within a Community of Antarctic Penguins (Genus Pygoscelis). PLoS ONE 9(3): e90081. doi:10.1371/journal.pone.0090081 \" )  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"getting-snippets-of-useful-text-with-the-info_snippet-function","dir":"Articles","previous_headings":"","what":"Getting Snippets of Useful Text With the info_snippet() Function","title":"Advanced Information Management","text":"great source information table can table . Suppose want show categorical values particular column. Maybe ‚Äôd like display range values important numeric column. Perhaps show KPI values can calculated using data table? can done info_snippet() function. give snippet name give function call. Let‚Äôs small_table dataset available pointblank. table looks like: wanted mean value data column d rounded one decimal place, one way expression: Inside info_snippet() call, used creating informant object, expression look like : small_table dataset associated informant target table, , ‚Äôs represented leading . functional sequence given fn. ‚Äôs important note ‚Äôs leading ~, making expression RHS formula (don‚Äôt want execute anything , time). Lastly, snippet given name \"mean_d\". know snippet produce value 2304.7 can ? put value info text use snippet_name key. works similarly glue package text interpolation, ‚Äôs continuation example: Within text, ‚Äôs use curly braces name snippet. ‚Äôs 2304.7 value inserted. methodology inserting computed values snippets can performed wherever info text provided (either info_tabular(), info_columns(), info_section() functions). Let‚Äôs take look report printing informant object  Hmm. \"... {mean_d} ...\" text report replaced mean value column d. gives? Well, ‚Äôs one finalizing step needs done always done wrap Information Management workflow use incorporate() function. Let‚Äôs write whole thing finish call incorporate().  time, sweet success. value appears overall formatting looks great! useful thing, long remember use incorporate() function make happen (next section).","code":"small_table ## # A tibble: 13 √ó 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high small_table %>% .$d %>% mean() %>% round(1) ## [1] 2304.7 informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Example No. 2\"   ) %>%   info_snippet(     snippet_name = \"mean_d\",     fn = ~ . %>% .$d %>% mean() %>% round(1)   ) informant <-    informant %>%   info_columns(     columns = vars(d),     info = \"This column contains fairly large numbers (much larger than     those numbers in column `a`. The mean value is {mean_d}, which is     far greater than any number in that other column.\"   ) informant informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Example No. 2\"   ) %>%   info_snippet(     snippet_name = \"mean_d\",     fn = ~ . %>% .$d %>% mean() %>% round(1)   ) %>%     info_columns(     columns = vars(d),     info = \"This column contains fairly large numbers (much larger than     those numbers in column `a`. The mean value is {mean_d}, which is     far greater than any number in that other column.\"   ) %>%   incorporate()  informant"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"ensuring-that-snippets-and-other-table-metadata-element-are-up-to-date","dir":"Articles","previous_headings":"","what":"Ensuring That Snippets (and Other Table Metadata Element) Are Up-to-Date","title":"Advanced Information Management","text":"Tables can change time. Whether data source public dataset, organization‚Äôs data table, continually-updated Excel file (üò±), ready change. previous example, used incorporate() function finalize report. Without , snippet didn‚Äôt work. two major things incorporate() Information Management workflow. Evaluation text snippets info_snippet() calls, , insertion snippets info text within \"{<snippet_name>}\". Updating table row column counts header report. really incorporating aspects table report incorporate() might might also think regenerating, refreshing, renewing table. gives pointblank license access table way interrogate() VALID-validation workflow. first use incorporate(), text snippets put places; subsequent uses incorporate() replace appropriate text necessary. Every use incorporate() update row column counts header. ‚Äôs short demo header changing, ‚Äôs pretty instructive. Let‚Äôs use small_table object target_table. dim() can totally sure table dimensions. Let‚Äôs allow informant access target_table read_fn argument. case, expression ~ target_table (simply gets table global workspace). using incorporate() printing informant_tt object, let‚Äôs just examine header. excerpt complete report, showing just header.  number rows columns reported header checks : 13 rows 8 columns. Now, let‚Äôs manually enlarge target_table print new row column counts. ‚Äôve got informant object, let‚Äôs see incorporate() keeps pace change. excerpt complete report, showing just header.  Great! Using incorporate() accurately updated reporting row column counts header. ‚Äôs also much worth noting use read_fn important . target_table given tbl argument create_informant(), table bound informant initial state (13 rows 8 columns) updates table wouldn‚Äôt reflected reporting upon using incorporate(). table-reading function meant obtaining table every time table needed. short, unless uses info_snippet() table isn‚Äôt expected change, ‚Äôs recommended use incorporate() final call workflow.","code":"target_table <- small_table  dim(target_table) ## [1] 13  8 informant_tt <-    create_informant(     read_fn = ~ target_table,     tbl_name = \"target_table\",     label = \"Example No. 3\"   ) %>%   incorporate()  informant_tt target_table <-    dplyr::bind_rows(small_table, small_table) %>%   dplyr::mutate(g = a + c)  dim(target_table) ## [1] 26  9 informant_tt %>% incorporate()"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"helpful-pointblank-functions-that-work-exceedingly-well-with-info_snippet","dir":"Articles","previous_headings":"","what":"Helpful pointblank Functions that Work Exceedingly Well with info_snippet()","title":"Advanced Information Management","text":"functions available pointblank make much easier get commonly-used text snippets. begin snip_ prefix : snip_list(): Gets list column categories snip_lowest(): Gets lowest value column snip_highest(): Gets highest value column functions can used directly fn value don‚Äôt specify table since assumed target table ‚Äôll snipping data . Let‚Äôs look action.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"the-snip_list-function","dir":"Articles","previous_headings":"","what":"The snip_list() Function","title":"Advanced Information Management","text":"describing aspect target table, may want extract values column include piece info text. ‚Äôd want values nicely formatted list (commas) ‚Äôd probably prefer constrained certain size (potentially generate massive amounts text). can efficiently done snip_list(). Let‚Äôs experiment combination snip_list() info_snippet(), extending palmerpenguins example Intro Information Management article. excerpt complete report, showing just header part COLUMNS section.  seemed work quite well. need determining strings hardcoding info text, snip_list() work . also works numeric values. Let‚Äôs use snip_list() provide text snippet based values year column (integer column): excerpt complete report, showing just bottom COLUMNS section footer.  , issues formatting display values. got info text \"study year (\"2007\", \"2008\", \"2009\" ).\" efforts saved us determine , plus, data updated new year values, reflected info text upon using incorporate(). Refreshed info text really provides huge benefits, especially data changes lot (e.g., database tables).","code":"informant_pp <-    create_informant(     read_fn = ~ palmerpenguins::penguins,     tbl_name = \"penguins\",     label = \"The `penguins` dataset from the **palmerpenguins** üì¶.\"   ) %>%    info_columns(     columns = \"species\",     `‚ÑπÔ∏è` = \"A factor denoting penguin species ({species_snippet}).\"   ) %>%   info_columns(     columns = \"island\",     `‚ÑπÔ∏è` = \"A factor denoting island in Palmer Archipelago, Antarctica     ({island_snippet}).\"   ) %>%   info_snippet(     snippet_name = \"species_snippet\",     fn = snip_list(column = \"species\")   ) %>%   info_snippet(     snippet_name = \"island_snippet\",     fn = snip_list(column = \"island\")   ) %>%   incorporate()  informant_pp informant_pp <-   informant_pp %>%   info_columns(     columns = \"year\",     `‚ÑπÔ∏è` = \"The study year ({year_snippet}).\"   ) %>%   info_snippet(     snippet_name = \"year_snippet\",     fn = snip_list(column = \"year\")   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"the-snip_lowest-and-snip_highest-functions","dir":"Articles","previous_headings":"","what":"The snip_lowest() and snip_highest() Functions","title":"Advanced Information Management","text":"can get lowest highest values column inject formatted values info_text. Let‚Äôs measured values penguins dataset snip_lowest() snip_highest().  can see report output can creatively use lowest highest values obtained snip_lowest() snip_highest() specify range simply show maximum value. ordering info_columns() calls example affects overall layout text (text appending behavior), placement info_snippet() calls matter. , , must use incorporate() update text snippets render appropriate locations (inside {<snippet_name>}).","code":"informant_pp <-   informant_pp %>%   info_columns(     columns = \"bill_length_mm\",     `‚ÑπÔ∏è` = \"A number denoting bill length\"   ) %>%   info_columns(     columns = \"bill_depth_mm\",     `‚ÑπÔ∏è` = \"A number denoting bill depth (in the range of     {min_depth} to {max_depth} millimeters).\"   ) %>%   info_columns(     columns = \"flipper_length_mm\",     `‚ÑπÔ∏è` = \"An integer denoting flipper length\"   ) %>%   info_columns(     columns = matches(\"length\"),     `‚ÑπÔ∏è` = \"(in units of millimeters).\"   ) %>%   info_columns(     columns = \"flipper_length_mm\",     `‚ÑπÔ∏è` = \"Largest observed is {largest_flipper_length} mm.\"   ) %>%   info_snippet(     snippet_name = \"min_depth\",     fn = snip_lowest(column = \"bill_depth_mm\")   ) %>%   info_snippet(     snippet_name = \"max_depth\",     fn = snip_highest(column = \"bill_depth_mm\")   ) %>%   info_snippet(     snippet_name = \"largest_flipper_length\",     fn = snip_highest(column = \"flipper_length_mm\")   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"text-tricks","dir":"Articles","previous_headings":"","what":"Text Tricks","title":"Advanced Information Management","text":"info text can jazzed Markdown, extra tricks make authoring text bit pleasurable. know text tricks ‚Äôll able express information many interesting ways.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"links-and-dates","dir":"Articles","previous_headings":"","what":"Links and Dates","title":"Advanced Information Management","text":"links text, pointblank try identify style nicely. amounts using pleasing, light-blue color underlines appear hover. doesn‚Äôt take much style links require something. , Markdown links written < link url > [ link text ]( link url ) get transformation treatment. Sometimes want dates stand text. Try enclosing date expressed ISO-8601 standard parentheses, like : (2004-12-01). happen date set monospaced variation reporting font, , underlined striking shade purple. ‚Äôs might use features otherwise adding information palmerpenguins reporting: excerpt complete report, showing just TABLE section header.","code":"informant_pp <-   informant_pp %>%   info_tabular(     `R dataset` = \"The goal of `palmerpenguins` is to provide a great dataset     for data exploration & visualization, as an alternative to `iris`. The     latest CRAN release was published on (2020-07-25).\",     `data collection` = \"Data were collected and made available by Dr. Kristen     Gorman and the [Palmer Station, Antarctica LTER](https://pal.lternet.edu),     a member of the [Long Term Ecological Research Network](https://lternet.edu).\",     citation = \"Horst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer      Archipelago (Antarctica) penguin data. R package version 0.1.0.     <https://allisonhorst.github.io/palmerpenguins/>.      doi: 10.5281/zenodo.3960218.\"   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"labels","dir":"Articles","previous_headings":"","what":"Labels","title":"Advanced Information Management","text":"can take portions text present labels. help call important attributes short form may eliminate need oft-repeated statements. might apply labels signify priority, category, information find useful. two options, Use double parentheses around text capture rectangular label: ((label text)) Use triple parentheses capture text rounded-rectangular label: (((label text))) excerpt complete report, showing just COLUMNS ADDITIONAL NOTES sections.","code":"informant_pp <-   informant_pp %>%   info_columns(     columns = vars(body_mass_g),      `‚ÑπÔ∏è` = \"An integer denoting body mass.\"   ) %>%   info_columns(     columns = c(ends_with(\"mm\"), ends_with(\"g\")),     `‚ÑπÔ∏è` = \"((measured))\"       ) %>%   info_section(     section_name = \"additional notes\",     `data types` = \"(((factor))) (((numeric))) (((integer)))\"   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/INFO-2.html","id":"get-stylin","dir":"Articles","previous_headings":"","what":"Get Stylin‚Äô","title":"Advanced Information Management","text":"want use CSS styles spans info text, ‚Äôs possible following construction: [[ info text ]]<< CSS style rules >> ‚Äôs important ensure CSS rule concluded ; character syntax. Styling word factor inside piece info text might look like : [[factor]]<<color: red; font-weight: 300;>> value. result looks something like :  many CSS style rules can used. ‚Äôs sample useful ones: color: <color value>; (text color) background-color: <color value>; (text‚Äôs background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); Continuing palmerpenguins reporting, ‚Äôll add info text take opportunity add CSS style rules using [[ ]]<< >> syntax. excerpt complete report, showing just bottom COLUMNS section, ADDITIONAL NOTES section, footer.  info_columns() info_section() function calls, able style single word (underline) even style labels (changing border background colors). syntax somewhat forgiving, allowing put line breaks ]] << style rules lines markup don‚Äôt overly long. , think text tricks? got admit can spice proceedings. inevitably added development pointblank proceeds. ‚Äôs now. Don‚Äôt think ‚Äôve enough?","code":"informant_pp <-   informant_pp %>%   info_columns(     columns = vars(sex),      `‚ÑπÔ∏è` = \"A [[factor]]<<text-decoration: underline;>>      denoting penguin sex (female or male).\"   ) %>%   info_section(     section_name = \"additional notes\",     keywords = \"     [[((penguins))]]<<border-color: platinum; background-color: #F0F8FF;>>      [[((Antarctica))]]<<border-color: #800080; background-color: #F2F2F2;>>      [[((measurements))]]<<border-color: #FFB3B3; background-color: #FFFEF4;>>     \"   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-I.html","id":"the-elements-of-this-workflow-an-agent-validation-functions-and-interrogate","dir":"Articles","previous_headings":"","what":"The Elements of this Workflow: an agent, validation functions, and interrogate()","title":"Introduction to the **Data Quality Reporting** Workflow (**VALID-I**)","text":"agent need workflow created create_agent() function. agent can handle one target table given time two different arguments can used specify table. first tbl, input table directly supplied agent. Alternatively, function can used read input data table read_fn argument one two ways: (1) using function (e.g., function() { <table reading code> }) , (2) R formula expression (e.g., ~ <table reading code>). agent needs directives table, , provide validation functions. check existence type column (col_exists() group col_is_*() functions). Others check cell column satisfying specific condition (col_vals_*() functions). can use many necessary satisfactory validation testing table question. certainly quite , ‚Äôs list validation functions questioning phrase function‚Äôs purpose: col_vals_lt(): column data less specified value? col_vals_lte(): column data less equal specified value? col_vals_equal(): column data equal specified value? col_vals_not_equal(): column data equal specified value? col_vals_gte(): column data greater equal specified value? col_vals_gt(): column data greater specified value? col_vals_between(): column data two specified values? col_vals_not_between(): column data two specified values? col_vals_in_set(): column data part specified set values? col_vals_not_in_set(): data part specified set values? col_vals_null(): column data NULL/NA? col_vals_not_null(): column data NULL/NA? col_vals_regex(): strings column data match regex pattern? col_vals_expr(): column data agree predicate expression? conjointly(): multiple rowwise validations result joint validity? rows_distinct(): row data distinct? col_is_character(): columns contain character/string data? col_is_numeric(): columns contain numeric values? col_is_integer(): columns contain integer values? col_is_logical(): columns contain logical values? col_is_date(): columns contain R Date objects? col_is_posix(): columns contain POSIXct dates? col_is_factor(): columns contain R factor objects? col_exists(): one columns actually exist? col_schema_match(): columns table (types) match predefined schema? final function needs called interrogate() function. validation functions, called agent object, don‚Äôt act target table interrogate() used. interrogation, usage validation functions serves instructions. interrogation phase instructions turn actions, agent carrying steps interrogation plan.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-I.html","id":"a-simple-example-with-the-basics","dir":"Articles","previous_headings":"","what":"A Simple Example with the Basics","title":"Introduction to the **Data Quality Reporting** Workflow (**VALID-I**)","text":"examples going forward, ‚Äôll use small_table dataset. ‚Äôs included pointblank package. isn‚Äôt large, makes great simple examples. entirety: follows simple validation plan. test : date_time column indeed date-time column column f values \"low\", \"mid\", \"high\" values column less 10 strings column b fit particular regex pattern (\"^[0-9]-[-z]{3}-[0-9]{3}$\") column d values range 0 5000 (entirely true!) validation plan written interrogated. carried interactively, ‚Äôll get status messages describe interrogation going. five OK messages means individual validations five validation steps passed within failure threshold levels. Since failure thresholds actually weren‚Äôt set, steps always display OK unless evaluation error occurred. Printing agent object gives step--step breakdown interrogation process.  Let‚Äôs look interpret report. bright green color strips left validation step indicates test units passed validation. lighter green color final step means least one failing unit. STEP column provides name validation function used basis validation step. COLUMNS shows us target column validation step. VALUES column lists values required validation step. TBL? indicates whether table mutated just interrogation validation step (via preconditions argument, available every validation function). right-facing arrows indicate table didn‚Äôt undergo transformation, working identity table every step. EVAL lets us know whether issues evaluating table (catching R errors warnings); checkmarks column show us issues interrogation. total number test units provided next ... column, absolute number fraction passing test units (PASS) failing test units (FAIL). W, S, N indicators tell us whether entered either WARN, STOP, NOTIFY states validation steps. didn‚Äôt set threshold levels states (can done actions argument, later), irrelevant report. Finally, EXT column provides opportunity download data extract rows CSV. rows represent rows failed test units. step 5, col_vals_between() validation step, data extract available (1 row). can either download CSV report examine extract R get_data_extracts() function: Recall validation step 5 asserted values column d 0 5000, however, extract small_table shows column d value 10000 lies outside specified range.","code":"small_table ## # A tibble: 13 √ó 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high agent <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"VALID-I Example No. 1\"   ) %>%   col_is_posix(vars(date_time)) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\", \"high\")) %>%   col_vals_lt(vars(a), value = 10) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\") %>%   col_vals_between(vars(d), left = 0, right = 5000) %>%   interrogate() ‚îÄ‚îÄ Interrogation Started - there are 5 steps ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚úì Step 1: OK. ‚úì Step 2: OK. ‚úì Step 3: OK. ‚úì Step 4: OK. ‚úì Step 5: OK.  ‚îÄ‚îÄ Interrogation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ agent get_data_extracts(agent, i = 5) ## # A tibble: 1 √ó 8 ##   date_time           date           a b             c      d e     f     ##   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ## 1 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-I.html","id":"using-threshold-levels-and-actions","dir":"Articles","previous_headings":"","what":"Using Threshold Levels and Actions","title":"Introduction to the **Data Quality Reporting** Workflow (**VALID-I**)","text":"can useful gauge data quality setting failure thresholds validation steps. example, may acceptable point time tolerate 5% failing test units given validation. , several levels data quality might useful instructive, failing test units across validations grouped 0-5%, 5-10%, 10%- bands. can specify failure threshold levels action_levels() function. Using function generates action_levels object can passed actions argument create_agent() (thereby creating default every validation step). following, use relative values (real numbers 0 1) define thresholds WARN STOP conditions. Printing al object gives us summary settings. Let‚Äôs use action_levels object new validation. ‚Äôs similar last one parameters validation functions result failing test units. ‚Äôll see interrogation messages show mention STOP WARNING conditions met. Printing agent provide different agent report seen previously, one ‚Äôs rife yellow red color strips left matching colors far right columns.  ‚Äôs possible invoke function particular failure condition met can set action_levels() function made part action_levels object. One example function can used included log4r_step() function logging failure conditions across validation steps. Let‚Äôs make new action_levels object include logging function WARN STOP failure conditions. Note function calls must written one-sided R formulas. Printing new al object show us failure threshold settings associated actions failure conditions. Using new al object validation workflow result failures certain validation steps logged. default, file named \"pb_log_file\" working directory log4r_step() function flexible allowing log4r appender used. Running following data validation code show us messages R console file \"pb_log_file\" can looked readLines(), showing us four entries (one validation step least WARN condition). log4r_step() function bit special provides severe condition given validation step, long function call present multiple conditions list() given action_levels()‚Äôs fns argument. ‚Äôs possible provide custom-made function generates side effect way log4r_step() used. Just like log4r_step(), custom function can take advantage x variable, x-list validation step. Let‚Äôs take look step 2 (col_vals_in_set validation step) using get_agent_x_list() function: message console shows us ‚Äôs available x, indication output types. wanted know number test units, fraction failed, whether STOP condition entered, can access even put character string (along info x-list). great way test function use validation step ‚Äòaction‚Äô invoked undergo evaluation environment contains x (structure).","code":"al <- action_levels(warn_at = 0.1, stop_at = 0.2) al ‚îÄ‚îÄ The `action_levels` settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ WARN failure threshold of 0.1 of all test units. STOP failure threshold of 0.2 of all test units. ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ agent <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"VALID-I Example No. 2\",     actions = al   ) %>%   col_is_posix(vars(date_time)) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\")) %>%   col_vals_lt(vars(a), value = 7) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-w]{3}-[2-9]{3}$\") %>%   col_vals_between(vars(d), left = 0, right = 4000) %>%   interrogate() ‚îÄ‚îÄ Interrogation Started - there are 5 steps ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚úì Step 1: OK. x Step 2: STOP condition met. ! Step 3: WARNING condition met. x Step 4: STOP condition met. ! Step 5: WARNING condition met.  ‚îÄ‚îÄ Interrogation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ agent al <-    action_levels(     warn_at = 0.1,     stop_at = 0.2,     fns = list(       warn = ~ log4r_step(x),       stop = ~ log4r_step(x)     )   ) al ‚îÄ‚îÄ The `action_levels` settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ WARN failure threshold of 0.1 of all test units. \\fns\\ ~ log4r_step(x) STOP failure threshold of 0.2 of all test units. \\fns\\ ~ log4r_step(x) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ agent <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"VALID-I Example No. 3\",     actions = al   ) %>%   col_is_posix(vars(date_time)) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\")) %>%   col_vals_lt(vars(a), value = 7) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-w]{3}-[2-9]{3}$\") %>%   col_vals_between(vars(d), left = 0, right = 4000) %>%   interrogate() ‚îÄ‚îÄ Interrogation Started - there are 5 steps ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚úì Step 1: OK. x Step 2: STOP condition met. ! Step 3: WARNING condition met. x Step 4: STOP condition met. ! Step 5: WARNING condition met.  ‚îÄ‚îÄ Interrogation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ readLines(\"pb_log_file\") [1] \"ERROR [2020-11-06 01:26:07] Step 2 exceeded the STOP failure threshold (f_failed = 0.46154) ['col_vals_in_set']\"  [2] \"WARN  [2020-11-06 01:26:07] Step 3 exceeded the WARN failure threshold (f_failed = 0.15385) ['col_vals_lt']\"      [3] \"ERROR [2020-11-06 01:26:07] Step 4 exceeded the STOP failure threshold (f_failed = 0.53846) ['col_vals_regex']\"   [4] \"WARN  [2020-11-06 01:26:07] Step 5 exceeded the WARN failure threshold (f_failed = 0.07692) ['col_vals_between']\" x <- get_agent_x_list(agent, i = 2) x ‚îÄ‚îÄ The x-list for STEP 2 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ $time_start $time_end (POSIXct [1]) $label $tbl_name $tbl_src $tbl_src_details (chr [1]) $tbl (spec_tbl_df, tbl_df, tbl, and data.frame) $col_names $col_types (chr [8]) $i $type $columns $values $label $briefs (mixed [1]) $eval_error $eval_warning (lgl [1]) $capture_stack (list [1]) $n $n_passed $n_failed $f_passed $f_failed (num [1]) $warn $stop $notify (lgl [1]) $lang (chr [1]) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ glue::glue(   \"In Step {x$i}, there were {x$n} test units and {x$f_failed * 100}% \\\\   failed. STOP condition met: {tolower(x$stop)}.\"   ) In Step 2, there were 13 test units and 46.154% failed. STOP condition met: true."},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-II.html","id":"an-example-of-this-workflow","dir":"Articles","previous_headings":"","what":"An Example of This Workflow","title":"Introduction to the **Pipeline Data Validation** Workflow (**VALID-II**)","text":"Let‚Äôs adapt example used VALID-: Data Quality Reporting Workflow article pipeline data validation workflow: terms expressions used pipeline, might notice create_agent() interrogate() functions absent. due secondary role validation functions, can operate directly immediately data, acting sort filter. validations pipeline pass (.e., failing test units validation steps), small_table data returned. Otherwise, ‚Äôs currently written, stoppage occur failure. turns , validation pipeline result error. stringent default threshold setting stops evaluation pipeline point failure (one test units failing). , turn, stops running script (key consideration script deployed automatically running sort schedule). type workflow don‚Äôt need define functions, pointblank automatically sensible thing stopping evaluation providing stock message. , first instance stoppage due validation failing, R scripts stop point R Markdown documents correspondingly cease render.","code":"small_table %>%   col_is_posix(vars(date_time)) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\", \"high\")) %>%   col_vals_lt(vars(a), value = 10) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\") %>%   col_vals_between(vars(d), left = 0, right = 5000) ## Error: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. ## The `col_vals_between()` validation failed beyond the absolute threshold level (1). ## * failure level (1) >= failure threshold (1)"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-II.html","id":"modifying-the-behavior-of-validation-failures","dir":"Articles","previous_headings":"","what":"Modifying the Behavior of Validation Failures","title":"Introduction to the **Pipeline Data Validation** Workflow (**VALID-II**)","text":"ways counteract stopping behavior seen previous example. R Markdown document, set chunk option error = TRUE might expect error occur due validation failure (allowing execution continue matter happens). ‚Äôs done small_table example document, giving us error message printed input. Another way disable evaluation step level use active = FALSE option every validation function shouldn‚Äôt evaluated. works R scripts R Markdown documents quite different since can‚Äôt determine whether validation passed failed since doesn‚Äôt actually perform check (simply skips ). useful, however, want enable staged checks use data validations sort ‚Äòdebug mode‚Äô since global variables logical can passed active argument specific validation functions. Another strategy stop() instead warn().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-II.html","id":"using-warn_on_fail-and-stop_on_fail-functions-to-generate-simple-action_levels","dir":"Articles","previous_headings":"","what":"Using warn_on_fail() and stop_on_fail() functions to generate simple action_levels","title":"Introduction to the **Pipeline Data Validation** Workflow (**VALID-II**)","text":"two helper functions convenient workflow: warn_on_fail() stop_on_fail(). functions return action_levels object either warns stops, informative warning error messages. default failure threshold set 1: one fail unit means threshold WARN FAIL condition met. stop_on_fail() helper (behind scenes) applied default using validation functions VALID-II workflow. , previous example exactly expanded form: want instead issue warnings, perhaps less stringent failure thresholds certain steps, warn_on_fail() function provides simple way express . warn_on_fail() stop_on_fail() handy ways generate action_levels objects actions argument every validation function, doesn‚Äôt provide way specify actions. , ‚Äôll need use action_levels() function directly.","code":"small_table %>%   col_is_posix(     vars(date_time),     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_in_set(     vars(f), set = c(\"low\", \"mid\", \"high\"),     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_lt(     vars(a), value = 10,     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_regex(     vars(b), regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\",     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_between(     vars(d), left = 0, right = 5000,     actions = stop_on_fail(stop_at = 1)   ) ## Error: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. ## The `col_vals_between()` validation failed beyond the absolute threshold level (1). ## * failure level (1) >= failure threshold (1) small_table %>%   col_is_posix(     vars(date_time),     actions = warn_on_fail()   ) %>%   col_vals_in_set(     vars(f), set = c(\"low\", \"mid\", \"high\"),     actions = warn_on_fail(warn_at = 0.2)   ) %>%   col_vals_lt(     vars(a), value = 10,     actions = warn_on_fail(warn_at = 3)   ) %>%   col_vals_regex(     vars(b), regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\",     actions = warn_on_fail(warn_at = 0.2)   ) %>%   col_vals_between(     vars(d), left = 0, right = 5000,     actions = warn_on_fail(warn_at = 1)   ) ## Warning: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. ## The `col_vals_between()` validation failed beyond the absolute threshold level (1). ## * failure level (1) >= failure threshold (1) ## # A tibble: 13 √ó 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-II.html","id":"using-action_levels-for-more-control","dir":"Articles","previous_headings":"","what":"Using action_levels() for More Control","title":"Introduction to the **Pipeline Data Validation** Workflow (**VALID-II**)","text":"action_levels() function can useful VALID-workflow agent. function creates action_levels object can two roles: (1) specification threshold failure levels entering certain conditions (WARN, STOP, NOTIFY), (2) setting actions (.e., function calls invoke) entering specific condition. fns argument action_levels() allows us define custom functions evaluated upon entering three states (acts ‚Äòstep‚Äô level, per validation function). Compared VALID-workflow, deals reporting, actions triggered failures VALID-II workflow probably useful important. can imagine situation R script deployed data validation interspersed throughout. Depending deployment, may desire hard stop (affecting downstream components), , may want softer approach warning logging. Let‚Äôs try hybrid approach three available conditions failure threshold levels set associated function invoke. functions invoke condition can whatever makes sense workflow (.e., don‚Äôt issue warnings WARN condition want something else). , use warning() WARN, stop() STOP, logging function (log4r_step()) NOTIFY. ‚Äôs might create action_levels object action_levels(): assigned action_levels object (case, al) can print get summary settings. Finally, apply object every validation function call expression (changed slightly result test units failing). addition error warning, log4r_step() function used NOTIFY condition generates, case, new \"pb_log_file\" text file logs. can examine readLines(); single entry relates Step 1 (col_vals_in_set() step): log4r_step() function offered pointblank shown examples explained detail VALID-: Data Quality Reporting Workflow article.","code":"al <-    action_levels(     warn_at = 0.1,     stop_at = 0.2,     notify_at = 0.3,     fns = list(       warn = ~ warning(\"WARN threshold exceeded.\"),       stop = ~ stop(\"STOP threshold exceeded.\"),       notify = ~ log4r_step(x)     )   ) al ‚îÄ‚îÄ The `action_levels` settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ WARN failure threshold of 0.1 of all test units. \\fns\\ ~ warning(\"WARN threshold exceeded.\") STOP failure threshold of 0.2 of all test units. \\fns\\ ~ stop(\"STOP threshold exceeded.\") NOTIFY failure threshold of 0.3 of all test units. \\fns\\ ~ log4r_step(x) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ small_table %>%   col_is_posix(vars(date_time), actions = al) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\"), actions = al) %>%   col_vals_lt(vars(a), value = 7, actions = al) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-w]{3}-[2-9]{3}$\", actions = al) %>%   col_vals_between(vars(d), left = 0, right = 4000, actions = al) ## Warning in rlang::eval_tidy(.): WARN threshold exceeded. ## Error in rlang::eval_tidy(.): STOP threshold exceeded. readLines(\"pb_log_file\") FATAL [2020-11-09 00:23:48] Step 1 exceeded the NOTIFY failure threshold (f_failed = 0.46154) ['col_vals_in_set']"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-III.html","id":"using-expect_-functions-in-the-testthat-way","dir":"Articles","previous_headings":"","what":"Using expect_*() Functions in the testthat Way","title":"Introduction to the **Expectations in Unit Tests** Workflow (**VALID-III**)","text":"testthat package collection functions begin expect_. ‚Äôs coincidence pointblank VALID-III workflow adopts naming convention. idea use functions interchangeably testthat standard testthat workflow (test-<name>.R file, inside tests/testthat folder). big difference instead testing function outputs, testing data tables. However, tables may returned function calls expect_*() functions offered pointblank might offer flexibility testing data. instance expect_col_vals_between() allows us write expectation fine control boundary values (whether inclusive bounds), whether NA values ignored, can even set failure threshold makes sense expectation. ‚Äôs example generate tests data testthat also pointblank. small_table dataset, let‚Äôs write expectations show non-NA values column c 2 9. testthat function tests values two values. original strategy use testthat::expect_gte() testthat::lte() small_table$c object , however, doesn‚Äôt work results logical vector greater length 1. Also, allowance NA values skipped. best . pointblank version task makes succinct understandable expectation expression: arguments expect_col_vals_between() give us everything need check tabular data without subsetting perform transformations. added benefits. data come data source locals data frame, SQL expressions handled internally tested extensively across supported database types Spark DataFrames well.","code":"testthat::expect_true(all(na.omit(small_table$c) >= 2)) testthat::expect_true(all(na.omit(small_table$c) <= 9)) expect_col_vals_between(small_table, vars(c), 2, 9, na_pass = TRUE)"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-III.html","id":"these-expect_-functions-are-simpler-than-their-counterparts","dir":"Articles","previous_headings":"","what":"These expect_*() Functions Are Simpler Than Their Counterparts","title":"Introduction to the **Expectations in Unit Tests** Workflow (**VALID-III**)","text":"expect_*() functions leading arguments validation function counterparts omit following arguments end signatures: actions step_id label brief active lose actions argument, get place threshold argument. simple failure threshold value use expectation (expect_*) test (test_*) functions. default, threshold set 1 means single test unit failing result overall failure (.e., expectation fail). thresholds set action_levels() functions (shortcut functions warn_on_fail() stop_on_fail()), whole numbers beyond 1 indicate failing units absolute threshold value result succeeding expectation. Likewise, fractional values (0 1) act proportional failure threshold, 0.25 means 25% failing test units results failed expectation. preconditions argument can used transform input data evaluation expectation. useful cases might need summarize input data table, mutate columns, perform filtering, even perform table joins beforehand.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-IV.html","id":"exactly-like-the-expect_-functions-except-you-get-a-true-or-false","dir":"Articles","previous_headings":"","what":"Exactly Like the expect_*() Functions Except You Get a TRUE or FALSE","title":"Introduction to the **Data Tests for Conditionals** Workflow (**VALID-IV**)","text":"interface test_*() function exact match expect_*() counterpart. haven‚Äôt used either used standard validation functions, ‚Äôs quick rundown. following arguments validation functions (e.g., col_vals_in_set() many ) removed corresponding test_*() functions: actions step_id label brief active Instead actions get threshold argument simplified replacement. ‚Äôs supplied single failure threshold value. default set 1 meaning single test fails result overall failure return FALSE (otherwise, TRUE). rules threshold setting (action_levels(), warn_on_fail(), stop_on_fail()) explained detail . Whole numbers beyond 1 indicate failing units absolute threshold value result TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.25 means 25% failing test units results FALSE. can use preconditions argument cases ‚Äôd like transform input data evaluation test. like things input table like summarize , perform filtering, mutate one columns, perform table joins, etc., good way go .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-IV.html","id":"heres-several-examples-quick-snap","dir":"Articles","previous_headings":"","what":"Here‚Äôs Several Examples Quick Snap","title":"Introduction to the **Data Tests for Conditionals** Workflow (**VALID-IV**)","text":"Let‚Äôs examples leaving article. use small_table: ‚Äôd like test pointblank validation skill, guess whether TRUE FALSE hovering line code. . nice set examples revealing truthy/falsy nature ::closer inspection.","code":"small_table ## # A tibble: 13 √ó 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-V.html","id":"an-example-with-the-palmer-penguins-dataset","dir":"Articles","previous_headings":"","what":"An Example with the Palmer Penguins Dataset","title":"Introduction to the **Table Scan** Workflow (**VALID-V**)","text":"output HTML report appear RStudio Viewer can also integrated R Markdown HTML output. ‚Äôs example uses penguins_raw dataset palmerpenguins package. scan_data() call, option deactivate display navigation bar taken navbar = FALSE, makes sense integrating type output larger document. seen, first two sections lot additional information tucked behind detail views (Toggle details buttons) within tab sets. amount information little overwhelming, option disable one sections. scan_data()‚Äôs sections argument, can specify just sections needed specific scan. default value sections string \"OVICMS\" letter stands following sections default order: \"O\": \"overview\" \"V\": \"variables\" \"\": \"interactions\" \"C\": \"correlations\" \"M\": \"missing\" \"S\": \"sample\". string can contain less key characters order can changed suit desired layout report. example, just need Overview, Sample, description Variables target table, string use sections \"OSV\". Just workflows, tbl supplied data frame, tibble, tbl_dbi object, tbl_spark object. However, one limitation scan_data(): tbl_dbi tbl_spark objects, Interactions Correlations sections currently excluded.","code":"scan_data(palmerpenguins::penguins_raw, navbar = FALSE)"},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-V.html","id":"languages-and-locales","dir":"Articles","previous_headings":"","what":"Languages and Locales","title":"Introduction to the **Table Scan** Workflow (**VALID-V**)","text":"reporting generated scan_data() can presented one eight spoken languages: English (\"en\", default), French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese, (\"pt\"), Chinese (\"zh\"), Russian (\"ru\"). two-letter language codes can used argument lang argument. applied, label text non-data elements set language choice. checked translations native speakers respective languages find error corrected, please file issue. Along translations, numerical values generated part reporting (e.g., table dimensions, summary statistics, etc.) automatically formatted locale language (given lang). can overridden locale argument accepts locale ID. Examples include \"en_US\" English (United States) \"fr_FR\" French (France). simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). 700 locales currently accepted.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-VI.html","id":"how-it-works","dir":"Articles","previous_headings":"","what":"How It Works","title":"Introduction to the **R Markdown Document Validation** Workflow (**VALID-VI**)","text":"Using pointblank VALID-VI workflow enabled default pointblank library loaded (best done setup chunk). framework allows validation testing within specialized validation code chunks validate = TRUE option set. Using pointblank validation functions data (VALID-II workflow) marked code chunks flag overall failure stop threshold exceeded anywhere. errors shown rendering document HTML. Green status buttons indicate validations succeeded, red buttons indicate one validation failures occurred. Clicking button reveals otherwise hidden validation statements associated messaging. ‚Äôs much better demonstrate workflow works series examples, resulting output interactive varies quite bit depending input. following examples, code chunk shown rendered result subsequently placed. result typically button can pressed reveal validation result code chunk hidden upon rendering (‚Äôs need use include = FALSE chunk option). start things , ‚Äôs example uses expression takes small_table dataset pipes two validation functions: col_is_date() col_vals_in_set(). col_is_date() validation passes whereas col_vals_in_set() validation fails (set values column f also \"high\" value.  Clicking 1 validation failed. button reveal expression failed validation validation function failing within . break , really one validation step chain passed (first one) one failed (second). additional validation steps otherwise pass, ‚Äôd still get result output failing step ends execution. workflow meant stop expression executing first validation function fails, ‚Äôs advisable break validations single steps. way, expression single validation either passes fails reported accordingly. Let‚Äôs rewrite example two expressions, one per validation.  still says 1 validation failed. (workflow focuses negatives) pressing button reveals first one passed second failed. much clearer don‚Äôt run risk evaluating validations validation failed earlier pipeline. ‚Äôs example validations individual expressions pass, showing us green status button.  ‚Äôs worth reminding point failed validations stop execution R Markdown rendering. Otherwise wouldn‚Äôt see document failing validations, , wouldn‚Äôt know failed validations occurred. expectation workflow add relevant validation expressions key junctures failures occur, one can fix underlying issues (enough) validations pass.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-VI.html","id":"the-pointblank-stop_if_not-function","dir":"Articles","previous_headings":"","what":"The pointblank stop_if_not() Function","title":"Introduction to the **R Markdown Document Validation** Workflow (**VALID-VI**)","text":"may want use set validation functions everything. Perhaps using stopifnot() sufficient validations. case, consider using pointblank variation : stop_if_not(). works well enough standalone, replacement stopifnot() advantage stop_if_not() customized use VALID-VI workflow (situation ‚Äôre using R Markdown render HTML, pointblank loaded via library()). Ultimately, using stop_if_not() code chunk validate = TRUE option set yield correct reporting successes failures whereas stopifnot() . ‚Äôs code chunk uses stop_if_not() twice check two different assertions small_table object. first one passes whereas second one fails.  Keep mind stop_if_not() (like stopifnot()) can used type assertion. ‚Äôs limited checking tables like functions pointblank focused .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-VI.html","id":"including-data-quality-reporting-from-the-valid-i-workflow","dir":"Articles","previous_headings":"","what":"Including Data Quality Reporting from the VALID-I Workflow","title":"Introduction to the **R Markdown Document Validation** Workflow (**VALID-VI**)","text":"Code chunks can include data quality reporting expressions (.e., agent-based VALID-workflow) ‚Äôs important ensure two things. ‚Äôs interesting thing : can opt use validate = TRUE chunk option omit entirely, choice different effect. ‚Äôd like hide validation output (Agent Report) behind button (case, light blue one) validate = TRUE used. ‚Äôs example data quality validation workflow executed single code chunk.  code chunk exclude validate = TRUE option, output appear output normally (input appears output report table). just want output reporting table shown without input expressions, use include = FALSE chunk option . final note , ‚Äôs important use expressions result output, just stick typical create_agent() ‚Üí <validation functions> ‚Üí interrogate() pattern. words, dedicate code chunk just agent put validation expressions elsewhere document.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/articles/VALID-VI.html","id":"setting-up-options-with-the-validate_rmd-function","dir":"Articles","previous_headings":"","what":"Setting Up Options with the validate_rmd() Function","title":"Introduction to the **R Markdown Document Validation** Workflow (**VALID-VI**)","text":"can modify pointblank validation testing options within R Markdown documents validate_rmd() function. framework testing set default, using validate_rmd() offers opportunity set UI logging options. summary argument, TRUE (default), leading summary validations rendered R Markdown document. FALSE, element shown. document, validate_rmd(summary = FALSE) placed setup chunk (right library(pointblank) statement) resulted suppressing display overall summary validation results. log_to_file argument, ‚Äôs option log errors text file. default, logging done setting log_to_file == TRUE write log entries \"validation_errors.log\" file working directory (generated non-existent, appended available). enable logging specify name file, include path log file (desired name) log_to_file.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Richard Iannone. Author, maintainer. Mauricio Vargas. Author.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Iannone R, Vargas M (2021). pointblank: Data Validation Organization Metadata Local Remote Tables. https://rich-iannone.github.io/pointblank/, https://github.com/rich-iannone/pointblank.","code":"@Manual{,   title = {pointblank: Data Validation and Organization of Metadata for Local and Remote Tables},   author = {Richard Iannone and Mauricio Vargas},   year = {2021},   note = {https://rich-iannone.github.io/pointblank/, https://github.com/rich-iannone/pointblank}, }"},{"path":"https://rich-iannone.github.io/pointblank/es/index.html","id":null,"dir":"","previous_headings":"","what":"Data Validation and Organization of Metadata for Local and Remote Tables","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"pointblank package ‚Äôs really easy methodically validate data whether form data frames database tables. top validation toolset, package gives means provide keep --date information defines tables. table validation, agent object works large collection simple (yet powerful!) validation functions. can enable much sophisticated validation checks using custom expressions also stepwise mutation target table (something call preconditions). Sometimes want maintain table information update table goes changes. , can use informant object + associated functions help define metadata entries present way suits .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Want try ? pointblank package available CRAN: can also install development version pointblank GitHub: encounter bug, usage questions, want share ideas make package better, feel free file issue.","code":"install.packages(\"pointblank\") devtools::install_github(\"rich-iannone/pointblank\")"},{"path":"https://rich-iannone.github.io/pointblank/es/index.html","id":"lets-discuss","dir":"","previous_headings":"","what":"Let‚Äôs Discuss!","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Let‚Äôs talk data validation data documentation pointblank Discussions! ‚Äôs great place ask questions use package, discuss ideas, engage others, much !","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Please note pointblank project released contributor code conduct. participating project agree abide terms.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/index.html","id":"-license","dir":"","previous_headings":"","what":"üìÑ License","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"pointblank licensed MIT license. See LICENSE.md file details.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/index.html","id":"Ô∏è-governance","dir":"","previous_headings":"","what":"üèõÔ∏è Governance","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"project primarily maintained Rich Iannone. authors may occasionally assist duties.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/action_levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Establecer niveles de acci√≥n: umbrales de falla y funciones para invocar ‚Äî action_levels","title":"Establecer niveles de acci√≥n: umbrales de falla y funciones para invocar ‚Äî action_levels","text":"La funci√≥n action_levels() trabaja con el argumento actions que est√° presente en la funci√≥n create_agent() y en cada funci√≥n de paso de validaci√≥n (que tambi√©n tiene un argumento actions). Con √©l, podemos proporcionar niveles de umbral falla para cualquier combinaci√≥n de estados de warn, stop o notify. Podemos reaccionar ante cualquier entrada de un estado proporcionando las funciones correspondientes al argumento fns. Se someter√°n evaluaci√≥n en el momento en que se ingrese al estado de coincidencia. Si se proporciona create_agent(), las pol√≠ticas se aplicar√°n cada paso de validaci√≥n, actuando de forma predeterminada para la validaci√≥n en su conjunto. Las llamadas de action_levels() tambi√©n podr√≠an aplicarse directamente cualquier paso de validaci√≥n y esto actuar√° como una anulaci√≥n si se establece tambi√©n en create_agent(). Se requiere el uso de action_levels() para tener efectos secundarios √∫tiles (es decir, advertencias, errores de lanzamiento) en el caso de funciones de validaci√≥n que operan directamente sobre los datos (p. Ej., mtcars %>% col_vals_lt(\"mpg\", 35)). Hay dos funciones auxiliares que son convenientes cuando se usan funciones de validaci√≥n directamente en datos (el flujo de trabajo sin agent): warn_on_fail() y stop_on_fail(). Estos ayudantes advierten o se detienen (el umbral de falla predeterminado para cada uno se establece en 1) y lo hacen con advertencias informativas o mensajes de error. El ayudante stop_on_fail() se aplica de forma predeterminada cuando se utilizan funciones de validaci√≥n directamente en los datos (se proporciona m√°s informaci√≥n sobre esto en Detalles).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/action_levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Establecer niveles de acci√≥n: umbrales de falla y funciones para invocar ‚Äî action_levels","text":"","code":"action_levels(warn_at = NULL, stop_at = NULL, notify_at = NULL, fns = NULL)  warn_on_fail(warn_at = 1)  stop_on_fail(stop_at = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/action_levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Establecer niveles de acci√≥n: umbrales de falla y funciones para invocar ‚Äî action_levels","text":"warn_at, stop_at, notify_at El n√∫mero de umbral o fracci√≥n de unidades de prueba que pueden proporcionar una fallar resultado antes de entrar en las warn, stop o notify estados de fallo. Si este es un valor decimal entre 0 y 1 entonces es un umbral de falla proporcional (por ejemplo, 0.15 indica que si se encuentra que el 15% por ciento de las unidades de prueba fallan, entonces se ingresa el estado de falla designado). En 1 su lugar, se pueden usar valores absolutos partir de, y esto constituye un umbral de falla absoluto (por ejemplo, 10 significa que si se encuentra que 10 de las unidades de prueba fallan , se ingresa el estado de falla). fns Una lista nombrada de funciones que se emparejar√° con los estados de falla apropiados. La sintaxis para esta lista implica el uso de nombres de estado fracaso desde el conjunto de warn, stop y notify. Las funciones correspondientes los estados de falla se proporcionan como f√≥rmulas (por ejemplo list(warn = ~ warning(\"many failures.\"))). Se puede usar una serie de expresiones para cada estado nombrado encerrando el conjunto de declaraciones con { }.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/action_levels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Establecer niveles de acci√≥n: umbrales de falla y funciones para invocar ‚Äî action_levels","text":"El resultado de la action_levels() llamada actionsse interpretar√° de forma ligeramente diferente si se usa un agente o se usan funciones de validaci√≥n directamente en una tabla de datos. Por conveniencia, cuando se trabaja directamente con datos, cualquier valor suministrado warn_at o stop_at se le asignar√° autom√°ticamente un stock warning() o stop() funci√≥n. Por ejemplo, el uso small_table %>% col_is_integer(\"date\") proporcionar√° un mensaje de detenci√≥n detallado de forma predeterminada, que indica el motivo del error. Si tuviera que suministrar el fns stop o warn manualmente, las funciones de stock se anular√≠an. Adem√°s, si actionses NULL en este flujo de trabajo (el predeterminado), pointblank usar√° un stop_at valor de 1 (que proporciona un mensaje de error detallado y espec√≠fico del contexto si hay unidades que fallan). Podemos suprimir absolutamente este comportamiento de parada autom√°tica en cada paso de validaci√≥n mediante la configuraci√≥n active = FALSE. En este caso de datos interactivos, se proporciona una funci√≥n de stock para notify_at. El notifyestado de falla se usa con menos frecuencia en este flujo de trabajo que en el basado en agente . Cuando se utiliza un agente , menudo opta por utilizar ninguna funci√≥n en la fns que el warn, stop y notify ser√°n reportados en los estados de insuficiencia cuando se usa create_agent_report() (y, por lo general eso es suficiente). En cambio, usar el end_fns argumento es una mejor opci√≥n, ya que ese esquema proporciona datos √∫tiles sobre todo el interrogatorio, lo que permite un control m√°s preciso de los efectos secundarios y reduce la posibilidad de duplicar los efectos secundarios.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/action_levels.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Establecer niveles de acci√≥n: umbrales de falla y funciones para invocar ‚Äî action_levels","text":"1-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/action_levels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Establecer niveles de acci√≥n: umbrales de falla y funciones para invocar ‚Äî action_levels","text":"","code":"# Para estos ejemplos, usaremos el conjunto # de datos `small_table` incluido small_table #> # A tibble: 13 √ó 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # Crea un objeto `action_levels` con valores # fraccionarios para el `warn_at`, # `stop_at` y `notify_at` estados al <-    action_levels(     warn_at = 0.2,     stop_at = 0.8,     notify_at = 0.5   )    # Un resumen de la configuraci√≥n de `al` # El objeto se muestra imprimi√©ndolo al #> ‚îÄ‚îÄ The `action_levels` settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> WARN failure threshold of 0.2 of all test units. #> STOP failure threshold of 0.8 of all test units. #> NOTIFY failure threshold of 0.5 of all test units. #> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # Cree un agente a quemarropa y # aplicar el objeto `al` a las `actions`; # agregue dos pasos de validaci√≥n y # interrogar a la `small_table` agent_1 <-   create_agent(     tbl = small_table,     actions = al   ) %>%   col_vals_gt(     vars(a), value = 2   ) %>%   col_vals_lt(     vars(d), value = 20000   ) %>%   interrogate()  # El informe del agente mostrar√° # que se ha entrado en el estado de advertencia # para el primer paso de validaci√≥n pero no # el segundo; podemos confirmar esto # en la consola inspeccionando el # Componente `warn` en la x-list del agente x_list <- get_agent_x_list(agent_1) x_list$warn #> [1]  TRUE FALSE  # Aplicar el objeto `action_levels` # para el agente significa que toda # validaci√≥n los pasos heredar√°n esta # configuraci√≥n, pero podemos anular # esto aplicando otro objeto similar a # la validaci√≥n paso en su lugar (esta # vez usando el `warn_on_fail()` # abreviatura) agent_2 <-   create_agent(     tbl = small_table,     actions = al   ) %>%   col_vals_gt(     vars(a), value = 2,     actions = warn_on_fail(warn_at = 0.5)   ) %>%   col_vals_lt(     vars(d), value = 20000   ) %>%   interrogate()  # En este caso, la primera validaci√≥n # el paso tiene una falla menos estricta # umbral para el estado de advertencia y es # lo suficientemente alto como para que la # condici√≥n no sea ingres√≥; esto se puede # confirmar en el consola a trav√©s de la # inspecci√≥n de la componente x-list `warn` x_list <- get_agent_x_list(agent_2) x_list$warn #> [1] FALSE FALSE  if (interactive()) {  # En el contexto del uso de la validaci√≥n # funciona directamente en los datos (es # decir, no participaci√≥n de un agente) # queremos desencadenar advertencias y # generar errores; los siguiente dar√° una # advertencia si se ejecuta (devolviendo el # datos de `small_table`) small_table %>%   col_vals_gt(     vars(a), value = 2,     actions = warn_on_fail(warn_at = 2)   )  # Con el mismo oleoducto, no suministrando # cualquier cosa para `actions` (es` NULL` # por predeterminado) tendr√° el mismo # efecto que usando `stop_on_fail (stop_at = 1)` small_table %>%   col_vals_gt(vars(a), value = 2)  small_table %>%   col_vals_gt(     vars(a), value = 2,     actions = stop_on_fail(stop_at = 1)   )  # Esto se debe a que el `stop_on_fail()` # la llamada se inyecta autom√°ticamente # de forma predeterminada caso (cuando # se opera con datos) para su conveniencia; # detr√°s de escena un agente secreto' utiliza # 'acciones encubiertas': todo para que # puedas escribir menos  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/activate_steps.html","id":null,"dir":"Reference","previous_headings":"","what":"Activar uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî activate_steps","title":"Activar uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî activate_steps","text":"Si es necesario activar ciertos pasos de validaci√≥n despu√©s de la creaci√≥n del plan de validaci√≥n para un agent, use la funci√≥n active_steps(). Este es equivalente usar active = TRUE para los pasos de validaci√≥n seleccionados (active es un argumento en todas las funciones de validaci√≥n). Esto reemplazar√° cualquier funci√≥n que puede haber sido definida para el argumento active durante la creaci√≥n de los pasos de validaci√≥n espec√≠ficos.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/activate_steps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Activar uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî activate_steps","text":"","code":"activate_steps(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/activate_steps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Activar uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî activate_steps","text":"agent Un objeto de agente de clase ptblank_agent. El n√∫mero de paso de validaci√≥n, que se asigna cada paso de validaci√≥n en el orden de definici√≥n.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/activate_steps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Activar uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî activate_steps","text":"Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/activate_steps.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Activar uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî activate_steps","text":"9-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/activate_steps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Activar uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî activate_steps","text":"","code":"# Cree un agente que tenga objeto # `small_table` como el tabla de  # destino, agregue algunos inactivos # pasos de validaci√≥n, y luego use # `interrogar()` agent_1 <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%   col_exists(     vars(date),     active = FALSE   ) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     active = FALSE   ) %>%   interrogate() #> ‚Ñπ Step 1 is not set as active. Skipping. #> ‚Ñπ Step 2 is not set as active. Skipping.  # En lo anterior, los datos son no # realmente interrogado porque el # ajuste `active` fue `FALSE` en # todos los pasos; nosotros puede # cambiar esto de forma selectiva # con `active_steps()` agent_2 <-   agent_1 %>%   activate_steps(i = 1) %>%   interrogate() #> ‚Ñπ Step 2 is not set as active. Skipping."},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Ponga la fecha actual en un nombre de archivo ‚Äî affix_date","title":"Ponga la fecha actual en un nombre de archivo ‚Äî affix_date","text":"Esta funci√≥n ayuda fijar la fecha actual un nombre de archivo. Esto es √∫til al escribir objetos agent y informante en el disco como parte de un proceso continuo. La fecha puede ser en t√©rminos de hora UTC o del sistema local. tiempo. La fecha se puede colocar al final del nombre del archivo (antes del extensi√≥n de archivo) o al principio con un delimitador personalizable. Las funciones x_write_disk(), yaml_write() permiten la escritura de objetos pointblank al disco. Adem√°s, la funci√≥n log4r_step() tiene el argumento append_to que acepta nombres de archivo, y es razonable que un La serie de archivos de registro se puede diferenciar por un componente de fecha en el nombre esquema. La modificaci√≥n de la cadena del nombre del archivo tiene efecto inmediatamente, pero en el momento de escribir un archivo en el disco. En la mayor√≠a de los casos, especialmente cuando usando affix_date() con las funciones de escritura de archivos antes mencionadas, el archivo las marcas de tiempo deben aproximarse los componentes de tiempo fijados los nombres de archivo.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ponga la fecha actual en un nombre de archivo ‚Äî affix_date","text":"","code":"affix_date(   filename,   position = c(\"end\", \"start\"),   format = \"%Y-%m-%d\",   delimiter = \"_\",   utc_time = TRUE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ponga la fecha actual en un nombre de archivo ‚Äî affix_date","text":"filename El nombre de archivo que se va modificar. position D√≥nde colocar la fecha formateada. Esto podr√≠a estar al \"end\" del nombre del archivo (el predeterminado) o al \"start\". format Una cadena de formato base::strptime() para formatear la fecha. Por predeterminado, esto es \"%Y-%m-%d\" que expresa la fecha de acuerdo con la ISO 8601 est√°ndar (como 'AAAA-MM-DD'). Consulte la documentaci√≥n en base::strptime() para las especificaciones de conversi√≥n si planea usar un cadena de formato diferente. delimiter Los caracteres delimitadores que se utilizar√°n para separar la fecha. cadena del nombre del archivo original. utc_time Una opci√≥n para utilizar la hora UTC actual para establecer la fecha (la predeterminada, con TRUE), o, utilizar el local del sistema tiempo (FALSE).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ponga la fecha actual en un nombre de archivo ‚Äî affix_date","text":"Un vector de caracteres.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_date.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Ponga la fecha actual en un nombre de archivo ‚Äî affix_date","text":"13-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ponga la fecha actual en un nombre de archivo ‚Äî affix_date","text":"","code":"# Tomando el nombre gen√©rico de `pb_file` # para un archivo, le agregamos la fecha # actual como sufijo affix_date(filename = \"pb_file\") #> [1] \"pb_file_2021-12-15\"  # Las extensiones de archivo no se # interpondr√°n en el camino: affix_date(filename = \"pb_file.rds\") #> [1] \"pb_file_2021-12-15.rds\"  # La fecha se puede utilizar como prefijo affix_date(   filename = \"pb_file\",   position = \"start\" ) #> [1] \"2021-12-15_pb_file\"  # El patr√≥n de fecha se puede cambiar # y as√≠ puede el delimitador affix_date(   filename = \"pb_file.yml\",   format = \"%Y%m%d\",   delimiter = \"-\" ) #> [1] \"pb_file-20211215.yml\"  if (interactive()) {  # Podemos usar una convenci√≥n de # nomenclatura de archivos que # involucran fechas al escribir la # salida archivos inmediatamente # despu√©s de interrogar; √∫til al # interrogar directamente de YAML # en un proceso programado yaml_agent_interrogate(   filename = system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) ) %>%    x_write_disk(     filename = affix_date(       filename = \"small_table_agent.rds\",       delimiter = \"-\"     ),     keep_tbl = TRUE,     keep_extracts = TRUE   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_datetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Ponga la fecha y hora actual en un nombre de archivo ‚Äî affix_datetime","title":"Ponga la fecha y hora actual en un nombre de archivo ‚Äî affix_datetime","text":"Esta funci√≥n ayuda fijar la fecha y hora actual un nombre de archivo. Este es √∫til al escribir objetos agent y informant en el disco como parte de un proceso continuo. La cadena de fecha y hora puede basarse en la hora UTC actual. o la hora del sistema local. La fecha y hora se puede colocar al final de el nombre del archivo (antes de la extensi√≥n del archivo) o al principio con un delimitador personalizable. Opcionalmente, la informaci√≥n de la zona horaria puede ser incluido. Si la fecha y hora se basa en la hora del sistema local, el sistema del usuario La zona horaria se muestra con el formato <time>(+/-)hhmm. Si usa la hora UTC, entonces se adopta el formato <time>Z. Las funciones x_write_disk(), yaml_write() permiten la escritura de objetos pointblank al disco. La modificaci√≥n de la cadena de nombre de archivo toma efecto inmediatamente, pero en el momento de escribir un archivo en el disco. En la mayor√≠a casos, especialmente cuando se usa affix_datetime() con el mencionado funciones de escritura de archivos, las marcas de tiempo del archivo deben aproximarse al tiempo componentes adheridos los nombres de archivo.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_datetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ponga la fecha y hora actual en un nombre de archivo ‚Äî affix_datetime","text":"","code":"affix_datetime(   filename,   position = c(\"end\", \"start\"),   format = \"%Y-%m-%d_%H-%M-%S\",   delimiter = \"_\",   utc_time = TRUE,   add_tz = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_datetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ponga la fecha y hora actual en un nombre de archivo ‚Äî affix_datetime","text":"filename El nombre de archivo que se va modificar. position D√≥nde colocar la fecha y hora formateada. Esto podr√≠a ser al \"end\" del nombre del archivo (predeterminado) o al \"start\". format Una cadena de formato base::strptime() para formatear el fecha y hora. De forma predeterminada, es \"%Y-%m-%dT%H:%M:%S\" que expresa la fecha seg√∫n la norma ISO 8601. Por ejemplo, si la corriente fecha-hora es 2020-12-04 13:11:23, la cadena formateada se convertir√≠a en \"2020-12-04T13:11:23\". Consulte la documentaci√≥n en base::strptime() para las especificaciones de conversi√≥n si planea utilizar una cadena de formato diferente. delimiter Los caracteres delimitadores que se utilizar√°n para separar la cadena de fecha y hora del nombre del archivo original. utc_time Una opci√≥n para usar la hora UTC actual para establecer la fecha y hora (la predeterminada, con TRUE), o usar la hora local del sistema (FALSE). add_tz ¬øDeber√≠a proporcionarse la zona horaria (como un desfase de UTC)? Si es TRUE, la compensaci√≥n UTC se proporcionar√° como <time>Z (si utc_time = TRUE) o <time>(+/-)hhmm. De forma predeterminada, es FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_datetime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ponga la fecha y hora actual en un nombre de archivo ‚Äî affix_datetime","text":"Un vector de caracteres.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_datetime.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Ponga la fecha y hora actual en un nombre de archivo ‚Äî affix_datetime","text":"13-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/affix_datetime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ponga la fecha y hora actual en un nombre de archivo ‚Äî affix_datetime","text":"","code":"# Tomando el nombre gen√©rico de `pb_file` # para un archivo, le agregamos la fecha y # hora actual como sufijo affix_datetime(filename = \"pb_file\") #> [1] \"pb_file_2021-12-15_04-07-22\"  # Las extensiones de archivo no se # interpondr√°n en el camino: affix_datetime(filename = \"pb_file.rds\") #> [1] \"pb_file_2021-12-15_04-07-22.rds\"  # La fecha y hora se puede utilizar # como prefijo affix_datetime(   filename = \"pb_file\",   position = \"start\" ) #> [1] \"2021-12-15_04-07-22_pb_file\"  # El patr√≥n de fecha y hora se puede # cambiar y as√≠ puede el delimitador affix_datetime(   filename = \"pb_file.yml\",   format = \"%Y%m%d_%H%M%S\",   delimiter = \"-\" ) #> [1] \"pb_file-20211215_040722.yml\"  # Se puede incluir informaci√≥n sobre # la zona horaria affix_datetime(   filename = \"pb_file.yml\",   add_tz = TRUE ) #> [1] \"pb_file_2021-12-15_04-07-22Z.yml\"  if (interactive()) {  # Podemos usar una convenci√≥n de # nomenclatura de archivos que # involucran fechas y horas al # escribir la salida archivos # inmediatamente despu√©s de interrogar; # √∫til al interrogar directamente # de YAML en un proceso programado yaml_agent_interrogate(   filename = system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) ) %>%    x_write_disk(     filename = affix_datetime(       filename = \"small_table_agent.rds\",       delimiter = \"-\"     ),     keep_tbl = TRUE,     keep_extracts = TRUE   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":null,"dir":"Reference","previous_headings":"","what":"Did all of the validations fully pass? ‚Äî all_passed","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"Given agent's validation plan undergone interrogation via interrogate(), every single validation step result zero failing test units? Using all_passed() function let us know whether TRUE .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"","code":"all_passed(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"agent agent object class ptblank_agent. vector validation step numbers. values assigned validation step pointblank order definition. NULL (default), validation steps used evaluation complete passing.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"all_passed() function provides single logical value based interrogation performed agent-based workflow. large-scale validation (data quality known issue, perhaps something tamed time) function likely less useful since quite stringent (test units must pass across validation steps). requirement logical values produced validation, flexible alternative using test (test_*()) variants validation functions. produce single logical value threshold option failure levels. Another option utilize post-interrogation objects within agent's x-list (obtained using get_agent_x_list() function). allows many possibilities producing single logical value interrogation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"8-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/all_passed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"","code":"# Create a simple table with # a column of numerical values tbl <-    dplyr::tibble(a = c(4, 5, 7, 8))  # Validate that values in column # `a` are always greater than 4 agent <-   create_agent(tbl = tbl) %>%   col_vals_gt(vars(a), value = 3) %>%   col_vals_lte(vars(a), value = 10) %>%   col_vals_increasing(vars(a)) %>%   interrogate()  # Determine if these column # validations have all passed by # using `all_passed()` (they do) all_passed(agent = agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øExiste realmente una o m√°s columnas? ‚Äî col_exists","title":"¬øExiste realmente una o m√°s columnas? ‚Äî col_exists","text":"La funci√≥n de validaci√≥n col_exists(), la expectativa expect_col_exists() funci√≥n, y la funci√≥n de prueba test_col_exists() comprueban si uno o existen m√°s columnas en la tabla de destino. El √∫nico requisito es la especificaci√≥n de los nombres de las columnas. La funci√≥n de validaci√≥n se puede utilizar directamente en un dato. tabla o con un objeto * agent * (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con datos mesa. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° en una sola unidad de prueba, que es si la columna existe o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øExiste realmente una o m√°s columnas? ‚Äî col_exists","text":"","code":"col_exists(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_exists(object, columns, threshold = 1)  test_col_exists(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øExiste realmente una o m√°s columnas? ‚Äî col_exists","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns Una o m√°s columnas de la tabla en foco. Esto se puede proporcionar como un vector de nombres de columnas usando c() o nombres de columnas desnudos encerrados entre vars(). actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øExiste realmente una o m√°s columnas? ‚Äî col_exists","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øExiste realmente una o m√°s columnas? ‚Äî col_exists","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øExiste realmente una o m√°s columnas? ‚Äî col_exists","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que se produce mejor con la funci√≥n action_levels(). Lee esa funci√≥n documentaci√≥n para la verdad sobre c√≥mo crear reacciones por encima del umbral niveles de falla en la validaci√≥n. La esencia b√°sica es que querr√°s al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fall√≥, o un valor absoluto), menudo usando el argumento warn_at. Utilizando action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situaci√≥n (el primero produce una advertencia, el otro stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øExiste realmente una o m√°s columnas? ‚Äî col_exists","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øExiste realmente una o m√°s columnas? ‚Äî col_exists","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_exists() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_exists() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_exists(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_exists()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_exists:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_exists()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øExiste realmente una o m√°s columnas? ‚Äî col_exists","text":"2-29","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_exists.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øExiste realmente una o m√°s columnas? ‚Äî col_exists","text":"","code":"# Para todos los ejemplos aqu√≠, # usaremos una tabla simple con # dos columnas: `a` y` b` tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 0, 3)   )  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Valide que las columnas `a` y` b` # existan en la tabla `tbl`; esto hace # dos pasos de validaci√≥n distintos ya # que se proporcionaron dos columnas # a `vars()` agent <-   create_agent(tbl) %>%   col_exists(vars(a, b)) %>%   interrogate()  # Determine si esta validaci√≥n no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>% col_exists(vars(a, b)) #> # A tibble: 6 √ó 2 #>       a     b #>   <dbl> <dbl> #> 1     5     7 #> 2     7     1 #> 3     6     0 #> 4     5     0 #> 5     8     0 #> 6     7     3  # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_exists(tbl, vars(a)) expect_col_exists(tbl, vars(b))  # D: Usando la funci√≥n de prueba  # Con el formulario `test_*()`, # deber√≠amos obtener un √∫nico valor # l√≥gico que se nos devuelva (incluso # si hay varias columnas probadas, # como es el caso a continuaci√≥n) tbl %>% test_col_exists(vars(a, b)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLas columnas contienen datos de caracteres / cadenas? ‚Äî col_is_character","title":"¬øLas columnas contienen datos de caracteres / cadenas? ‚Äî col_is_character","text":"La funci√≥n de validaci√≥n col_is_character(), la funci√≥n de expectativa expect_col_is_character() y la funci√≥n de prueba test_col_is_character() comprueban si una o m√°s columnas de una tabla son del tipo car√°cter. Como muchas de las funciones de tipo col_is_*() en pointblank, el √∫nico requisito es una especificaci√≥n de los nombres de las columnas. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre una sola unidad de prueba, que es si la columna es una columna de tipo car√°cter o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLas columnas contienen datos de caracteres / cadenas? ‚Äî col_is_character","text":"","code":"col_is_character(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_character(object, columns, threshold = 1)  test_col_is_character(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLas columnas contienen datos de caracteres / cadenas? ‚Äî col_is_character","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLas columnas contienen datos de caracteres / cadenas? ‚Äî col_is_character","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLas columnas contienen datos de caracteres / cadenas? ‚Äî col_is_character","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLas columnas contienen datos de caracteres / cadenas? ‚Äî col_is_character","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLas columnas contienen datos de caracteres / cadenas? ‚Äî col_is_character","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLas columnas contienen datos de caracteres / cadenas? ‚Äî col_is_character","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_is_character() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_is_character() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_is_character(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_character()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_is_character:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_character()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLas columnas contienen datos de caracteres / cadenas? ‚Äî col_is_character","text":"2-22","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_character.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLas columnas contienen datos de caracteres / cadenas? ‚Äî col_is_character","text":"","code":"# Para todos los ejemplos aqu√≠, # usaremos una tabla simple con una # columna num√©rica (`a`) y una # columna de caracteres (`b`) tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = LETTERS[1:6]   )    # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validar que la columna `b` tenga la # clase `character` agent <-   create_agent(tbl) %>%   col_is_character(vars(b)) %>%   interrogate()  # Determine si esta validaci√≥n no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>% col_is_character(vars(b)) #> # A tibble: 6 √ó 2 #>       a b     #>   <dbl> <chr> #> 1     5 A     #> 2     7 B     #> 3     6 C     #> 4     5 D     #> 5     8 E     #> 6     7 F      # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_character(tbl, vars(b))  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto tbl %>% test_col_is_character(vars(b)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLas columnas contienen objetos R Date? ‚Äî col_is_date","title":"¬øLas columnas contienen objetos R Date? ‚Äî col_is_date","text":"La funci√≥n de validaci√≥n col_is_date(), la funci√≥n de expectativa expect_col_is_date() y la funci√≥n de prueba test_col_is_date() comprueban si una o m√°s columnas en una tabla es del tipo R Date. Como muchas de las funciones de tipo col_is_*() en pointblank, el √∫nico requisito es una especificaci√≥n de los nombres de las columnas. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre una sola unidad de prueba, que es si la columna es una columna de tipo Date o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLas columnas contienen objetos R Date? ‚Äî col_is_date","text":"","code":"col_is_date(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_date(object, columns, threshold = 1)  test_col_is_date(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLas columnas contienen objetos R Date? ‚Äî col_is_date","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLas columnas contienen objetos R Date? ‚Äî col_is_date","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLas columnas contienen objetos R Date? ‚Äî col_is_date","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLas columnas contienen objetos R Date? ‚Äî col_is_date","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLas columnas contienen objetos R Date? ‚Äî col_is_date","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLas columnas contienen objetos R Date? ‚Äî col_is_date","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_is_date() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_is_date() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_is_date(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_date()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_is_date:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_date()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLas columnas contienen objetos R Date? ‚Äî col_is_date","text":"2-26","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLas columnas contienen objetos R Date? ‚Äî col_is_date","text":"","code":"# The `small_table` dataset in the # package has a `date` column; the # following examples will validate # that that column is of the `Date` # class  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validar que la columna `date` # tenga la clase `Date` agent <-   create_agent(small_table) %>%   col_is_date(vars(date)) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` small_table %>%   col_is_date(vars(date)) %>%   dplyr::slice(1:5) #> # A tibble: 5 √ó 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_date(   small_table, vars(date) )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto small_table %>%   test_col_is_date(vars(date)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLas columnas contienen objetos de factor R? ‚Äî col_is_factor","title":"¬øLas columnas contienen objetos de factor R? ‚Äî col_is_factor","text":"La funci√≥n de validaci√≥n col_is_factor(), la funci√≥n de expectativa expect_col_is_factor() y la funci√≥n de prueba test_col_is_factor() comprueban si una o m√°s columnas en una tabla son del tipo factor. Como muchas de las funciones de tipo col_is_*() en pointblank, el √∫nico requisito es una especificaci√≥n de los nombres de las columnas. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre una sola unidad de prueba, que es si la columna es una columna de tipo factor o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLas columnas contienen objetos de factor R? ‚Äî col_is_factor","text":"","code":"col_is_factor(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_factor(object, columns, threshold = 1)  test_col_is_factor(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLas columnas contienen objetos de factor R? ‚Äî col_is_factor","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLas columnas contienen objetos de factor R? ‚Äî col_is_factor","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLas columnas contienen objetos de factor R? ‚Äî col_is_factor","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLas columnas contienen objetos de factor R? ‚Äî col_is_factor","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLas columnas contienen objetos de factor R? ‚Äî col_is_factor","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLas columnas contienen objetos de factor R? ‚Äî col_is_factor","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_is_factor() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_is_factor() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_is_factor(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_factor()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_is_factor:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_factor()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLas columnas contienen objetos de factor R? ‚Äî col_is_factor","text":"2-28","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_factor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLas columnas contienen objetos de factor R? ‚Äî col_is_factor","text":"","code":"# Modifiquemos la columna `f` en la # tabla `small_table` para que los # valores sean factores en lugar de # tener la clase `character`; los # siguientes ejemplos validar√°n que la # columna `f` se mut√≥ con √©xito y # ahora consta de factores tbl <-    small_table %>%   dplyr::mutate(f = factor(f))  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validar que la columna `f` en el # objeto `tbl` sea de la clase `factor` agent <-   create_agent(tbl) %>%   col_is_factor(vars(f)) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>%   col_is_factor(vars(f)) %>%   dplyr::slice(1:5) #> # A tibble: 5 √ó 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <fct> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_factor(tbl, vars(f))  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto tbl %>% test_col_is_factor(vars(f)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLas columnas contienen valores enteros? ‚Äî col_is_integer","title":"¬øLas columnas contienen valores enteros? ‚Äî col_is_integer","text":"La funci√≥n de validaci√≥n col_is_integer(), la funci√≥n de expectativa expect_col_is_integer() y la funci√≥n de prueba test_col_is_integer() comprueban si una o m√°s columnas de una tabla son de tipo entero. Como muchas de las funciones de tipo col_is_*() en pointblank, el √∫nico requisito es una especificaci√≥n de los nombres de las columnas. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre una sola unidad de prueba, que es si la columna es una columna de tipo entero o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLas columnas contienen valores enteros? ‚Äî col_is_integer","text":"","code":"col_is_integer(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_integer(object, columns, threshold = 1)  test_col_is_integer(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLas columnas contienen valores enteros? ‚Äî col_is_integer","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLas columnas contienen valores enteros? ‚Äî col_is_integer","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLas columnas contienen valores enteros? ‚Äî col_is_integer","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLas columnas contienen valores enteros? ‚Äî col_is_integer","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLas columnas contienen valores enteros? ‚Äî col_is_integer","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLas columnas contienen valores enteros? ‚Äî col_is_integer","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_is_integer() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_is_integer() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_is_integer(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_integer()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_is_integer:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_integer()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLas columnas contienen valores enteros? ‚Äî col_is_integer","text":"2-24","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_integer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLas columnas contienen valores enteros? ‚Äî col_is_integer","text":"","code":"# Para todos los ejemplos aqu√≠, usaremos # una tabla simple con una columna de # caracteres (`a`) y una columna de # n√∫meros enteros (`b`) tbl <-   dplyr::tibble(     a = letters[1:6],     b = 2:7   )    # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validar que la columna `b` tenga la # clase `integer` agent <-   create_agent(tbl) %>%   col_is_integer(vars(b)) %>%   interrogate()  # Determine si esta validaci√≥n no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>% col_is_integer(vars(b)) #> # A tibble: 6 √ó 2 #>   a         b #>   <chr> <int> #> 1 a         2 #> 2 b         3 #> 3 c         4 #> 4 d         5 #> 5 e         6 #> 6 f         7  # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_integer(tbl, vars(b))  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto tbl %>% test_col_is_integer(vars(b)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLas columnas contienen valores l√≥gicos? ‚Äî col_is_logical","title":"¬øLas columnas contienen valores l√≥gicos? ‚Äî col_is_logical","text":"La funci√≥n de validaci√≥n col_is_logical(), la funci√≥n de expectativa expect_col_is_logical() y la funci√≥n de prueba test_col_is_logical() verifican si una o m√°s columnas en una tabla son l√≥gicas (TRUE/ FALSE). Como muchas de las funciones de tipo col_is_*() en pointblank, el √∫nico requisito es una especificaci√≥n de los nombres de las columnas. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre una sola unidad de prueba, que es si la columna es una columna de tipo l√≥gico o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLas columnas contienen valores l√≥gicos? ‚Äî col_is_logical","text":"","code":"col_is_logical(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_logical(object, columns, threshold = 1)  test_col_is_logical(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLas columnas contienen valores l√≥gicos? ‚Äî col_is_logical","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLas columnas contienen valores l√≥gicos? ‚Äî col_is_logical","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLas columnas contienen valores l√≥gicos? ‚Äî col_is_logical","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLas columnas contienen valores l√≥gicos? ‚Äî col_is_logical","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLas columnas contienen valores l√≥gicos? ‚Äî col_is_logical","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLas columnas contienen valores l√≥gicos? ‚Äî col_is_logical","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_is_logical() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_is_logical() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_is_logical(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_logical()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_is_logical:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_logical()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLas columnas contienen valores l√≥gicos? ‚Äî col_is_logical","text":"2-25","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_logical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLas columnas contienen valores l√≥gicos? ‚Äî col_is_logical","text":"","code":"# La tabla `small_table` del paquete # tiene una columna `e` que tiene valores # l√≥gicos; los siguientes ejemplos # validar√°n que esa columna es de la # clase `logical`  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validar que la columna `e` tenga la # clase `logical` agent <-   create_agent(small_table) %>%   col_is_logical(vars(e)) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` small_table %>%   col_is_logical(vars(e)) %>%   dplyr::slice(1:5) #> # A tibble: 5 √ó 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_logical(   small_table, vars(e) )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto small_table %>%   test_col_is_logical(vars(e)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLas columnas contienen valores num√©ricos? ‚Äî col_is_numeric","title":"¬øLas columnas contienen valores num√©ricos? ‚Äî col_is_numeric","text":"La funci√≥n de validaci√≥n col_is_numeric(), la funci√≥n de expectativa expect_col_is_numeric() y la funci√≥n de prueba test_col_is_numeric() verifican si una o m√°s columnas en una tabla son de tipo num√©rico. Como muchas de las funciones de tipo col_is_*() en pointblank, el √∫nico requisito es una especificaci√≥n de los nombres de las columnas. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre una sola unidad de prueba, que es si la columna es de tipo num√©rico o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLas columnas contienen valores num√©ricos? ‚Äî col_is_numeric","text":"","code":"col_is_numeric(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_numeric(object, columns, threshold = 1)  test_col_is_numeric(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLas columnas contienen valores num√©ricos? ‚Äî col_is_numeric","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLas columnas contienen valores num√©ricos? ‚Äî col_is_numeric","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLas columnas contienen valores num√©ricos? ‚Äî col_is_numeric","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLas columnas contienen valores num√©ricos? ‚Äî col_is_numeric","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLas columnas contienen valores num√©ricos? ‚Äî col_is_numeric","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLas columnas contienen valores num√©ricos? ‚Äî col_is_numeric","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_is_numeric() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_is_numeric() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_is_numeric(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_numeric()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_is_numeric:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_numeric()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLas columnas contienen valores num√©ricos? ‚Äî col_is_numeric","text":"2-23","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_numeric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLas columnas contienen valores num√©ricos? ‚Äî col_is_numeric","text":"","code":"# La tabla `small_table` del paquete # tiene una columna `d` que se sabe # que es num√©rica; los siguientes # ejemplos validar√°n que esa columna # es de hecho de la clase `numeric`  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validar que la columna `d` tenga # la clase `numeric` agent <-   create_agent(small_table) %>%   col_is_numeric(vars(d)) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` small_table %>%   col_is_numeric(vars(d)) %>%   dplyr::slice(1:5) #> # A tibble: 5 √ó 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_numeric(   small_table, vars(d) )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto small_table %>%   test_col_is_numeric(vars(d)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLas columnas contienen fechas POSIXct? ‚Äî col_is_posix","title":"¬øLas columnas contienen fechas POSIXct? ‚Äî col_is_posix","text":"La funci√≥n de validaci√≥n col_is_posix(), la funci√≥n de expectativa expect_col_is_posix() y la funci√≥n de prueba test_col_is_posix() comprueban si una o m√°s columnas en una tabla es del tipo de fecha y hora R POSIXct. Como muchas de las funciones de tipo col_is_*() en pointblank, el √∫nico requisito es una especificaci√≥n de los nombres de las columnas. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre una sola unidad de prueba, que es si la columna es una columna de tipo POSIXct o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLas columnas contienen fechas POSIXct? ‚Äî col_is_posix","text":"","code":"col_is_posix(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_posix(object, columns, threshold = 1)  test_col_is_posix(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLas columnas contienen fechas POSIXct? ‚Äî col_is_posix","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLas columnas contienen fechas POSIXct? ‚Äî col_is_posix","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLas columnas contienen fechas POSIXct? ‚Äî col_is_posix","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLas columnas contienen fechas POSIXct? ‚Äî col_is_posix","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_is_*(), usar action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia, la otra stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLas columnas contienen fechas POSIXct? ‚Äî col_is_posix","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLas columnas contienen fechas POSIXct? ‚Äî col_is_posix","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_is_posix() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_is_posix() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_is_posix(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_is_posix()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_is_posix:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_is_posix()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLas columnas contienen fechas POSIXct? ‚Äî col_is_posix","text":"2-27","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_is_posix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLas columnas contienen fechas POSIXct? ‚Äî col_is_posix","text":"","code":"# La tabla `small_table` del paquete # tiene una columna `date_time`; los # siguientes ejemplos validar√°n que esa # columna es de las clases `POSIXct` # y `POSIXt`  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Valide que la columna `date_time` sea # de hecho una columna de fecha y hora agent <-   create_agent(small_table) %>%   col_is_posix(vars(date_time)) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba defectuosas (1) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` small_table %>%   col_is_posix(vars(date_time)) %>%   dplyr::slice(1:5) #> # A tibble: 5 √ó 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_is_posix(   small_table, vars(date_time) )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto small_table %>%   test_col_is_posix(vars(date_time)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Genere un esquema de columna de tabla manualmente o con una tabla de\nreferencia ‚Äî col_schema","title":"Genere un esquema de columna de tabla manualmente o con una tabla de\nreferencia ‚Äî col_schema","text":"Un objeto de esquema de columna de tabla, como puede ser creado por col_schema(), es necesario cuando se usa la funci√≥n de validaci√≥n col_schema_match() (que verifica si el objeto de tabla en estudio coincide con un esquema de columna conocido). El objeto col_schema se puede crear proporcionando cuidadosamente los nombres de las columnas y sus tipos como un conjunto de argumentos con nombre, o podr√≠amos proporcionar un objeto de tabla, que podr√≠a ser de data.frame, tbl_df, tbl_dbi, o tbl_spark. Hay una opci√≥n adicional, que es solo para validar el esquema de un objeto tbl_dbi o tbl_spark: podemos validar el esquema en funci√≥n de los tipos de columna R (por ejemplo, \"numeric\", \"character\", etc.), tipos de columna SQL (por ejemplo, \"double\", \"varchar\", etc.), o tipos de columna Spark SQL (\"DoubleType\", \"StringType\", etc.). Esto es genial si queremos validar los esquemas de columna de la tabla tanto en el lado del servidor como cuando se recopilan y cargan datos tabulares en R.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Genere un esquema de columna de tabla manualmente o con una tabla de\nreferencia ‚Äî col_schema","text":"","code":"col_schema(..., .tbl = NULL, .db_col_types = c(\"r\", \"sql\"))"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Genere un esquema de columna de tabla manualmente o con una tabla de\nreferencia ‚Äî col_schema","text":"... Un conjunto de argumentos con nombre donde los nombres se refieren nombres de columna y los valores son uno o m√°s tipos de columna. .tbl Una opci√≥n para usar un objeto de tabla para definir el esquema. Si se proporciona esto, se ignorar√°n los valores proporcionados .... .db_col_types Determina si los tipos de columna se refieren tipos de columna R (\"r\") o tipos de columna SQL (\"sql\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Genere un esquema de columna de tabla manualmente o con una tabla de\nreferencia ‚Äî col_schema","text":"13-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Genere un esquema de columna de tabla manualmente o con una tabla de\nreferencia ‚Äî col_schema","text":"","code":"# Cree una tabla simple con dos # columnas: una `integer` y la # otra `character` tbl <-    dplyr::tibble(     a = 1:5,     b = letters[1:5]   )  # Cree un objeto de esquema de # columna que describa las columnas # y sus tipos (en el orden esperado) schema_obj <-    col_schema(     a = \"integer\",     b = \"character\"   )  # Valide que el objeto de esquema # `schema_obj` defina exactamente los # nombres de columna y los tipos de # columna de la tabla `tbl` agent <-   create_agent(tbl = tbl) %>%   col_schema_match(schema_obj) %>%   interrogate()  # Determine si este paso de validaci√≥n # pas√≥ usando `all_passed()` all_passed(agent) #> [1] TRUE  # Alternativamente, podemos crear un # objeto de esquema de columna a partir # de un objeto `tbl_df` schema_obj <-   col_schema(     .tbl = dplyr::tibble(       a = integer(0),       b = character(0)     )   )  # Esto deber√≠a proporcionar los mismos # resultados de interrogaci√≥n que en # el ejemplo anterior create_agent(tbl = tbl) %>%   col_schema_match(schema_obj) %>%   interrogate() %>%   all_passed() #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLas columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? ‚Äî col_schema_match","title":"¬øLas columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? ‚Äî col_schema_match","text":"La funci√≥n de validaci√≥n col_schema_match(), la funci√≥n de expectativa expect_col_schema_match() y la funci√≥n de prueba test_col_schema_match() funcionan en conjunto con un objeto col_schema (generado trav√©s de la funci√≥n col_schema()) para determinar si el esquema esperado coincide con el de la tabla de destino. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). El paso de validaci√≥n o expectativa opera sobre una sola unidad de prueba, que es si el esquema coincide con el de la tabla (dentro de las restricciones impuestas por las opciones complete, in_order y is_exact). Si la tabla de destino es un objeto tbl_dbi o tbl_spark, podemos optar por validar el esquema de columna que se basa en los tipos de columna R (por ejemplo, \"numeric\", \"character\", etc.), Tipos de columna SQL (p. Ej., \"Double\", \"varchar\", etc.) o tipos de Spark SQL (p. Ej., \"DoubleType\", \"StringType\", etc.). Esa opci√≥n se define en la funci√≥n col_schema() (es el argumento .db_col_types). Hay opciones para hacer que la verificaci√≥n de esquemas sea menos estricta (de forma predeterminada, esta validaci√≥n opera con el nivel m√°s alto de rigor). Con la opci√≥n complete establecida en FALSE, podemos proporcionar un objeto col_schema con una inclusi√≥n parcial de columnas. El uso de in_order establecido en FALSE significa que es necesario que las columnas definidas en el objeto schema est√©n en el mismo orden que en la tabla de destino. Finalmente, la opci√≥n is_exact establecida en FALSE significa que es necesario proporcionar todas las clases / tipos de columna para una columna en particular. Incluso puede ser NULL, omitiendo la verificaci√≥n del tipo de columna.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLas columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? ‚Äî col_schema_match","text":"","code":"col_schema_match(   x,   schema,   complete = TRUE,   in_order = TRUE,   is_exact = TRUE,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_schema_match(   object,   schema,   complete = TRUE,   in_order = TRUE,   is_exact = TRUE,   threshold = 1 )  test_col_schema_match(   object,   schema,   complete = TRUE,   in_order = TRUE,   is_exact = TRUE,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLas columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? ‚Äî col_schema_match","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). schema Un esquema de tabla de tipo col_schema que se puede generar usando la funci√≥n col_schema(). complete Este es un requisito para tener en cuenta todas las columnas de la tabla en el schema proporcionado. De forma predeterminada, es TRUE, por lo que todos los nombres de columna de la tabla de destino deben estar presentes en el objeto de esquema. Esta restricci√≥n se puede relajar usando FALSE, donde podemos proporcionar un subconjunto de columnas de tabla en el esquema. in_order Este es un requisito estricto para hacer cumplir el orden de las columnas en el schema proporcionado. De forma predeterminada, es TRUE y el orden de las columnas tanto en el esquema como en la tabla de destino debe coincidir. Al establecerlo en FALSE, se elimina este requisito de orden estricto. is_exact Esta opci√≥n determina si la verificaci√≥n de los tipos de columna debe ser exacta o incluso realizada. Por ejemplo, las columnas en los marcos de datos R pueden tener varias clases (por ejemplo, una columna de fecha y hora puede tener las clases POSIXct y POSIXt). Si usa is_exact == FALSE, el tipo de columna en el esquema definido por el usuario para un valor de fecha y hora se puede establecer como \"POSIXct\" o \"POSIXt\" y pasar la validaci√≥n (con esta columna, por lo menos). Esto se puede ir un paso m√°s all√° y el uso de NULL para un tipo de columna en el esquema definido por el usuario omitir√° la verificaci√≥n de validaci√≥n de un tipo de columna. De forma predeterminada, is_exact se establece en TRUE. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLas columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? ‚Äî col_schema_match","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLas columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? ‚Äî col_schema_match","text":"menudo, querremos especificar \"acciones\" para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. El uso de action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situaci√≥n (el primero produce una advertencia, el otro stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLas columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? ‚Äî col_schema_match","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLas columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? ‚Äî col_schema_match","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_schema_match() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_schema_match() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos ya que solo el argumento schema requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_schema_match(     schema = col_schema(       a = \"integer\",       b = \"character\"     ),      complete = FALSE,     in_order = FALSE,     is_exact = FALSE,     actions = action_levels(stop_at = 1),     label = \"El paso `col_schema_match()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_schema_match:     schema:       a: integer       b: character     complete: false     in_order: false     is_exact: false     actions:       stop_count: 1.0     label: El paso `col_schema_match()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLas columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? ‚Äî col_schema_match","text":"2-30","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_schema_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLas columnas de la tabla (y sus tipos) coinciden con un esquema predefinido? ‚Äî col_schema_match","text":"","code":"# Para todos los ejemplos aqu√≠, # usaremos una tabla simple con dos # columnas: una `integral` (`a`) y la # otra `caracteres` (`b`); los # siguientes ejemplos validar√°n que # las columnas de la tabla coinciden # con un esquema creado por # `col_schema()`. tbl <-    dplyr::tibble(     a = 1:5,     b = letters[1:5]   )    tbl #> # A tibble: 5 √ó 2 #>       a b     #>   <int> <chr> #> 1     1 a     #> 2     2 b     #> 3     3 c     #> 4     4 d     #> 5     5 e      # Crear un objeto de esquema de # columnas con la funci√≥n de ayuda # `col_schema()` que describa las # columnas y sus tipos (en el # orden esperado) schema_obj <-    col_schema(     a = \"integer\",     b = \"character\"   )    # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validar que el objeto de esquema # `schema_obj` define exactamente los # nombres y tipos de columnas agent <-   create_agent(tbl) %>%   col_schema_match(schema_obj) %>%   interrogate()  # Determinar si esta validaci√≥n no ten√≠a # unidades de prueba que fallaran (hay # una √∫nica unidad de prueba gobernada # por si hay una coincidencia) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>% col_schema_match(schema_obj) #> # A tibble: 5 √ó 2 #>       a b     #>   <int> <chr> #> 1     1 a     #> 2     2 b     #> 3     3 c     #> 4     4 d     #> 5     5 e      # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_schema_match(tbl, schema_obj)  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto tbl %>% test_col_schema_match(schema_obj) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"La funci√≥n de validaci√≥n col_vals_between(), la funci√≥n de expectativa expect_col_vals_between() y la funci√≥n de prueba test_col_vals_between() comprueban si los valores de las columnas de una tabla est√°n dentro de un rango. El rango especificado con tres argumentos: left, right e inclusive. Los valores left y right especifican los l√≠mites superior e inferior. Los l√≠mites se pueden especificar como valores literales simples o como nombres de columna dados en vars(). El argumento inclusive, como un vector de dos valores l√≥gicos relacionados con \"izquierda\" y \"derecha\", establece si cada l√≠mite es inclusivo o . El valor predeterminado es c(TRUE, TRUE), donde ambos extremos son inclusivos (es decir, [izquierda, derecha]). Para versiones parcialmente ilimitadas de esta funci√≥n, podemos usar las funciones de validaci√≥n col_vals_lt(), col_vals_lte(), col_vals_gt() o col_vals_gte(). La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"","code":"col_vals_between(   x,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. left El l√≠mite inferior del rango. La validaci√≥n incluye este valor l√≠mite (si el primer elemento en inclusive es TRUE) adem√°s de valores mayores que left. Puede ser un valor √∫nico o una columna compatible dada en vars(). right El l√≠mite superior del rango. La validaci√≥n incluye este valor l√≠mite (si el segundo elemento en inclusive es TRUE) adem√°s de valores inferiores right. Puede ser un valor √∫nico o una columna compatible dada en vars(). inclusive Un valor l√≥gico de dos elementos que indica si los l√≠mites left y right deben ser inclusivos. De forma predeterminada, ambos l√≠mites son inclusivos. na_pass ¬øDeber√≠a considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Aj√∫stelo en TRUE para darle un pase NA. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"Esta funci√≥n de validaci√≥n admite el manejo especial de valores NA. El argumento na_pass determinar√° si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumular√° unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_between() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_between() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos suelen ser m√°s cortos, ya que solo los argumentos de las columns, left y right requieren valores. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_vals_between(     columns = vars(a),     left = 1,     right = 2,     inclusive = c(TRUE, FALSE),     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_between()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_between:     columns: vars(a)     left: 1.0     right: 2.0     inclusive:     - true     - false     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_between()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"2-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_between.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLos datos de la columna se encuentran entre dos valores especificados o los\ndatos de otras columnas? ‚Äî col_vals_between","text":"","code":"# El conjunto de datos `small_table` en # el paquete tiene una columna de valores # num√©ricos en `c` (hay algunas `NA` en # esa columna); los siguientes ejemplos # validar√°n los valores en esa # columna num√©rica  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Valide que los valores en la columna # `c` est√©n todos entre `1` y `9`; # debido a que hay valores `NA`, # elegiremos dejar que pasen la # validaci√≥n configurando `na_pass = TRUE` agent <-   create_agent(small_table) %>%   col_vals_between(     vars(c), 1, 9, na_pass = TRUE   ) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 13 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` small_table %>%   col_vals_between(     vars(c), 1, 9, na_pass = TRUE   ) %>%   dplyr::pull(c) #>  [1]  3  8  3 NA  7  4  3  2  9  9  7  8 NA  # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_between(   small_table, vars(c), 1, 9,   na_pass = TRUE )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto small_table %>%   test_col_vals_between(     vars(c), 1, 9,     na_pass = TRUE   ) #> [1] TRUE  # Una nota adicional sobre los l√≠mites # de esta funci√≥n: son inclusivos por # defecto (es decir, se aprobar√°n valores # de exactamente `1` y `9`); podemos # modificar la inclusividad de los l√≠mites # superior e inferior con la opci√≥n # `inclusive`, que es un vector l√≥gico # de longitud 2  # Al probar con el l√≠mite superior no # inclusivo, obtenemos `FALSO` ya que dos # valores son `9` y ahora quedan fuera # del l√≠mite superior (o derecho) small_table %>%   test_col_vals_between(     vars(c), 1, 9,     inclusive = c(TRUE, FALSE),     na_pass = TRUE   ) #> [1] FALSE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","title":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","text":"La funci√≥n de validaci√≥n col_vals_decreasing(), la funci√≥n de expectativa expect_col_vals_decreasing() y la funci√≥n de prueba test_col_vals_decreasing() comprueban si los valores de las columnas en una tabla est√°n disminuyendo cuando se mueve hacia abajo en una tabla. Hay opciones para permitir valores NA en la columna de destino, permitir fases estacionarias (donde los valores consecutivos cambian), e incluso para permitir movimientos crecientes hasta un cierto umbral. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","text":"","code":"col_vals_decreasing(   x,   columns,   allow_stationary = FALSE,   increasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_decreasing(   object,   columns,   allow_stationary = FALSE,   increasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_decreasing(   object,   columns,   allow_stationary = FALSE,   increasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. allow_stationary Una opci√≥n para permitir pausas en valores decrecientes. Por ejemplo, si los valores de las unidades de prueba son [85, 82, 82, 80, 77], la tercera unidad (82, que aparece por segunda vez) fallar√° cuando allow_stationary sea FALSE (el valor predeterminado ). El uso de allow_stationary = TRUE dar√° como resultado que todas las unidades de prueba en [85, 82, 82, 80, 77] se marquen con aprobado. increasing_tol Un valor de umbral opcional que permite el movimiento de valores num√©ricos en la direcci√≥n positiva. De forma predeterminada, es NULL, pero se utiliza un valor num√©rico para establecer el umbral absoluto de recorrido positivo permitido en las unidades de prueba num√©ricas. Tenga en cuenta que establecer un valor aqu√≠ tambi√©n tiene el efecto de establecer allow_stationary en TRUE. na_pass ¬øDeber√≠a considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Aj√∫stelo en TRUE para darle un pase NA. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","text":"Esta funci√≥n de validaci√≥n admite el manejo especial de valores NA. El argumento na_pass determinar√° si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumular√° unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_decreasing() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_decreasing() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_vals_decreasing(     columns = vars(a),     allow_stationary = TRUE,     increasing_tol = 0.5,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_decreasing()`.\",     active = FALSE   ) %>% yaml_agent_string()  # Representaci√≥n YAML steps: - col_vals_decreasing:     columns: vars(a)     allow_stationary: true     increasing_tol: 0.5     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_decreasing()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_decreasing.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos datos de las columnas est√°n disminuyendo por filas? ‚Äî col_vals_decreasing","text":"2-14","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"La funci√≥n de validaci√≥n col_vals_equal(), la funci√≥n de expectativa expect_col_vals_equal() y la funci√≥n de prueba test_col_vals_equal() comprueban si los valores de las columnas en una tabla son iguales un value especificado. El value se puede especificar como un valor literal √∫nico o como un nombre de columna dado en vars(). La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"","code":"col_vals_equal(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. value Un valor utilizado para esta prueba de igualdad. Puede ser un valor √∫nico o una columna compatible dada en vars(). Cualquier valor de columna igual lo que se especifica aqu√≠ pasar√° la validaci√≥n. na_pass ¬øDeber√≠a considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Aj√∫stelo en TRUE para darle un pase NA. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"Esta funci√≥n de validaci√≥n admite el manejo especial de valores NA. El argumento na_pass determinar√° si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumular√° unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_equal() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_equal() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_vals_equal(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_equal()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_equal:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_equal()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"2-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_equal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øSon los datos de la columna iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_equal","text":"","code":"# Para todos los ejemplos aqu√≠, # usaremos una tabla simple con tres # columnas num√©ricas (`a`,` b` y `c`) # y tres columnas de caracteres # (`d`, `e` y `f`) tbl <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 2, 2),     d = LETTERS[c(1:3, 5:7)],     e = LETTERS[c(1:6)],     f = LETTERS[c(1:6)]   )    tbl #> # A tibble: 6 √ó 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 A     A     A     #> 2     5     1     1 B     B     B     #> 3     5     1     1 C     C     C     #> 4     5     2     2 E     D     D     #> 5     5     2     2 F     E     E     #> 6     5     2     2 G     F     F      # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Valide que los valores en la columna # `a` sean todos iguales al valor de `5` agent <-   create_agent(tbl) %>%   col_vals_equal(vars(a), 5) %>%   interrogate()  # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>%    col_vals_equal(vars(a), 5) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_equal(tbl, vars(a), 5)  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto test_col_vals_equal(tbl, vars(a), 5) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øCoinciden los datos de la columna con una expresi√≥n de predicado? ‚Äî col_vals_expr","title":"¬øCoinciden los datos de la columna con una expresi√≥n de predicado? ‚Äî col_vals_expr","text":"La funci√≥n de validaci√≥n col_vals_expr(), la funci√≥n de expectativa expect_col_vals_expr() y la funci√≥n de prueba test_col_vals_expr() comprueban si los valores de las columnas en una tabla concuerdan con una expresi√≥n de predicado definida por el usuario. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øCoinciden los datos de la columna con una expresi√≥n de predicado? ‚Äî col_vals_expr","text":"","code":"col_vals_expr(   x,   expr,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_expr(object, expr, preconditions = NULL, threshold = 1)  test_col_vals_expr(object, expr, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øCoinciden los datos de la columna con una expresi√≥n de predicado? ‚Äî col_vals_expr","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). expr Una expresi√≥n para usar en esta prueba. Esto puede ser en forma de una llamada realizada con la funci√≥n expr() o como una f√≥rmula R unilateral (usando un ~ inicial). preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øCoinciden los datos de la columna con una expresi√≥n de predicado? ‚Äî col_vals_expr","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øCoinciden los datos de la columna con una expresi√≥n de predicado? ‚Äî col_vals_expr","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øCoinciden los datos de la columna con una expresi√≥n de predicado? ‚Äî col_vals_expr","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øCoinciden los datos de la columna con una expresi√≥n de predicado? ‚Äî col_vals_expr","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øCoinciden los datos de la columna con una expresi√≥n de predicado? ‚Äî col_vals_expr","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øCoinciden los datos de la columna con una expresi√≥n de predicado? ‚Äî col_vals_expr","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_expr() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_expr() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos ya que solo el argumento expr requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_vals_expr(     expr = ~ a %% 1 == 0,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_expr()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_expr:     expr: ~a%%1 == 0     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_expr()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øCoinciden los datos de la columna con una expresi√≥n de predicado? ‚Äî col_vals_expr","text":"2-19","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_expr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øCoinciden los datos de la columna con una expresi√≥n de predicado? ‚Äî col_vals_expr","text":"","code":"# Para todos los ejemplos aqu√≠, # usaremos una tabla simple con tres # columnas num√©ricas (`a`, `b` y `c`) # y tres columnas de caracteres # (`d`, `e` y `f`) tbl <-   dplyr::tibble(     a = c(1, 2, 1, 7, 8, 6),     b = c(0, 0, 0, 1, 1, 1),     c = c(0.5, 0.3, 0.8, 1.4, 1.9, 1.2),   )    tbl #> # A tibble: 6 √ó 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     1     0   0.5 #> 2     2     0   0.3 #> 3     1     0   0.8 #> 4     7     1   1.4 #> 5     8     1   1.9 #> 6     6     1   1.2  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Valide que los valores en la columna # `a` sean de tipo entero usando el # operador de m√≥dulo R y esperando `0` agent <-   create_agent(tbl) %>%   col_vals_expr(expr(a %% 1 == 0)) %>%   interrogate()  # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>%    col_vals_expr(expr(a %% 1 == 0)) %>%   dplyr::pull(a) #> [1] 1 2 1 7 8 6    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_expr(tbl, ~ a %% 1 == 0)  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto test_col_vals_expr(tbl, ~ a %% 1 == 0) #> [1] TRUE  # Variaciones  # Podemos hacer cosas m√°s complejas # aprovechando las funciones `case_when()` # y `between()` (disponibles para su uso # en el paquete pointblank) tbl %>%   test_col_vals_expr(~ case_when(     b == 0 ~ a %>% between(0, 5) & c < 1,     b == 1 ~ a > 5 & c >= 1   )) #> [1] TRUE  # Si solo desea probar un subconjunto de # filas, entonces la declaraci√≥n # `case_when()` no necesita ser exhaustiva; # todas las filas que no caigan en los # casos se recortar√°n (lo que nos dar√° # menos unidades de prueba en general) tbl %>%   test_col_vals_expr(~ case_when(     b == 1 ~ a > 5 & c >= 1   )) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"La funci√≥n de validaci√≥n col_vals_gt(), la funci√≥n de expectativa expect_col_vals_gt() y la funci√≥n de prueba test_col_vals_gt() comprueban si los valores de las columnas en una tabla son mayores que un value especificado (la comparaci√≥n exacta utilizada en esta funci√≥n es col_val > value). El value se puede especificar como un valor literal √∫nico o como un nombre de columna dado en vars(). La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"","code":"col_vals_gt(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_gt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_gt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. value Un valor utilizado para esta comparaci√≥n. Puede ser un valor √∫nico o una columna compatible dada en vars(). Cualquier valor de columna mayor que el especificado aqu√≠ pasar√° la validaci√≥n. na_pass ¬øDeber√≠a considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Aj√∫stelo en TRUE para darle un pase NA. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"Esta funci√≥n de validaci√≥n admite el manejo especial de valores NA. El argumento na_pass determinar√° si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumular√° unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_gt() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_gt() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# C√≥digo R agent %>%    col_vals_gt(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_gt()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_gt:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_gt()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"2-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLos datos de la columna son mayores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_gt","text":"","code":"# Para todos los ejemplos, # utilizaremos una tabla sencilla # con tres columnas num√©ricas # (`a`, `b` y `c`) y tres columnas # de caracteres (`d`, `e` y `f`) tbl <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 3, 4),     d = LETTERS[a],     e = LETTERS[b],     f = LETTERS[c]   )    tbl #> # A tibble: 6 √ó 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A     #> 2     5     1     1 E     A     A     #> 3     5     1     1 E     A     A     #> 4     5     2     2 E     B     B     #> 5     5     2     3 E     B     C     #> 6     5     2     4 E     B     D      # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Valida que los valores de la columna # `a` son todos mayores que el valor # de `4`. agent <-   create_agent(tbl) %>%   col_vals_gt(vars(a), value = 4) %>%   interrogate()  # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>%    col_vals_gt(vars(a), value = 4) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_gt(   tbl, vars(a),   value = 4 )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto test_col_vals_gt(   tbl, vars(a),    value = 4 ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"La funci√≥n de validaci√≥n col_vals_gte(), la funci√≥n de expectativa expect_col_vals_gte() y la funci√≥n de prueba test_col_vals_gte() comprueban si los valores de las columnas en una tabla son mayores o iguales un value especificado (el La comparaci√≥n exacta utilizada en esta funci√≥n es col_val> = value). El value se puede especificar como un valor literal √∫nico o como un nombre de columna dado en vars(). La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"","code":"col_vals_gte(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_gte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_gte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. value Un valor utilizado para esta comparaci√≥n. Puede ser un valor √∫nico o una columna compatible dada en vars(). Cualquier valor de columna mayor o igual lo especificado aqu√≠ pasar√° la validaci√≥n. na_pass ¬øDeber√≠a considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Aj√∫stelo en TRUE para darle un pase NA. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"Esta funci√≥n de validaci√≥n admite el manejo especial de valores NA. El argumento na_pass determinar√° si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumular√° unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_gte() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_gte() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# C√≥digo R agent %>%    col_vals_gte(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_gte()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_gte:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_gte()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"2-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_gte.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLos datos de la columna son mayores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_gte","text":"","code":"# Para todos los ejemplos, # utilizaremos una tabla sencilla # con tres columnas num√©ricas # (`a`, `b` y `c`) y tres columnas # de caracteres (`d`, `e` y `f`) tbl <-   dplyr::tibble(       a = c(5, 5, 5, 5, 5, 5),       b = c(1, 1, 1, 2, 2, 2),       c = c(1, 1, 1, 2, 3, 4),       d = LETTERS[a],       e = LETTERS[b],       f = LETTERS[c]   )    tbl #> # A tibble: 6 √ó 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A     #> 2     5     1     1 E     A     A     #> 3     5     1     1 E     A     A     #> 4     5     2     2 E     B     B     #> 5     5     2     3 E     B     C     #> 6     5     2     4 E     B     D      # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validate that values in column `a` # are all greater than or equal to the # value of `5` agent <-   create_agent(tbl) %>%   col_vals_gte(vars(a), 5) %>%   interrogate()  # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>%    col_vals_gte(vars(a), 5) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_gte(tbl, vars(a), 5)  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto test_col_vals_gte(tbl, vars(a), 5) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","title":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","text":"La funci√≥n de validaci√≥n col_vals_in_set(), la funci√≥n de expectativa expect_col_vals_in_set() y la funci√≥n de prueba test_col_vals_in_set() comprueban si los valores de las columnas en una tabla son parte de un set de valores especificado. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","text":"","code":"col_vals_in_set(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_in_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_in_set(object, columns, set, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. set vector numeric string-based elements, column values found within set considered passing. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_in_set() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_in_set() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. practice, often shorter columns, set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# C√≥digo R agent %>%    col_vals_in_set(     columns = vars(a),     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_in_set()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_in_set:     columns: vars(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: El paso `col_vals_in_set()`.    active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","text":"2-9","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_in_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLos datos de la columna forman parte de un conjunto de valores espec√≠fico? ‚Äî col_vals_in_set","text":"","code":"# La tabla `small_table` del paquete # se utilizar√° para validar que los # valores de las columnas forman # parte de un conjunto determinado  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validar que los valores de la # columna `f` forman parte del # conjunto de valores que contienen # `low`, `mid` y `high` agent <-   create_agent(small_table) %>%   col_vals_in_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 13 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` small_table %>%   col_vals_in_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\"   # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_in_set(   small_table,   vars(f), c(\"low\", \"mid\", \"high\") )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto small_table %>%   test_col_vals_in_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","title":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","text":"La funci√≥n de validaci√≥n col_vals_increasing(), la funci√≥n de expectativa expect_col_vals_increasing() y la funci√≥n de prueba test_col_vals_increasing() comprueban si los valores de las columnas en una tabla est√°n aumentando cuando se mueve hacia abajo en una tabla. Hay opciones para permitir valores NA en la columna de destino, permitir fases estacionarias (donde los valores consecutivos cambian), e incluso para permitir movimientos decrecientes hasta un cierto umbral. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","text":"","code":"col_vals_increasing(   x,   columns,   allow_stationary = FALSE,   decreasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_increasing(   object,   columns,   allow_stationary = FALSE,   decreasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_increasing(   object,   columns,   allow_stationary = FALSE,   decreasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. allow_stationary option allow pauses decreasing values. example values test units [80, 82, 82, 85, 88] third unit (82, appearing second time) marked fail allow_stationary FALSE (default). Using allow_stationary = TRUE result test units [80, 82, 82, 85, 88] marked pass. decreasing_tol optional threshold value allows movement numerical values negative direction. default NULL using numerical value set absolute threshold negative travel allowed across numerical test units. Note setting value also effect setting allow_stationary TRUE. na_pass ¬øDeber√≠a considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Aj√∫stelo en TRUE para darle un pase NA. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","text":"Esta funci√≥n de validaci√≥n admite el manejo especial de valores NA. El argumento na_pass determinar√° si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumular√° unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_increasing() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_increasing() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_vals_increasing(     columns = vars(a),     allow_stationary = TRUE,     decreasing_tol = 0.5,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_increasing()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_increasing:     columns: vars(a)     allow_stationary: true     decreasing_tol: 0.5     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_increasing()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_increasing.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos datos de la columna aumentan por fila? ‚Äî col_vals_increasing","text":"2-13","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"La funci√≥n de validaci√≥n col_vals_lt(), la funci√≥n de expectativa expect_col_vals_lt() y la funci√≥n de prueba test_col_vals_lt() comprueban si los valores de las columnas en una tabla son menores que un value especificado (la comparaci√≥n exacta utilizada en esta funci√≥n es col_val < value). El value se puede especificar como un valor literal √∫nico o como un nombre de columna dado en vars(). La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"","code":"col_vals_lt(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_lt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_lt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. value value used comparison. can single value compatible column given vars(). column values less specified pass validation. na_pass ¬øDeber√≠a considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Aj√∫stelo en TRUE para darle un pase NA. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"Esta funci√≥n de validaci√≥n admite el manejo especial de valores NA. El argumento na_pass determinar√° si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumular√° unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_lt() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_lt() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# C√≥digo R agent %>%    col_vals_lt(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_lt()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_lt:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_lt()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"2-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLos datos de la columna son menores que un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_lt","text":"","code":"# Para todos los ejemplos, utilizaremos # una tabla sencilla con tres columnas # num√©ricas (`a`, `b` y `c`) y tres # columnas de caracteres (`d`, `e` # y `f`) tbl <-   dplyr::tibble(       a = c(5, 5, 5, 5, 5, 5),       b = c(1, 1, 1, 2, 2, 2),       c = c(1, 1, 1, 2, 3, 4),       d = LETTERS[a],       e = LETTERS[b],       f = LETTERS[c]   )    tbl #> # A tibble: 6 √ó 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A     #> 2     5     1     1 E     A     A     #> 3     5     1     1 E     A     A     #> 4     5     2     2 E     B     B     #> 5     5     2     3 E     B     C     #> 6     5     2     4 E     B     D      # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Valida que los valores de la columna # `c` son todos menores que el valor # de `5`. agent <-   create_agent(tbl) %>%   col_vals_lt(vars(c), 5) %>%   interrogate()  # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>%    col_vals_lt(vars(c), 5) %>%   dplyr::pull(c) #> [1] 1 1 1 2 3 4    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_lt(tbl, vars(c), 5)  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto test_col_vals_lt(tbl, vars(c), 5) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"La funci√≥n de validaci√≥n col_vals_lte(), la funci√≥n de expectativa expect_col_vals_lte() y la funci√≥n de prueba test_col_vals_lte() comprueban si los valores de las columnas en una tabla son menores o iguales un value especificado (la comparaci√≥n exacta utilizada en esta funci√≥n es col_val < value). El value se puede especificar como un valor literal √∫nico o como un nombre de columna dado en vars(). La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"","code":"col_vals_lte(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_lte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_lte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. value value used comparison. can single value compatible column given vars(). column values less equal specified pass validation. na_pass ¬øDeber√≠a considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Aj√∫stelo en TRUE para darle un pase NA. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"Esta funci√≥n de validaci√≥n admite el manejo especial de valores NA. El argumento na_pass determinar√° si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumular√° unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_lte() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_lte() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# C√≥digo R agent %>%    col_vals_lte(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_lte()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_lte:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_lte()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"2-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_lte.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLos datos de la columna son menores o iguales a un valor fijo o los datos de\notra columna? ‚Äî col_vals_lte","text":"","code":"# Para todos los ejemplos, utilizaremos # una tabla sencilla con tres columnas # num√©ricas (`a`, `b` y `c`) y tres # columnas de caracteres (`d`, `e` # y `f`) tbl <-   dplyr::tibble(       a = c(5, 5, 5, 5, 5, 5),       b = c(1, 1, 1, 2, 2, 2),       c = c(1, 1, 1, 2, 3, 4),       d = LETTERS[a],       e = LETTERS[b],       f = LETTERS[c]   )    tbl #> # A tibble: 6 √ó 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A     #> 2     5     1     1 E     A     A     #> 3     5     1     1 E     A     A     #> 4     5     2     2 E     B     B     #> 5     5     2     3 E     B     C     #> 6     5     2     4 E     B     D      # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validate that values in column `c` # are all less than or equal to the # value of `4` agent <-   create_agent(tbl) %>%   col_vals_lte(vars(c), 4) %>%   interrogate()  # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>%    col_vals_lte(vars(c), 4) %>%   dplyr::pull(c) #> [1] 1 1 1 2 3 4    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_lte(tbl, vars(c), 4)  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto test_col_vals_lte(tbl, vars(c), 4) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","title":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","text":"La funci√≥n de validaci√≥n col_vals_make_set(), la funci√≥n de expectativa expect_col_vals_make_set() y la funci√≥n de prueba test_col_vals_make_set() comprueban si los valores de set se ven al menos una vez en una columna de la tabla. Un criterio necesario aqu√≠ es que se deben ver valores adicionales (fuera de los definidos en el set) (este requisito se relaja en la funci√≥n de validaci√≥n col_vals_make_subset() y en sus variantes de expectativa y prueba). La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number elements set plus test unit reserved detecting column values outside set (outside value seen make additional test unit fail).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","text":"","code":"col_vals_make_set(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_make_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_make_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. set vector elements expected equal set unique values target column. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_make_set() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_make_set() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. practice, often shorter columns, set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# C√≥digo R agent %>%    col_vals_make_set(     columns = vars(a),     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_make_set()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_make_set:     columns: vars(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: El paso `col_vals_make_set()`.    active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","text":"2-11","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øUn conjunto de valores se tiene en cuenta por completo en una columna de\nvalores? ‚Äî col_vals_make_set","text":"","code":"# The `small_table` dataset in the # package will be used to validate that # column values are part of a given set  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validate that values in column `f` # comprise the values of `low`, `mid`, # and `high`, and, no other values agent <-   create_agent(small_table) %>%   col_vals_make_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 4 # unidades de prueba) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` small_table %>%   col_vals_make_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\"   # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_make_set(   small_table,   vars(f), c(\"low\", \"mid\", \"high\") )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto small_table %>%   test_col_vals_make_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","title":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","text":"La funci√≥n de validaci√≥n col_vals_make_subset(), la funci√≥n de expectativa expect_col_vals_make_subset() y la funci√≥n de prueba test_col_vals_make_subset() comprueban si todos los valores de set se ven al menos una vez en una columna de tabla. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de elementos en el set.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","text":"","code":"col_vals_make_subset(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_make_subset(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_make_subset(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. set vector elements expected subset unique values target column. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_make_subset() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_make_subset() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. practice, often shorter columns, set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# C√≥digo R agent %>%    col_vals_make_subset(     columns = vars(a),     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_make_subset()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_make_subset:     columns: vars(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: El paso `col_vals_make_subset()`.    active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","text":"2-12","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_make_subset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øEs un conjunto de valores un subconjunto de una columna de valores? ‚Äî col_vals_make_subset","text":"","code":"# The `small_table` dataset in the # package will be used to validate that # column values are part of a given set  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validate that the distinct set of values # in column `f` contains at least the # subset defined as `low` and `high` (the # column actually has both of those and # some `mid` values) agent <-   create_agent(small_table) %>%   col_vals_make_subset(     vars(f), c(\"low\", \"high\")   ) %>%   interrogate()    # Determine if this validation # had no failing test units (there # are 2 test units, one per element # in the `set`) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` small_table %>%   col_vals_make_subset(     vars(f), c(\"low\", \"high\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\"   # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_make_subset(   small_table,   vars(f), c(\"low\", \"high\") )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto small_table %>%   test_col_vals_make_subset(     vars(f), c(\"low\", \"high\")   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"La funci√≥n de validaci√≥n col_vals_not_between(), la funci√≥n de expectativa expect_col_vals_not_between() y la funci√≥n de prueba test_col_vals_not_between() comprueban si los valores de las columnas en una tabla caen dentro de un rango. El rango especificado con tres argumentos: left, right e inclusive. Los valores left y right especifican los l√≠mites superior e inferior. Los l√≠mites se pueden especificar como valores literales simples o como nombres de columna dados en vars(). El argumento inclusive, como un vector de dos valores l√≥gicos relacionados con left y right, establece si cada l√≠mite es inclusivo o . El valor predeterminado es c(TRUE, TRUE), donde ambos extremos son inclusivos (es decir, [izquierda, derecha]). Para versiones parcialmente ilimitadas de esta funci√≥n, podemos usar las funciones de validaci√≥n col_vals_lt(), col_vals_lte(), col_vals_gt() o col_vals_gte(). La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"","code":"col_vals_not_between(   x,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_not_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. left, right Los valores l√≠mite inferior (o izquierdo) y superior (o derecho) del rango. Pueden expresarse como valores individuales, columnas compatibles dadas en vars(), o una combinaci√≥n de ambos. Por defecto, cualquier valor de columna mayor o igual que left y menor o igual que right fallar√° la validaci√≥n. La inclusividad de los l√≠mites puede ser modificada por la opci√≥n inclusive. inclusive Un valor l√≥gico de dos elementos que indica si los l√≠mites left y right deben ser inclusivos. De forma predeterminada, ambos l√≠mites son inclusivos. na_pass ¬øDeber√≠a considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Aj√∫stelo en TRUE para darle un pase NA. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"Esta funci√≥n de validaci√≥n admite el manejo especial de valores NA. El argumento na_pass determinar√° si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumular√° unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_not_between() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_not_between() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. practice, often shorter columns, left, right arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# C√≥digo R agent %>%    col_vals_not_between(     columns = vars(a),     left = 1,     right = 2,     inclusive = c(TRUE, FALSE),     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_not_between()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_not_between:     columns: vars(a)     left: 1.0     right: 2.0     inclusive:     - true     - false     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_not_between()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"2-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_between.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLos datos de la columna se encuentran fuera de dos valores especificados o\nlos datos de otras columnas? ‚Äî col_vals_not_between","text":"","code":"# La tabla `small_table` del paquete # tiene una columna de valores # num√©ricos en `c` (hay algunos `NA` # en esa columna); los siguientes # ejemplos validar√°n los valores de # esa columna num√©rica  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Valida que los valores de la # columna `c` est√©n todos entre `10` # y `20`; como hay valores `NA`, # elegiremos que pasen la validaci√≥n # poniendo `na_pass = TRUE`. agent <-   create_agent(small_table) %>%   col_vals_not_between(     vars(c), 10, 20, na_pass = TRUE   ) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 13 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` small_table %>%   col_vals_not_between(     vars(c), 10, 20, na_pass = TRUE   ) %>%   dplyr::pull(c) #>  [1]  3  8  3 NA  7  4  3  2  9  9  7  8 NA  # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_not_between(   small_table, vars(c), 10, 20,   na_pass = TRUE )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto small_table %>%   test_col_vals_not_between(     vars(c), 10, 20,     na_pass = TRUE   ) #> [1] TRUE  # Una nota adicional sobre los l√≠mites # de esta funci√≥n: son inclusivos por # defecto; podemos modificar la # inclusividad de los l√≠mites superior # e inferior con la opci√≥n `inclusive`, # que es un vector l√≥gico de longitud 2  # Al cambiar el l√≠mite inferior para # que sea `9` y hacerlo no inclusivo, # obtenemos `TRUE` ya que aunque dos # valores son `9` y quedan fuera del # l√≠mite inferior (o izquierdo) (y # cualquier valor `no entre` cuenta # como unidades de prueba que pasan) small_table %>%   test_col_vals_not_between(     vars(c), 9, 20,     inclusive = c(FALSE, TRUE),     na_pass = TRUE   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"La funci√≥n de validaci√≥n col_vals_not_equal(), la funci√≥n de expectativa expect_col_vals_not_equal() y la funci√≥n de prueba test_col_vals_not_equal() comprueban si los valores de las columnas en una tabla son iguales un value especificado. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"","code":"col_vals_not_equal(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_not_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. value value used test inequality. can single value compatible column given vars(). column values equal specified pass validation. na_pass ¬øDeber√≠a considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Aj√∫stelo en TRUE para darle un pase NA. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"Esta funci√≥n de validaci√≥n admite el manejo especial de valores NA. El argumento na_pass determinar√° si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumular√° unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_not_equal() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_not_equal() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# C√≥digo R agent %>%    col_vals_not_equal(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_not_equal()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_not_equal:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_not_equal()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"2-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_equal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLos datos de la columna no son iguales a un valor fijo o los datos de otra\ncolumna? ‚Äî col_vals_not_equal","text":"","code":"# Para todos los ejemplos, utilizaremos # una tabla sencilla con tres columnas # num√©ricas (`a`, `b` y `c`) y tres # columnas de caracteres (`d`, `e` # y `f`) tbl <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 2, 2),     d = LETTERS[c(1:3, 5:7)],     e = LETTERS[c(1:6)],     f = LETTERS[c(1:6)]   )    tbl #> # A tibble: 6 √ó 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 A     A     A     #> 2     5     1     1 B     B     B     #> 3     5     1     1 C     C     C     #> 4     5     2     2 E     D     D     #> 5     5     2     2 F     E     E     #> 6     5     2     2 G     F     F      # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validate that values in column `a` # are all *not* equal to the value # of `6` agent <-   create_agent(tbl) %>%   col_vals_not_equal(vars(a), 6) %>%   interrogate()  # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 6 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>%    col_vals_not_equal(vars(a), 6) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_not_equal(tbl, vars(a), 6)  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto test_col_vals_not_equal(tbl, vars(a), 6) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","title":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","text":"La funci√≥n de validaci√≥n col_vals_not_in_set(), la funci√≥n de expectativa expect_col_vals_not_in_set() y la funci√≥n de prueba test_col_vals_not_in_set() comprueban si los valores de columna en una tabla son parte de un conjunto de valores especificado. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","text":"","code":"col_vals_not_in_set(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_in_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_not_in_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. set vector numeric string-based elements, column values found within set considered failing. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_not_in_set() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_not_in_set() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. practice, often shorter columns, set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# C√≥digo R agent %>%    col_vals_not_in_set(     columns = vars(a),     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_not_in_set()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_not_in_set:     columns: vars(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: El paso `col_vals_not_in_set()`.    active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","text":"2-10","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_in_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLos datos no forman parte de un conjunto espec√≠fico de valores? ‚Äî col_vals_not_in_set","text":"","code":"# The `small_table` dataset in the # package will be used to validate that # column values are part of a given set  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validate that values in column `f` # contain none of the values `lows`, # `mids`, and `highs` agent <-   create_agent(small_table) %>%   col_vals_not_in_set(     vars(f), c(\"lows\", \"mids\", \"highs\")   ) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 13 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` small_table %>%   col_vals_not_in_set(     vars(f), c(\"lows\", \"mids\", \"highs\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\"   # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_not_in_set(   small_table,   vars(f), c(\"lows\", \"mids\", \"highs\") )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto small_table %>%   test_col_vals_not_in_set(     vars(f), c(\"lows\", \"mids\", \"highs\")   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","title":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","text":"La funci√≥n de validaci√≥n col_vals_not_null(), la funci√≥n de expectativa expect_col_vals_not_null() y la funci√≥n de prueba test_col_vals_not_null() comprueban si los valores de columna en una tabla son valores de NA o, en el contexto de la base de datos, valores NULL. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","text":"","code":"col_vals_not_null(   x,   columns,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_null(object, columns, preconditions = NULL, threshold = 1)  test_col_vals_not_null(object, columns, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_not_null() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_not_null() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_vals_not_null(     vars(a),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_not_null()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_not_null:     columns: vars(a)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_not_null()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","text":"2-16","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_not_null.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLos datos de la columna no son NULL/NA? ‚Äî col_vals_not_null","text":"","code":"# For all examples here, we'll use # a simple table with four columns: # `a`, `b`, `c`, and `d` tbl <-   dplyr::tibble(     a = c( 5,  7,  6,  5,  8),     b = c( 7,  1,  0,  0,  0),     c = c(NA, NA, NA, NA, NA),     d = c(35, 23, NA, NA, NA)   )    tbl #> # A tibble: 5 √ó 4 #>       a     b c         d #>   <dbl> <dbl> <lgl> <dbl> #> 1     5     7 NA       35 #> 2     7     1 NA       23 #> 3     6     0 NA       NA #> 4     5     0 NA       NA #> 5     8     0 NA       NA    # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validate that all values in column # `b` are *not* NA (they would be # non-NULL in a database context, which # isn't the case here) agent <-   create_agent(tbl) %>%   col_vals_not_null(vars(b)) %>%   interrogate()  # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 5 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>%   col_vals_not_null(vars(b)) %>%   dplyr::pull(b) #> [1] 7 1 0 0 0  # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_not_null(tbl, vars(b))  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto tbl %>% test_col_vals_not_null(vars(b)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","title":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","text":"La funci√≥n de validaci√≥n col_vals_null(), la funci√≥n de expectativa expect_col_vals_null() y la funci√≥n de prueba test_col_vals_null() comprueban si los valores de las columnas en una tabla son valores NA o, en el contexto de la base de datos, NULL valores. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","text":"","code":"col_vals_null(   x,   columns,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_null(object, columns, preconditions = NULL, threshold = 1)  test_col_vals_null(object, columns, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_null() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_null() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo el argumento de las columns requiere un valor. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    col_vals_null(     vars(a),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_null()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_null:     columns: vars(a)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_null()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","text":"2-15","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_null.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øSon los datos de la columna NULL/NA? ‚Äî col_vals_null","text":"","code":"# For all examples here, we'll use # a simple table with four columns: # `a`, `b`, `c`, and `d` tbl <-   dplyr::tibble(     a = c( 5,  7,  6,  5,  8),     b = c( 7,  1,  0,  0,  0),     c = c(NA, NA, NA, NA, NA),     d = c(35, 23, NA, NA, NA)   )    tbl #> # A tibble: 5 √ó 4 #>       a     b c         d #>   <dbl> <dbl> <lgl> <dbl> #> 1     5     7 NA       35 #> 2     7     1 NA       23 #> 3     6     0 NA       NA #> 4     5     0 NA       NA #> 5     8     0 NA       NA    # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validate that all values in column # `c` are NA (they would be NULL in a # database context, which isn't the # case here) agent <-   create_agent(tbl) %>%   col_vals_null(vars(c)) %>%   interrogate()  # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 5 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>%   col_vals_null(vars(c)) %>%   dplyr::pull(c) #> [1] NA NA NA NA NA  # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_null(tbl, vars(c))  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto tbl %>% test_col_vals_null(vars(c)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"La funci√≥n de validaci√≥n col_vals_regex(), la funci√≥n de expectativa expect_col_vals_regex() y la funci√≥n de prueba test_col_vals_regex() comprueban si los valores de las columnas en una tabla corresponden una expresi√≥n coincidente de regex. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"","code":"col_vals_regex(   x,   columns,   regex,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_regex(   object,   columns,   regex,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_regex(   object,   columns,   regex,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. regex regular expression pattern test match target column. regex matches values target columns pass validation. na_pass ¬øDeber√≠a considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Aj√∫stelo en TRUE para darle un pase NA. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"Esta funci√≥n de validaci√≥n admite el manejo especial de valores NA. El argumento na_pass determinar√° si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumular√° unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_regex() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_regex() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. practice, often shorter columns regex arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# C√≥digo R agent %>%    col_vals_regex(     columns = vars(a),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_regex()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_regex:     columns: vars(a)     regex: '[0-9]-[a-z]{3}-[0-9]{3}'     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_regex()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"2-17","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_regex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLas cadenas en los datos de la columna coinciden con un patr√≥n de\nexpresiones regulares? ‚Äî col_vals_regex","text":"","code":"# The `small_table` dataset in the # package has a character-based `b` # column with values that adhere to # a very particular pattern; the # following examples will validate # that that column abides by a regex # pattern small_table #> # A tibble: 13 √ó 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # This is the regex pattern that will # be used throughout pattern <- \"[0-9]-[a-z]{3}-[0-9]{3}\"  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validate that all values in column # `b` match the regex `pattern` agent <-   create_agent(small_table) %>%   col_vals_regex(vars(b), pattern) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 13 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` small_table %>%   col_vals_regex(vars(b), pattern) %>%   dplyr::slice(1:5) #> # A tibble: 5 √ó 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_regex(   small_table,   vars(b), pattern )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto small_table %>%   test_col_vals_regex(     vars(b), pattern   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"La funci√≥n de validaci√≥n col_vals_within_spec(), la funci√≥n de expectativa expect_col_vals_within_spec() y la funci√≥n de prueba test_col_vals_within_spec() comprueban si los valores de columna en una tabla corresponden un tipo de especificaci√≥n (spec) (los detalles son disponible en la secci√≥n Especificaciones) La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"","code":"col_vals_within_spec(   x,   columns,   spec,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_within_spec(   object,   columns,   spec,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_within_spec(   object,   columns,   spec,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. spec specification string. Examples \"email\", \"url\", \"postal[USA]\". options explained Specifications section. na_pass ¬øDeber√≠a considerarse que los valores de NA encontrados pasan unidades de prueba? Esto es por defecto FALSE. Aj√∫stelo en TRUE para darle un pase NA. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"especificaciones","dir":"Reference","previous_headings":"","what":"Especificaciones","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"specification type must used spec argument. character-based keyword corresponds type data specified columns. following keywords can used: \"isbn\": International Standard Book Number (ISBN) unique numerical identifier books, pamphletes, educational kits, microforms, digital/electronic publications. specification formalized ISO 2108. keyword can used validate 10- 13-digit ISBNs. \"VIN\": vehicle identification number (VIN) unique code (includes serial number) used automotive industry identify individual motor vehicles, motorcycles, scooters, mopeds stipulated ISO 3779 ISO 4030. \"postal_code[<country_code>]\": postal code (also known postcodes, PIN, ZIP codes, depending region) series letters, digits, (sometimes including spaces/punctuation) included postal address aid sorting mail. coding varies country, country code either 2- (ISO 3166-1 alpha-2) 3-letter (ISO 3166-1 alpha-3) formats needs supplied along keywords (e.g., postal codes Germany, \"postal_code[DE]\" \"postal_code[DEU]\" can used). keyword alias \"zip\" can used US ZIP codes. \"credit_card\": credit card number can validated check works across large variety credit type issuers (card numbers allocated accordance ISO/IEC 7812). Numbers can various lengths (typically, 14-19 digits) key validation performed usage Luhn algorithm. \"iban[<country_code>]\": International Bank Account Number (IBAN) system identifying bank accounts across different countries purpose improving cross-border transactions. IBAN values validated conversion integer values performing basic mod-97 operation (described ISO 7064) . length coding varies country, country code either 2- (ISO 3166-1 alpha-2) 3-letter (ISO 3166-1 alpha-3) formats needs supplied along keywords (e.g., IBANs Germany, \"iban[DE]\" \"iban[DEU]\" can used). \"swift\": Business Identifier Codes (also known SWIFT-BIC, BIC, SWIFT code) defined standard format described ISO 9362. codes unique identifiers financial non-financial institutions. SWIFT stands Society Worldwide Interbank Financial Telecommunication. numbers used transferring money banks, especially important international wire transfers. \"phone\", \"email\", \"url\", \"ipv4\", \"ipv6\", \"mac\": Phone numbers, email addresses, Internet URLs, IPv4 IPv6 addresses, MAC addresses can validated respective keywords. validations use regex-based matching determine validity. single spec value provided per function call.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"Si proporciona varios nombres de columna, el resultado ser√° una expansi√≥n de pasos de validaci√≥n para ese n√∫mero de nombres de columna (por ejemplo, vars(col_a, col_b) dar√° lugar la entrada de dos pasos de validaci√≥n). Aparte de los nombres de las columnas en comillas y en vars(), tidyselect funciones auxiliares est√°n disponibles para especificando columnas. Ellos son: starts_with(), ends_with(), contains(), matches(), y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"valores-faltantes","dir":"Reference","previous_headings":"","what":"Valores faltantes","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"Esta funci√≥n de validaci√≥n admite el manejo especial de valores NA. El argumento na_pass determinar√° si un valor de NA que aparece en una unidad de prueba debe pasar o . El valor predeterminado de na_pass = FALSE significa que cualquier NA encontrado acumular√° unidades de prueba fallidas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando col_vals_within_spec() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de col_vals_within_spec() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. practice, often shorter columns spec arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# C√≥digo R agent %>%    col_vals_within_spec(     columns = vars(a),     spec = \"email\",     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(b < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `col_vals_within_spec()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - col_vals_within_spec:     columns: vars(a)     spec: email     na_pass: true     preconditions: ~. %>% dplyr::filter(b < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `col_vals_within_spec()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"2-18","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/col_vals_within_spec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLos valores de los datos de la columna se ajustan a una especificaci√≥n? ‚Äî col_vals_within_spec","text":"","code":"# The `specifications` dataset in the # package has columns of character data # that correspond to each of the # specifications that can be tested; # the following examples will validate # that the `email_addresses` column # has 5 correct values (this is true if # we get a subset of the data: the first # five rows) spec_slice <- specifications[1:5, ]  # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validate that all values in the column # `email_addresses` are correct agent <-   create_agent(spec_slice) %>%   col_vals_within_spec(     vars(email_addresses),     spec = \"email\"   ) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 5 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` spec_slice %>%   col_vals_within_spec(     vars(email_addresses),     spec = \"email\"   ) %>%   dplyr::select(email_addresses) #> # A tibble: 5 √ó 1 #>   email_addresses                                                           #>   <chr>                                                                     #> 1 test@test.com                                                             #> 2 mail+mail@example.com                                                     #> 3 mail.email@e.test.com                                                     #> 4 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@letters-in-local.org #> 5 01234567890@numbers-in-local.net                                           # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_col_vals_within_spec(   spec_slice,   vars(email_addresses),   spec = \"email\" )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto spec_slice %>%   test_col_vals_within_spec(     vars(email_addresses),     spec = \"email\"   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":null,"dir":"Reference","previous_headings":"","what":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","title":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","text":"La funci√≥n de validaci√≥n conjointly(), la funci√≥n de expectativa expect_conjointly() y la funci√≥n de prueba test_conjointly() comprueban si las unidades de prueba en cada √≠ndice (t√≠picamente cada fila) pasan todas las validaciones m√∫ltiples. Podemos usar funciones de validaci√≥n que validan las unidades de fila (la serie col_vals_*()), verificar la existencia de la columna (col_exists()), o validar el tipo de columna (la serie col_is_*()). Debido la restricci√≥n impuesta sobre las funciones de validaci√≥n permitidas, el conjunto de unidades de prueba est√° compuesto por filas de la tabla (despu√©s de que se hayan aplicado las preconditions comunes) o son unidades de prueba √∫nicas (para aquellas funciones que validan columnas). Cada una de las funciones usadas en un paso de validaci√≥n conjointly() (compuesto usando m√∫ltiples llamadas funciones de validaci√≥n) finalmente realiza una prueba por filas de si todas las subvalidaciones reportaron un aprobado para las mismas unidades de prueba. En la pr√°ctica, un ejemplo de validaci√≥n conjunta es probar si los valores de la columna son mayores que un valor espec√≠fico, mientras que los valores adyacentes en la columna b se encuentran dentro de un rango espec√≠fico. Las funciones de validaci√≥n que ser√°n parte de la validaci√≥n conjunta deben ser suministradas como f√≥rmulas R unilaterales (usando un ~ inicial y con un . como el objeto de datos). La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","text":"","code":"conjointly(   x,   ...,   .list = list2(...),   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_conjointly(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )  test_conjointly(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). ... Una colecci√≥n de f√≥rmulas unilaterales que constan de funciones de validaci√≥n que validan unidades de fila (la serie col_vals_*()), existencia de columna (col_exists()) o tipo de columna (la serie col_is_*()). Un ejemplo de esto es ~ col_vals_gte(., vars(), 5.5), ~ col_vals_not_null(., vars(b)). .list Allows use list input alternative .... preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","text":"Si proporciona varios nombres de columna en cualquiera de los pasos de validaci√≥n proporcionados, el resultado ser√° una expansi√≥n de los pasos de subvalidaci√≥n ese n√∫mero de nombres de columna. Aparte de los nombres de las columnas entre comillas y en vars(), las funciones auxiliares tidyselect est√°n disponibles para especificar columnas. Son: starts_with(), ends_with(), contains(), matches() y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. Si hay varias columns especificadas, el n√∫mero potencial de pasos de validaci√≥n ser√° m columnas multiplicadas por n segmentos resueltos. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop()s en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando conjointly() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de conjointly() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo son necesarias las expresiones para los pasos de validaci√≥n. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    conjointly(     ~ col_vals_lt(., vars(a), 8),     ~ col_vals_gt(., vars(c), vars(a)),     ~ col_vals_not_null(., vars(b)),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),      label = \"El paso `conjointly()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - conjointly:     fns:     - ~col_vals_lt(., vars(a), 8)     - ~col_vals_gt(., vars(c), vars(a))     - ~col_vals_not_null(., vars(b))     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `conjointly()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","text":"2-31","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/conjointly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Realice m√∫ltiples validaciones por filas para la validez conjunta ‚Äî conjointly","text":"","code":"# Para todos los ejemplos aqu√≠, usaremos # una tabla simple con tres columnas # num√©ricas (`a`, `b` y `c`); esta es # una tabla muy b√°sica, pero ser√° m√°s # √∫til cuando se expliquen las cosas # m√°s adelante tbl <-   dplyr::tibble(     a = c(5, 2, 6),     b = c(3, 4, 6),     c = c(9, 8, 7)   )    tbl #> # A tibble: 3 √ó 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     3     9 #> 2     2     4     8 #> 3     6     6     7    # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # Validate a number of things on a # row-by-row basis using validation # functions of the `col_vals*` type # (all have the same number of test # units): (1) values in `a` are less # than `8`, (2) values in `c` are # greater than the adjacent values in # `a`, and (3) there aren't any NA # values in `b` agent <-   create_agent(tbl = tbl) %>%   conjointly(     ~ col_vals_lt(., vars(a), value = 8),     ~ col_vals_gt(., vars(c), value = vars(a)),     ~ col_vals_not_null(., vars(b))     ) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 3 # unidades de prueba, una para cada fila) all_passed(agent) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent)`  # ¬øQue esta pasando? Piense en que hay # tres validaciones paralelas, cada una # de las cuales produce una columna de # valores `TRUE` o `FALSE` (\"pasa\" o # \"falla\") y alin√©elos uno al lado del # otro, cualquier fila con cualquier # valor `FALSE` da como resultado una # unidad de prueba conjunta \"fallida\"  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>%   conjointly(     ~ col_vals_lt(., vars(a), value = 8),     ~ col_vals_gt(., vars(c), value = vars(a)),     ~ col_vals_not_null(., vars(b))   ) #> # A tibble: 3 √ó 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     3     9 #> 2     2     4     8 #> 3     6     6     7  # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_conjointly(   tbl,   ~ col_vals_lt(., vars(a), value = 8),   ~ col_vals_gt(., vars(c), value = vars(a)),   ~ col_vals_not_null(., vars(b)) )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto tbl %>%   test_conjointly(     ~ col_vals_lt(., vars(a), value = 8),     ~ col_vals_gt(., vars(c), value = vars(a)),     ~ col_vals_not_null(., vars(b))   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Crear un objeto pointblank agent ‚Äî create_agent","title":"Crear un objeto pointblank agent ‚Äî create_agent","text":"La funci√≥n create_agent() crea un objeto agent, que se utiliza en un flujo de trabajo de informes de calidad de datos. El objetivo general de este flujo de trabajo es generar informaci√≥n de informes √∫til para evaluar el nivel de calidad de los datos para la tabla de destino. Podemos proporcionar tantas funciones de validaci√≥n como el usuario desee escribir, aumentando as√≠ el nivel de cobertura de validaci√≥n para esa tabla. El agent asignado por la llamada create_agent() toma funciones de validaci√≥n, que se expanden los pasos de validaci√≥n (cada uno est√° numerado). Este proceso se conoce como desarrollo de un plan de validaci√≥n. Las funciones de validaci√≥n, cuando se llaman en un agent, son simplemente instrucciones hasta el punto en que se llama la funci√≥n interrogate(). Eso inicia el proceso del agent actuando sobre el * plan de validaci√≥n * y obteniendo resultados para cada paso. Una vez que se completa el proceso de interrogaci√≥n, podemos decir que el agent tiene inteligencia. Llamar al agent en s√≠ mismo dar√° como resultado una tabla de informes. Tambi√©n se puede acceder este informe de la interrogaci√≥n con la funci√≥n get_agent_report(), donde hay m√°s opciones de informe.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Crear un objeto pointblank agent ‚Äî create_agent","text":"","code":"create_agent(   tbl = NULL,   read_fn = NULL,   tbl_name = NULL,   label = NULL,   actions = NULL,   end_fns = NULL,   embed_report = FALSE,   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Crear un objeto pointblank agent ‚Äî create_agent","text":"tbl La tabla de entrada. Puede ser un marco de datos, un tibble, un objeto tbl_dbi o un objeto tbl_spark. Alternativamente, se puede usar una funci√≥n para leer en la tabla de datos de entrada con el argumento read_fn (en cuyo caso, tbl puede ser NULL). read_fn Una f√≥rmula de preparaci√≥n de tablas que se usa para acceder la tabla de destino. Incluso si se proporciona un tbl, esta f√≥rmula se invocar√° para obtener los datos (es decir, el read_fn tiene prioridad). Hay dos formas de especificar un read_fn: (1) con una expresi√≥n de f√≥rmula del lado derecho (RHS) (p. Ej., ~ {<c√≥digo de lectura de la tabla>}) o (2) como una funci√≥n (p. Ej., function () {<c√≥digo de lectura de la tabla>}). tbl_name Un nombre opcional para asignar al objeto de la tabla de entrada. Si se proporciona ning√∫n valor, se generar√° un nombre en funci√≥n de la informaci√≥n disponible. Este nombre de tabla se mostrar√° en el √°rea de encabezado del informe del agente generado al imprimir el agent o llamar get_agent_report(). label Una etiqueta opcional para el plan de validaci√≥n. Si se proporciona ning√∫n valor, se generar√° una etiqueta basada en la hora actual del sistema. Markdown se puede usar aqu√≠ para hacer que la etiqueta sea m√°s atractiva visualmente (aparecer√° en el √°rea de encabezado del informe del agente). actions Una opci√≥n para incluir una lista con niveles de umbral para que todos los pasos de validaci√≥n puedan reaccionar en consecuencia al exceder los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). Si se utiliza una lista de niveles de acci√≥n para un paso de validaci√≥n espec√≠fico, se anular√° el conjunto predeterminado especificado aqu√≠. end_fns Una lista de expresiones que deben invocarse al final de un interrogatorio. Cada expresi√≥n debe tener la forma de una f√≥rmula R unilateral, por lo que en general se debe usar esta construcci√≥n: end_fns = list (~ <declaraciones R>, ~ <declaraciones R>, ...). Un ejemplo de una funci√≥n incluida en pointblank que se puede utilizar con sensatez aqu√≠ es email_blast(), que env√≠a un correo electr√≥nico del informe de validaci√≥n (basado en una condici√≥n de env√≠o). embed_report Una opci√≥n para incrustar un informe de validaci√≥n basado en gt en el objeto ptblank_agent. Si es FALSE (el valor predeterminado), el objeto de la tabla se generar√° ni estar√° disponible con el agent al regresar del interrogatorio. lang El idioma que se utilizar√° para la creaci√≥n autom√°tica de res√∫menes (descripciones breves para cada paso de validaci√≥n) y para el informe del agente (una tabla de resumen que proporciona el plan de validaci√≥n y los resultados de la interrogaci√≥n. De forma predeterminada, NULL crear√° ingl√©s (\"en\") texto. Otras opciones incluyen franc√©s (\"fr\"), alem√°n (\"de\"), italiano (\"\"), espa√±ol (\"es\"), portugu√©s (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), dan√©s (\"da\") , Sueco (\"sv\") y holand√©s (\"nl\"). locale Un ID de configuraci√≥n regional opcional que se utilizar√° para formatear valores en la tabla de resumen informe del agente de acuerdo con las reglas de la configuraci√≥n regional. Los ejemplos incluyen \"en_US\" para ingl√©s (Estados Unidos) y \"fr_FR\" para franc√©s (Francia); m√°s simplemente, puede ser un identificador de idioma sin una designaci√≥n de pa√≠s, como \"es\" para espa√±ol (Espa√±a, igual que \"es_ES\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Crear un objeto pointblank agent ‚Äî create_agent","text":"Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"data-products-obtained-from-an-agent","dir":"Reference","previous_headings":"","what":"Data Products Obtained from an Agent","title":"Crear un objeto pointblank agent ‚Äî create_agent","text":"Se puede obtener un objeto de lista muy detallado, conocido como x-list, usando la funci√≥n get_agent_x_list() en el agent. Esta fuente de informaci√≥n puede tomarse como un todo o desglosarse por el n√∫mero de paso (con el argumento ). veces es √∫til ver qu√© filas fallaron. Al usar la funci√≥n get_data_extracts() en el agent, obtenemos una lista de tibbles (para aquellos pasos que tienen extracciones de datos) o un tibble si el paso de validaci√≥n se especifica con el argumento . Los datos de destino se pueden dividir en partes que representan las porciones de 'pasa' y 'falla' con la funci√≥n get_sundered_data(). Un requisito principal es un agente al que se le haya llamado interrogate(). Adem√°s, los pasos de validaci√≥n considerados para esta divisi√≥n de datos deben ser aquellos que operan en valores en una columna (por ejemplo, las funciones col_vals_*() o conjointly()). Con estos pasos de validaci√≥n en consideraci√≥n, las filas sin unidades de prueba fallidas en todos los pasos de validaci√≥n comprenden la pieza de datos 'aprobada', y las filas con al menos una unidad de prueba fallida en la misma serie de validaciones constituyen la pieza 'fallida'. Si solo necesitamos saber si todas las validaciones pasaron por completo (es decir, todos los pasos ten√≠an unidades de prueba fallidas), la funci√≥n all_passed() podr√≠a usarse en el agent. Sin embargo, en la pr√°ctica, es frecuente que todos los pasos de validaci√≥n de datos est√©n libres de unidades defectuosas. Si bien la impresi√≥n de un agent mostrar√° el informe agent en el Viewer, podemos usar alternativamente get_agent_report() para aprovechar otras opciones (por ejemplo, cambiar el idioma, modificar la disposici√≥n de las filas del informe, etc.) y devolver el informe como objetos independientes. Por ejemplo, con la opci√≥n display_table = TRUE (la predeterminada), get_agent_report() devolver√° un objeto de tabla gt (\"gt_tbl\"). Si display_table se establece en FALSE, obtendremos un marco de datos en su lugar.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Crear un objeto pointblank agent ‚Äî create_agent","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()) . Aqu√≠ hay un ejemplo de c√≥mo se expresa una llamada compleja de create_agent() en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, este bloque de YAML ser√° m√°s corto ya que los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con su valor predeterminado al generar el YAML por otros medios). El √∫nico requisito para escribir la representaci√≥n YAML de un agent es tener especificado read_fn (cualquier tabla proporcionada tbl es ignorado). Lo que sigue t√≠picamente este fragmento de YAML es una parte de \"pasos\", y eso corresponde la adici√≥n de pasos de validaci√≥n trav√©s de funciones de validaci√≥n. Los art√≠culos de ayuda para cada funci√≥n de validaci√≥n tienen una secci√≥n YAML que describe c√≥mo una funci√≥n de validaci√≥n determinada se traduce YAML. Si necesita obtener una vista previa de la transformaci√≥n de un agent YAML (sin enviar nada al disco), use la funci√≥n yaml_agent_string(). Si ya tiene un archivo .yml que contiene un agent, puede echar un vistazo las expresiones R que se utilizan para regenerar ese agente con yaml_agent_show_exprs().","code":"# C√≥digo R create_agent(   read_fn = ~ small_table,   tbl_name = \"small_table\",   label = \"Un ejemplo.\",   actions = action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   ),    end_fns = list(     ~ beepr::beep(2),     ~ Sys.sleep(1)   ),    embed_report = TRUE,   lang = \"fr\",    locale = \"fr_CA\" )  # Representaci√≥n YAML type: agent read_fn: ~small_table tbl_name: small_table label: Un ejemplo. lang: fr locale: fr_CA actions:   warn_fraction: 0.1 stop_fraction: 0.25 notify_fraction: 0.35 end_fns: - ~beepr::beep(2) - ~Sys.sleep(1) embed_report: true"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"escribir-un-agente-en-el-disco","dir":"Reference","previous_headings":"","what":"Escribir un agente en el disco","title":"Crear un objeto pointblank agent ‚Äî create_agent","text":"Se puede escribir un objeto agent en el disco con la funci√≥n x_write_disk(). Esto puede resultar √∫til para mantener un historial de validaciones y generar vistas de la calidad de los datos lo largo del tiempo. Los agentes se almacenan en formato RDS serializado y se pueden recuperar f√°cilmente con la funci√≥n x_read_disk(). Se recomienda que las f√≥rmulas de preparaci√≥n de tablas se proporcionen al argumento read_fn de create_agent(). De esta manera, cuando se lee un agent desde el disco trav√©s de x_read_disk(), se puede reutilizar para acceder la tabla de destino (que puede cambiar, de ah√≠ la necesidad de usar una expresi√≥n para esto).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"combinaci-n-de-varios-agentes-en-un-objeto-multiagent","dir":"Reference","previous_headings":"","what":"Combinaci√≥n de varios agentes en un objeto multiagent","title":"Crear un objeto pointblank agent ‚Äî create_agent","text":"Varios objetos agent pueden formar parte de un objeto agent m√∫ltiple, y se pueden usar dos funciones para esto: create_multiagent() y read_disk_multiagent(). Al recopilar varios agentes que han realizado interrogaciones en el pasado, podemos obtener un informe multiagent que muestra c√≥mo evolucion√≥ la calidad de los datos con el tiempo. Este caso de uso es interesante para el control y la gesti√≥n de la calidad de los datos, y los informes (que se pueden personalizar con get_multiagent_report()) son s√≥lidos frente los cambios en los pasos de validaci√≥n para una tabla de destino determinada.","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Crear un objeto pointblank agent ‚Äî create_agent","text":"1-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_agent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Crear un objeto pointblank agent ‚Äî create_agent","text":"","code":"# Analicemos un an√°lisis de la calidad de # los datos de una tabla extremadamente peque√±a; # en realidad se llama `small_table` y podemos # encontrarlo como un conjunto de datos en # este paquete small_table #> # A tibble: 13 √ó 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # Debemos pensar en lo que es tolerable en # t√©rminos de calidad de los datos, as√≠ que # designemos umbrales de falla proporcionales # a los estados `warn`,` stop` y `notify` # usando `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Ahora cree un objeto `agent` en blanco y # as√≠gnele el objeto` al` (que sirve como valor # predeterminado para todos los pasos de # validaci√≥n que se pueden anular); los umbrales # est√°ticos proporcionados por `al` har√°n que # los informes sean un poco m√°s √∫tiles agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   )  # Luego, como con cualquier objeto `agent`, # podemos agregar pasos al plan de validaci√≥n # usando tantas funciones de validaci√≥n como # queramos; luego, usamos `interrogate()` # para realizar f√≠sicamente las validaciones # y recopilar informaci√≥n agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5) %>%   col_vals_equal(     vars(d), value = vars(d),     na_pass = TRUE   ) %>%   col_vals_between(     vars(c),     left = vars(a), right = vars(d),     na_pass = TRUE   ) %>%   interrogate()    # Llamar a un objeto *agent* en la consola # imprime el informe del agente; pero # podemos obtener un objeto `gt_tbl` # directamente con `get_agent_report(agent)` report <- get_agent_report(agent) class(report) #> [1] \"ptblank_agent_report\" \"gt_tbl\"               \"list\"                  # ¬øQu√© puedes hacer con el informe? Imprima # desde un fragmento de c√≥digo R Markdown, # √∫selo en un correo electr√≥nico **blastula**, # col√≥quelo en una p√°gina web o modif√≠quelo # con el paquete **gt**  # Por el informe sabemos que el Paso 4 # ten√≠a dos unidades de prueba (filas, # en realidad) que fallaron; podemos ver # esas filas con `get_data_extracts()` agent %>% get_data_extracts(i = 4) #> # A tibble: 2 √ó 8 #>   date_time           date           a b             c     d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high  #> 2 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high   # Podemos obtener una 'x-list' para toda # la validaci√≥n (8 pasos), o solo para el # cuarto paso con `get_agent_x_list()` xl_step_4 <-   agent %>% get_agent_x_list(i = 4)   # Y luego podemos examinar las diferentes # partes de la lista; obtengamos la fracci√≥n # de unidades de prueba que fallaron xl_step_4$f_failed #> [1] 0.15385  # Simplemente imprimiendo la lista x nos # dir√° qu√© hay disponible all√≠ xl_step_4 #> ‚îÄ‚îÄ The x-list for `small_table` ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 4 ‚îÄ‚îÄ #> $time_start $time_end (POSIXct [1]) #> $label $tbl_name $tbl_src $tbl_src_details (chr [1]) #> $tbl (spec_tbl_df, tbl_df, tbl, and data.frame) #> $col_names $col_types (chr [8]) #> $i $type $columns $values $label $briefs (mixed [1]) #> $eval_error $eval_warning (lgl [1]) #> $capture_stack (list [1]) #> $n $n_passed $n_failed $f_passed $f_failed (num [1]) #> $warn $stop $notify (lgl [1]) #> $lang (chr [1]) #> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # Una 'x-list' que no sea espec√≠fica de # ning√∫n paso tendr√° mucha m√°s informaci√≥n # y una estructura ligeramente diferente; ver # `help(get_agent_x_list)` para m√°s informaci√≥n # get_agent_x_list(agent)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":null,"dir":"Reference","previous_headings":"","what":"Crear un objeto pointblank informant ‚Äî create_informant","title":"Crear un objeto pointblank informant ‚Äî create_informant","text":"La funci√≥n create_informant() crea un objeto informant, que se utiliza en un flujo de trabajo de gesti√≥n de informaci√≥n. El objetivo general de este flujo de trabajo es registrar, recopilar y generar informaci√≥n √∫til en tablas de datos. Podemos proporcionar cualquier informaci√≥n que sea √∫til para describir una tabla de datos en particular. El objeto informant creado por la funci√≥n create_informant() toma funciones enfocadas en informaci√≥n: info_columns(), info_tabular(), info_section(), y info_snippet(). La serie de funciones info_*() permite una acumulaci√≥n progresiva de informaci√≥n sobre la tabla de destino. Las funciones info_columns() y info_tabular() facilitan la entrada de texto de informaci√≥n que concierne las columnas de la tabla y la tabla propiamente dicha; la funci√≥n info_section() permite la creaci√≥n de secciones arbitrarias que pueden tener m√∫ltiples subsecciones llenas de texto de informaci√≥n adicional. El sistema permite valores din√°micos seleccionados de la tabla de destino mediante info_snippet(), para obtener extractos de texto con nombre de consultas y el uso de {<snippet_name>} en el texto de informaci√≥n. Para hacer el uso de info_snippet() m√°s conveniente para consultas comunes, se proporciona un conjunto de funciones snip_*() en el paquete (snip_list(), snip_stats(), snip_lowest(), y snip_highest()) aunque puedes usar tus propias expresiones. Debido que los fragmentos necesitan consultar la tabla de destino para devolver fragmentos de texto de informaci√≥n, la funci√≥n incorporate() debe usarse para iniciar esta acci√≥n. Esto tambi√©n es necesario para que el informant actualice otros elementos de metadatos, como los recuentos de filas y columnas. Una vez que se complete el proceso de incorporaci√≥n, se actualizar√°n los fragmentos y otros metadatos. Llamar al informant en s√≠ mismo dar√° como resultado una tabla de informes. Tambi√©n se puede acceder este informe con la funci√≥n get_informant_report(), donde hay m√°s opciones de informe.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Crear un objeto pointblank informant ‚Äî create_informant","text":"","code":"create_informant(   tbl = NULL,   read_fn = NULL,   agent = NULL,   tbl_name = NULL,   label = NULL,   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Crear un objeto pointblank informant ‚Äî create_informant","text":"tbl La tabla de entrada. Puede ser un marco de datos, un tibble, un objeto tbl_dbi o un objeto tbl_spark. Alternativamente, se puede usar una funci√≥n para leer en la tabla de datos de entrada con el argumento read_fn (en cuyo caso, tbl puede ser NULL). read_fn Una funci√≥n que se usa para leer los datos. Incluso si se proporciona un tbl, esta funci√≥n se invocar√° para obtener los datos (es decir, el read_fn tiene prioridad). Hay dos formas de especificar un read_fn: (1) usando una funci√≥n (por ejemplo, function () {<c√≥digo de lectura de la tabla>}) o, (2) con una expresi√≥n de f√≥rmula R. agent Un objeto agent quemarropa. Este objeto se puede utilizar en lugar de proporcionar una tabla en tbl o una f√≥rmula de preparaci√≥n de tablas en read_fn. tbl_name Un nombre opcional para asignar al objeto de la tabla de entrada. Si se proporciona ning√∫n valor, se generar√° un nombre en funci√≥n de la informaci√≥n disponible. label Una etiqueta opcional para el informe de informaci√≥n. Si se proporciona ning√∫n valor, se generar√° una etiqueta basada en la hora actual del sistema. Markdown se puede utilizar aqu√≠ para hacer que la etiqueta sea m√°s atractiva visualmente (aparecer√° en el √°rea de encabezado del informe de informaci√≥n). lang El idioma que se utilizar√° para el informe de informaci√≥n (una tabla de resumen que proporciona toda la informaci√≥n disponible para la tabla. De forma predeterminada, NULL crear√° texto en ingl√©s (\"en\"). Otras opciones incluyen franc√©s (\"fr\"), Alem√°n (\"de\"), italiano (\"\"), espa√±ol (\"es\"), portugu√©s (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), dan√©s (\"da\"), sueco (\"sv\") y holand√©s (\"nl\"). locale Un ID de configuraci√≥n regional opcional que se utilizar√° para dar formato los valores en el informe de informaci√≥n de acuerdo con las reglas de la configuraci√≥n regional. Los ejemplos incluyen \"en_US\" para ingl√©s (Estados Unidos) y \"fr_FR\" para franc√©s (Francia); m√°s simplemente, puede ser un identificador de idioma sin una designaci√≥n de pa√≠s, como \"es\" para espa√±ol (Espa√±a, igual que \"es_ES\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Crear un objeto pointblank informant ‚Äî create_informant","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Crear un objeto pointblank informant ‚Äî create_informant","text":"Se puede escribir un informante pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un informante (con yaml_read_informant()) o realizar la acci√≥n 'incorporar' usando la tabla de destino (trav√©s de yaml_informant_incorporate()). Aqu√≠ hay un ejemplo de c√≥mo una llamada compleja de create_informant() se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. El YAML generado incluye algunas claves de nivel superior donde type y read_fn son obligatorios, y dos secciones de metadatos: table y columns. Las claves que comienzan con un car√°cter de subrayado son las que se actualizan cada vez que se llama incorporate() en un informant. La secci√≥n de metadatos table puede tener m√∫ltiples subsecciones con texto de informaci√≥n. De manera similar, la secci√≥n de metadatos columns puede tener m√∫ltiples subsecciones, siempre que sean elementos secundarios de cada una de las claves de columna (en el ejemplo de YAML anterior, date_time y date son claves de columna y coinciden con los nombres de columna de la tabla). Se pueden agregar secciones adicionales, pero deben tener nombres de clave en el nivel superior que dupliquen el conjunto predeterminado (es decir, type, table, columns, etc. se tratan como claves reservadas).","code":"# C√≥digo R create_informant(   read_fn = ~ small_table,   tbl_name = \"small_table\",   label = \"Un ejemplo.\",   lang = \"fr\",    locale = \"fr_CA\" )  # Representaci√≥n YAML type: informant read_fn: ~small_table tbl_name: small_table info_label: Un ejemplo. lang: fr locale: fr_CA table:   name: small_table   _columns: 8   _rows: 13.0   _type: tbl_df columns:   date_time:     _type: POSIXct, POSIXt   date:     _type: Date   a:     _type: integer   b:     _type: character   c:     _type: numeric   d:     _type: numeric   e:     _type: logical   f:     _type: character"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"escribir-un-objeto-informant-en-el-disco","dir":"Reference","previous_headings":"","what":"Escribir un objeto informant en el disco","title":"Crear un objeto pointblank informant ‚Äî create_informant","text":"Se puede escribir un objeto informant en el disco con la funci√≥n x_write_disk(). Los informantes se almacenan en formato RDS serializado y se pueden recuperar f√°cilmente con la funci√≥n x_read_disk(). Se recomienda que las f√≥rmulas de preparaci√≥n de tablas se proporcionen al argumento read_fn de create_informant(). De esta manera, cuando se lee un informante desde el disco trav√©s de x_read_disk(), se puede reutilizar para acceder la tabla de destino (que puede cambiar, de ah√≠ la necesidad de usar una expresi√≥n para esto).","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Crear un objeto pointblank informant ‚Äî create_informant","text":"1-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_informant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Crear un objeto pointblank informant ‚Äî create_informant","text":"","code":"# Veamos c√≥mo podemos generar informaci√≥n # √∫til para una mesa realmente peque√±a; en # realidad se llama `small_table` y podemos # encontrarlo como un conjunto de datos en # este paquete small_table #> # A tibble: 13 √ó 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # Cree un objeto `informant` en blanco con # `create_informant()` y el conjunto de # datos `small_table` informant <-    create_informant(     read_fn = ~small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   )  # Esta funci√≥n crea informaci√≥n sin ninguna # ayuda adicional al perfilar el objeto de # tabla proporcionado; agrega las secciones: # (1) 'tabla' y (2) 'columnas' y podemos # imprimir el objeto para ver el informe # de informaci√≥n  # Alternativamente, podemos obtener el mismo # informe usando `get_informant_report()` report <- get_informant_report(informant) class(report) #> [1] \"ptblank_informant_report\" \"gt_tbl\"                   #> [3] \"list\""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_multiagent.html","id":null,"dir":"Reference","previous_headings":"","what":"Crear un objeto pointblank multiagent ‚Äî create_multiagent","title":"Crear un objeto pointblank multiagent ‚Äî create_multiagent","text":"Varios agents pueden formar parte de un solo objeto llamado multiagent. Esto puede ser √∫til cuando se re√∫nen varios agentes que han realizado interrogaciones en el pasado (quiz√°s guardados en el disco con x_write_disk()). Cuando formamos parte de un multiagent, podemos obtener un informe que muestra c√≥mo la calidad de los datos evolucion√≥ con el tiempo. Esto puede ser de inter√©s cuando es importante monitorear la calidad de los datos e incluso la evoluci√≥n del propio plan de validaci√≥n. La tabla de informes, generada imprimiendo un objeto ptblank_multiagent o usando la funci√≥n get_multiagent_report(), est√°, por defecto, organizada por el tiempo de interrogaci√≥n y reconoce autom√°ticamente qu√© pasos de validaci√≥n son equivalentes entre interrogaciones.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_multiagent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Crear un objeto pointblank multiagent ‚Äî create_multiagent","text":"","code":"create_multiagent(..., lang = NULL, locale = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_multiagent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Crear un objeto pointblank multiagent ‚Äî create_multiagent","text":"... Uno o m√°s objetos de agent pointblank. lang El idioma que se utilizar√° para cualquier informe que se generar√° partir del multiagente. De forma predeterminada, NULL crear√° texto en ingl√©s (\"en\"). Otras opciones incluyen franc√©s (\"fr\"), alem√°n (\"de\"), italiano (\"\"), espa√±ol (\"es\"), portugu√©s (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), dan√©s (\"da\"), sueco (\"sv\") y holand√©s (\"nl\"). locale Un ID de configuraci√≥n regional opcional que se utilizar√° para formatear valores en las salidas de informes de acuerdo con las reglas de la configuraci√≥n regional. Los ejemplos incluyen \"en_US\" para ingl√©s (Estados Unidos) y \"fr_FR\" para franc√©s (Francia); m√°s simplemente, puede ser un identificador de idioma sin una designaci√≥n de pa√≠s, como \"es\" para espa√±ol (Espa√±a, igual que \"es_ES\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_multiagent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Crear un objeto pointblank multiagent ‚Äî create_multiagent","text":"Un objeto ptblank_multiagent.","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_multiagent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Crear un objeto pointblank multiagent ‚Äî create_multiagent","text":"10-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/create_multiagent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Crear un objeto pointblank multiagent ‚Äî create_multiagent","text":"","code":"if (interactive()) {  # Repasemos varios an√°lisis te√≥ricos de # la calidad de los datos de una tabla # extremadamente peque√±a; esa tabla se # llama `small_table` y podemos # encontrarla como un conjunto de datos # en este paquete small_table  # Para establecer l√≠mites de falla y # condiciones de se√±al, designamos # umbrales de falla proporcionales a # los estados `warn`, `stop` y # `notify` usando `action_levels()` al <-    action_levels(     warn_at = 0.05,     stop_at = 0.10,     notify_at = 0.20   )  # Crearemos cuatro agentes diferentes # y tendremos pasos de validaci√≥n # ligeramente diferentes en cada uno # de ellos; en el primero, `agent_1`, # se crean ocho pasos de validaci√≥n # diferentes y el agente interrogar√° # a la `small_table` agent_1 <-   create_agent(     read_fn = ~ small_table,     label = \"Un ejemplo.\",     actions = al   ) %>%   col_vals_gt(     vars(date_time),     value = vars(date),     na_pass = TRUE   ) %>%   col_vals_gt(     vars(b),      value = vars(g),     na_pass = TRUE   ) %>%   rows_distinct() %>%   col_vals_equal(     vars(d),      value = vars(d),     na_pass = TRUE   ) %>%   col_vals_between(     vars(c),      left = vars(a), right = vars(d)   ) %>%   col_vals_not_between(     vars(c),     left = 10, right = 20,     na_pass = TRUE   ) %>%   rows_distinct(vars(d, e, f)) %>%   col_is_integer(vars(a)) %>%   interrogate()  # El segundo agente, `agent_2`, # conserva todos los pasos de `agent_1` # y agrega dos m√°s (el √∫ltimo de los # cuales est√° inactivo) agent_2 <-    agent_1 %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),      regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     active = FALSE   ) %>%   interrogate()  # El tercer agente, `agent_3`, agrega # un solo paso de validaci√≥n, elimina # el quinto y desactiva el primero agent_3 <-    agent_2 %>%   col_vals_in_set(     vars(f),     set = c(\"low\", \"mid\", \"high\")   ) %>%   remove_steps(i = 5) %>%   deactivate_steps(i = 1) %>%   interrogate()  # El cuarto y √∫ltimo agente, `agent_4`, # reactiva los pasos 1 y 10, y elimina # el sexto paso agent_4 <-   agent_3 %>%   activate_steps(i = 1) %>%   activate_steps(i = 10) %>%   remove_steps(i = 6) %>%   interrogate()  # Si bien todos los agentes son # ligeramente diferentes entre s√≠, a√∫n # podemos obtener un informe combinado # de ellos creando un objeto 'multiagent' multiagent <-   create_multiagent(     agent_1, agent_2, agent_3, agent_4   )  # Llamar a un objeto `multiagent` en # la consola imprime el informe # multiagente; pero podemos obtener un # objeto `gt_tbl` con la funci√≥n # `get_multiagent_report()` report <- get_multiagent_report(multiagent)  class(report)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/db_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtener una tabla de una base de datos ‚Äî db_tbl","title":"Obtener una tabla de una base de datos ‚Äî db_tbl","text":"Si su tabla de destino est√° en una base de datos, la funci√≥n db_tbl() es una forma pr√°ctica de acceder ella. Esta funci√≥n simplifica el proceso de obtener un objeto tbl_dbi, que generalmente implica una combinaci√≥n de construir una conexi√≥n una base de datos y usar la funci√≥n dplyr::tbl() con la conexi√≥n y el nombre de la tabla (o una referencia una tabla en un esquema). Puede usar db_tbl() como base para obtener una tabla de base de datos para el par√°metro read_fn en create_agent() o create_informant(). Esto se puede hacer usando un ~ antes de la llamada db_tbl() (por ejemplo, read_fn = ~ db_tbl (...)). Otra gran opci√≥n es proporcionar una f√≥rmula de preparaci√≥n de tablas que involucre db_tbl() tbl_store() para que tenga acceso las tablas de la base de datos trav√©s de nombres √∫nicos trav√©s de un almac√©n de tablas. El nombre de usuario y la contrase√±a se proporcionan trav√©s de variables de entorno. Si lo desea, estos se pueden proporcionar directamente encerrando esos valores en ().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/db_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtener una tabla de una base de datos ‚Äî db_tbl","text":"","code":"db_tbl(   table,   dbname,   dbtype,   host = NULL,   port = NULL,   user = NULL,   password = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/db_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtener una tabla de una base de datos ‚Äî db_tbl","text":"table El nombre de la tabla, o una referencia una tabla en un esquema (vector de dos elementos con los nombres de esquema y tabla). Alternativamente, esto se puede proporcionar como una tabla de datos para copiar en una conexi√≥n de base de datos en memoria. Esto solo funciona si: (1) el db es \"sqlite\" o \"duckdb\" , (2) el dbname fue elegido como \":memory:\", y (3) el data_tbl es un marco de datos o un objeto tibble. dbname El nombre de la base de datos. dbtype Ya sea una funci√≥n de controlador apropiada (por ejemplo, RPostgres::Postgres()) o un nombre corto para el tipo de base de datos. Los nombres v√°lidos son: \"postgresql\", \"postgres\", o \"pgsql\" (PostgreSQL, usando la funci√≥n del controlador RPostgres::Postgres()); \"mysql\" (MySQL, usando RMySQL::MySQL()); \"duckdb\" (DuckDB, usando duckdb::duckdb()); y \"sqlite\" (SQLite, usando RSQLite::SQLite()). host, port El host de la base de datos y el n√∫mero de puerto opcional. user, password Las variables de entorno utilizadas para acceder al nombre de usuario y la contrase√±a de la base de datos.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/db_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtener una tabla de una base de datos ‚Äî db_tbl","text":"Un objeto tbl_dbi.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/db_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtener una tabla de una base de datos ‚Äî db_tbl","text":"1-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/db_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtener una tabla de una base de datos ‚Äî db_tbl","text":"","code":"# Puede usar una tabla de base de # datos en memoria y proporcionarle # una tabla en memoria tambi√©n: small_table_duckdb <-    db_tbl(     table = small_table,     dbname = \":memory:\",     dbtype = \"duckdb\"   )  if (interactive()) {  # Tambi√©n es posible obtener un # archivo remoto y guardarlo en una # base de datos en memoria; use el # combo `file_tbl()` + `db_tbl()` all_revenue_large_duckdb <-   db_tbl(     table = file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"       )     ),     dbname = \":memory:\",     dbtype = \"duckdb\"   )  # Para las bases de datos remotas, # es muy similar; aqu√≠ hay un ejemplo # que accede a la tabla `rna` (en la # base de datos p√∫blica de RNA Central) # usando `db_tbl()` rna_db_tbl <-    db_tbl(     table = \"rna\",     dbname = \"pfmegrnargs\",     dbtype = \"postgres\",      host = \"hh-pgsql-public.ebi.ac.uk\",     port = 5432,     user = I(\"reader\"),     password = I(\"NWDMCE5xdipIjRrp\")   )  # El uso de `I()` para el nombre de # usuario y la contrase√±a significa que # est√° pasando los valores reales pero, # normalmente, querr√° usar los nombres # de las variables de entorno (envvars) # para acceder de forma segura a los # valores de nombre de usuario y # contrase√±a apropiados cuando se # conecte a una base de datos: example_db_tbl <-    db_tbl(     table = \"<table_name>\",     dbname = \"<database_name>\",     dbtype = \"<database_type_shortname>\",      host = \"<connection_url>\",     port = \"<connection_port>\",     user = \"<DB_USER_NAME>\",     password = \"<DB_PASSWORD>\"   )  # Las variables de entorno se pueden # crear editando el archivo de usuario # `.Renviron` y la funci√≥n # `usethis::edit_r_environ()` hace que # esto sea bastante f√°cil de hacer  # El almacenamiento de f√≥rmulas de # preparaci√≥n de tablas en una tienda # de tablas facilita el trabajo con # tablas de base de datos en blanco; # aqu√≠ se explica c√≥mo generar un # almac√©n de tablas con dos entradas # con nombre para la preparaci√≥n de # la tabla tbls <-   tbl_store(     small_table_duck ~ db_tbl(       table = pointblank::small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     small_high_duck ~ db_tbl(       table = pointblank::small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ) %>%       dplyr::filter(f == \"high\")   )  # Ahora es f√°cil acceder a cualquiera # de estas tablas (la segunda es una # versi√≥n mutada) a trav√©s de la # funci√≥n `tbl_get()` tbl_get(\"small_table_duck\", store = tbls) tbl_get(\"small_high_duck\", store = tbls)  # Las f√≥rmulas de preparaci√≥n de tablas # en `tbls` tambi√©n podr√≠an usarse en # funciones con el argumento `read_fn`; # esto es gracias a la funci√≥n # `tbl_source()` agent <-    create_agent(     read_fn = ~ tbl_source(       \"small_table_duck\",       store = tbls     )   )  informant <-    create_informant(     read_fn = ~ tbl_source(       \"small_high_duck\",       store = tbls     )   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/deactivate_steps.html","id":null,"dir":"Reference","previous_headings":"","what":"Desactive uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî deactivate_steps","title":"Desactive uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî deactivate_steps","text":"Si fuera necesario desactivar uno o m√°s pasos de validaci√≥n despu√©s de la creaci√≥n del plan de validaci√≥n para un agent, la funci√≥n deactivate_steps() ser√° √∫til para ello. Esto tiene el mismo efecto que usar la opci√≥n active = FALSE (active es un argumento en todas las funciones de validaci√≥n) para los pasos de validaci√≥n seleccionados. Tenga en cuenta que esto edita directamente el paso de validaci√≥n, eliminando cualquier funci√≥n que pueda haber sido definida para si el paso deber√≠a estar activo o .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/deactivate_steps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Desactive uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî deactivate_steps","text":"","code":"deactivate_steps(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/deactivate_steps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Desactive uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî deactivate_steps","text":"agent Un objeto de agente de clase ptblank_agent. El n√∫mero de paso de validaci√≥n, que se asigna cada paso de validaci√≥n en el orden de definici√≥n.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/deactivate_steps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Desactive uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî deactivate_steps","text":"Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/deactivate_steps.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Desactive uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî deactivate_steps","text":"9-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/deactivate_steps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Desactive uno o m√°s de los pasos de validaci√≥n de un agent ‚Äî deactivate_steps","text":"","code":"# Cree un agente que tenga el objeto # `small_table` como tabla de destino, # agregue algunos pasos de validaci√≥n # y luego use `interrogate()` agent_1 <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%   col_exists(vars(date)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]\"   ) %>%   interrogate()    # El segundo paso de validaci√≥n # se est√° reconsiderando ahora y # puede eliminarse gradualmente o # mejorarse; en el per√≠odo # intermedio se decidi√≥ que el paso # deber√≠a desactivarse por ahora agent_2 <-   agent_1 %>%   deactivate_steps(i = 2) %>%   interrogate() #> ‚Ñπ Step 2 is not set as active. Skipping."},{"path":"https://rich-iannone.github.io/pointblank/es/reference/draft_validation.html","id":null,"dir":"Reference","previous_headings":"","what":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos ‚Äî draft_validation","title":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos ‚Äî draft_validation","text":"Genere un borrador del plan de validaci√≥n en un nuevo archivo .R o .Rmd usando una tabla de datos de entrada. Con este flujo de trabajo, se escanear√° la tabla de datos para conocer los datos de su columna y se escribir√° un conjunto de pasos de validaci√≥n de inicio (que constituyen un plan de validaci√≥n). Es mejor utilizar un extracto de datos que contenga al menos 1000 filas y que est√© relativamente libre de datos falsos. Una vez en el archivo, es posible modificar los pasos de validaci√≥n para que se ajusten mejor las expectativas del dominio en particular. Si bien la inferencia de columna se utiliza para generar planes de validaci√≥n razonables, es dif√≠cil inferir los valores aceptables sin experiencia en el dominio. Sin embargo, usar draft_validation() podr√≠a ayudarlo comenzar en el piso 10 para abordar los problemas de calidad de los datos y, en cualquier caso, es mejor que comenzar con una vista de editor de c√≥digo vac√≠a.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/draft_validation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos ‚Äî draft_validation","text":"","code":"draft_validation(   tbl,   tbl_name = NULL,   file_name = tbl_name,   path = NULL,   lang = NULL,   output_type = c(\"R\", \"Rmd\"),   add_comments = TRUE,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/draft_validation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos ‚Äî draft_validation","text":"tbl La tabla de entrada. Puede ser un marco de datos, tibble, un objeto tbl_dbi o un objeto tbl_spark. tbl_name Un nombre opcional para asignar al objeto de la tabla de entrada. Si se proporciona ning√∫n valor, se generar√° un nombre en funci√≥n de la informaci√≥n disponible. Este nombre de tabla se mostrar√° en el √°rea de encabezado del informe del agente generado al imprimir el agent o llamar get_agent_report(). file_name Un nombre opcional para el archivo .R o .Rmd. Debe ser un nombre sin extensi√≥n. Por defecto, esto se toma del tbl_name pero si se proporciona nada para eso, el nombre contendr√° el texto \"draft_validation_\" seguido de la fecha y hora actuales. path Aqu√≠ se puede especificar una ruta si se debe intentar colocar el archivo generado en el directorio de trabajo. lang El idioma que se utilizar√° al crear comentarios para los pasos de validaci√≥n generados autom√°ticamente. De forma predeterminada, NULL crear√° texto en ingl√©s (\"en\"). Otras opciones incluyen franc√©s (\"fr\"), alem√°n (\"de\"), italiano (\"\"), espa√±ol (\"es\"), portugu√©s (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), dan√©s (\"da\"), sueco (\"sv\" ) y holand√©s (\"nl\"). output_type Una opci√≥n para elegir qu√© tipo de salida se debe generar. De forma predeterminada, este es un script .R (\"R\") pero podr√≠a ser alternativamente un documento R Markdown (\"Rmd\"). add_comments ¬øDeber√≠a haber comentarios que expliquen las caracter√≠sticas del plan de validaci√≥n en el documento generado? De forma predeterminada, es TRUE. overwrite ¬øDeber√≠a sobrescribirse un archivo con el mismo nombre? De forma predeterminada, es FALSE. quiet ¬øDeber√≠a la funci√≥n informar cuando se escribe el archivo? Por defecto, esto es FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/draft_validation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos ‚Äî draft_validation","text":"Devuelve de forma invisible TRUE si el archivo se ha escrito.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/draft_validation.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos ‚Äî draft_validation","text":"1-11","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/draft_validation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Redacte un archivo inicial pointblank validation .R / .Rmd con una tabla\nde datos ‚Äî draft_validation","text":"","code":"if (interactive()) {  # Proyecto de plan de validaci√≥n # para la tabla `dplyr::storms` draft_validation(tbl = dplyr::storms)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_blast.html","id":null,"dir":"Reference","previous_headings":"","what":"Env√≠e un correo electr√≥nico en un paso de validaci√≥n o al final de un\ninterrogatorio ‚Äî email_blast","title":"Env√≠e un correo electr√≥nico en un paso de validaci√≥n o al final de un\ninterrogatorio ‚Äî email_blast","text":"email_blast() function useful sending email message explains result pointblank validation. powered blastula glue packages. function invoked part end_fns argument create_agent(). also possible invoke email_blast() part fns argument action_levels() function (.e., send multiple email messages granularity different validation steps exceeding failure thresholds). better get handle emailing email_blast(), analogous email_create() function can used pointblank agent object x-list obtained using get_agent_x_list() function.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_blast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Env√≠e un correo electr√≥nico en un paso de validaci√≥n o al final de un\ninterrogatorio ‚Äî email_blast","text":"","code":"email_blast(   x,   to,   from,   credentials = NULL,   msg_subject = NULL,   msg_header = NULL,   msg_body = stock_msg_body(),   msg_footer = stock_msg_footer(),   send_condition = ~TRUE %in% x$notify )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_blast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Env√≠e un correo electr√≥nico en un paso de validaci√≥n o al final de un\ninterrogatorio ‚Äî email_blast","text":"x reference x-list object prepared internally agent. version x-list generated via get_agent_x_list(<agent>) except version internally generated hence available internal evaluation context. , email addresses recipients sender. credentials credentials list object produced either blastula::creds(), blastula::creds_anonymous(), blastula::creds_key(), blastula::creds_file() functions. Please refer blastula documentation information use functions. msg_subject subject line email message. msg_header, msg_body, msg_footer Content header, body, footer components HTML email message. send_condition expression evaluate logical vector length 1. evaluated TRUE email sent, FALSE happen. expression can use x-list variables (e.g., x$notify, x$type, etc.) variables can explored using get_agent_x_list() function. default expression ~TRUE %% x$notify, results TRUE TRUE values x$notify logical vector (.e., validation step results 'notify' condition).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_blast.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Env√≠e un correo electr√≥nico en un paso de validaci√≥n o al final de un\ninterrogatorio ‚Äî email_blast","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). example use email_blast() inside end_fns argument create_agent() expressed R code corresponding YAML representation.","code":"# C√≥digo R create_agent(   read_fn = ~ small_table,   tbl_name = \"small_table\",   label = \"Un ejemplo.\",   actions = al,   end_fns = list(     ~ email_blast(       x,       to = \"joe_public@example.com\",       from = \"pb_notif@example.com\",       msg_subject = \"Table Validation\",       credentials = blastula::creds_key(         id = \"smtp2go\"       ),     )   ) ) %>%   col_vals_gt(vars(a), 1) %>%   col_vals_lt(vars(a), 7)   # Representaci√≥n YAML type: agent read_fn: ~small_table tbl_name: small_table label: Un ejemplo. lang: en locale: en actions:   warn_count: 1.0   notify_count: 2.0 end_fns: ~email_blast(x, to = \"joe_public@example.com\",    from = \"pb_notif@example.com\", msg_subject = \"Table Validation\",   credentials = blastula::creds_key(id = \"smtp2go\"),   ) embed_report: true steps:   - col_vals_gt:     columns: vars(a)     value: 1.0   - col_vals_lt:     columns: vars(a)     value: 7.0"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_blast.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Env√≠e un correo electr√≥nico en un paso de validaci√≥n o al final de un\ninterrogatorio ‚Äî email_blast","text":"4-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_blast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Env√≠e un correo electr√≥nico en un paso de validaci√≥n o al final de un\ninterrogatorio ‚Äî email_blast","text":"","code":"# Create an `action_levels()` list # with absolute values for the # `warn`, and `notify` states (with # thresholds of 1 and 2 'fail' units) al <-    action_levels(     warn_at = 1,     notify_at = 2   )    if (interactive()) {  # Validate that values in column # `a` from `small_tbl` are always > 1 # and that they are always < 7; first, # apply the `actions_levels()` # directive to `actions` and set up # an `email_blast()` as one of the # `end_fns` (by default, the email # will be sent if there is a single # 'notify' state across all # validation steps) agent <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al,     end_fns = list(       ~ email_blast(         x,         to = \"joe_public@example.com\",         from = \"pb_notif@example.com\",         msg_subject = \"Table Validation\",         credentials = blastula::creds_key(           id = \"smtp2go\"         ),       )     )   ) %>%   col_vals_gt(vars(a), value = 1) %>%   col_vals_lt(vars(a), value = 7) %>%   interrogate()  }  # The above example was intentionally # not run because email credentials # aren't available and the `to` # and `from` email addresses are # nonexistent  # To get a blastula email object # instead of eagerly sending the # message, we can use the  # `email_create()` function email_object <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_vals_gt(vars(a), value = 5) %>%   col_vals_lt(vars(a), value = 7) %>%   interrogate() %>%   email_create()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Cree un objeto de correo electr√≥nico a partir de un pointblank agent o\ninformant ‚Äî email_create","title":"Cree un objeto de correo electr√≥nico a partir de un pointblank agent o\ninformant ‚Äî email_create","text":"email_create() function produces email message object sent using blastula package. x need either pointblank agent, agent x-list (produced agent get_agent_x_list() function), pointblank informant. cases, email message appear Viewer blastula email_message object returned.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cree un objeto de correo electr√≥nico a partir de un pointblank agent o\ninformant ‚Äî email_create","text":"","code":"email_create(   x,   msg_header = NULL,   msg_body = stock_msg_body(),   msg_footer = stock_msg_footer() )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cree un objeto de correo electr√≥nico a partir de un pointblank agent o\ninformant ‚Äî email_create","text":"x pointblank agent, agent x-list, pointblank informant. x-list object can created get_agent_x_list() function. recommended option = NULL used get_agent_x_list() supplying x-list x. Furthermore, option generate_report = TRUE used create_agent() agent report available within email. msg_header, msg_body, msg_footer Content header, body, footer components HTML email message.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cree un objeto de correo electr√≥nico a partir de un pointblank agent o\ninformant ‚Äî email_create","text":"blastulaemail_message object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_create.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Cree un objeto de correo electr√≥nico a partir de un pointblank agent o\ninformant ‚Äî email_create","text":"4-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/email_create.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cree un objeto de correo electr√≥nico a partir de un pointblank agent o\ninformant ‚Äî email_create","text":"","code":"if (interactive()) {  # Create an `action_levels()` list # with absolute values for the # `warn`, and `notify` states (with # thresholds of 1 and 2 'fail' units) al <-    action_levels(     warn_at = 1,     notify_at = 2   )  # In a workflow that involves an # `agent` object, we can make use of # the `end_fns` argument and # programmatically email the report # with the `email_blast()` function, # however, an alternate workflow is to # produce the email object and choose # to send outside of the pointblank API; # the `email_create()` function lets # us do this with an `agent` object email_object_1 <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_vals_gt(vars(a), value = 1) %>%   col_vals_lt(vars(a), value = 7) %>%   interrogate() %>%   email_create()  # We can view the HTML email just # by printing `email_object`; it # should appear in the Viewer  # The `email_create()` function can # also be used on an agent x-list to # get the same email message object email_object_2 <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_vals_gt(vars(a), value = 5) %>%   col_vals_lt(vars(b), value = 5) %>%   interrogate() %>%   get_agent_x_list() %>%   email_create()  # An information report that's # produced by the informant can # made into an email message object; # let's create an informant and use # `email_create()` email_object_3 <-   create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%   info_tabular(     info = \"A simple table in the     *Examples* section of the function     called `email_create()`.\"   ) %>%   info_columns(     columns = vars(a),     info = \"Numbers. On the high side.\"   ) %>%   info_columns(     columns = vars(b),     info = \"Lower numbers. Zeroes, even.\"   ) %>%   incorporate() %>%   email_create()  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/export_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML ‚Äî export_report","title":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML ‚Äî export_report","text":"agent, informant, multiagent, table scan object can easily written HTML export_report(). Furthermore, report objects agent, informant, multiagent (generated using get_agent_report(), get_informant_report(), get_multiagent_report()) can provided HTML export. HTML document written disk self-contained easily viewable web browser.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/export_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML ‚Äî export_report","text":"","code":"export_report(x, filename, path = NULL, quiet = FALSE)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/export_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML ‚Äî export_report","text":"x agent object class ptblank_agent, informant class ptblank_informant, multiagent class ptblank_multiagent, table scan class ptblank_tbl_scan, , customized reporting objects (ptblank_agent_report, ptblank_informant_report, ptblank_multiagent_report.wide, ptblank_multiagent_report.long). filename filename create disk HTML export object provided. recommended extension \".html\" included. path optional path file saved (automatically combined filename). quiet function inform file written? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/export_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML ‚Äî export_report","text":"Invisibly returns TRUE file written.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/export_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML ‚Äî export_report","text":"9-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/export_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exportar un agent, informant, multiagent o escaneo de tabla a HTML ‚Äî export_report","text":"","code":"if (interactive()) {  # A: Writing an agent report as HTML   # Let's go through the process of (1) # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # (2) interrogating the agent with the # `interrogate()` function, and (3) writing # the agent and all its intel to a file  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`export_report()`\",     actions = al   )  # Then, as with any agent object, we # can add steps to the validation plan by # using as many validation functions as we # want; then, we `interrogate()` agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5) %>%   interrogate()  # The agent report can be written to an # HTML file with `export_report()` export_report(   agent,   filename = \"agent-small_table.html\" )  # If you're consistently writing agent # reports when periodically checking data, # we could make use of `affix_date()` or # `affix_datetime()` depending on the # granularity you need; here's an example # that writes the file with the format: # 'agent-small_table-YYYY-mm-dd_HH-MM-SS.html' export_report(   agent,   filename = affix_datetime(     \"agent-small_table.html\"   ) )  # B: Writing an informant report as HTML  # Let's go through the process of (1) # creating an informant object that # minimally describes the `small_table` # dataset, (2) ensuring that data is # captured from the target table using # the `incorporate()` function, and (3) # writing the informant report to HTML  # Create a pointblank `informant` # object with `create_informant()` # and the `small_table` dataset; # `incorporate()` so that info snippets # are integrated into the text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`export_report()`\"   ) %>%   info_snippet(     snippet_name = \"high_a\",     fn = snip_highest(column = \"a\")   ) %>%   info_snippet(     snippet_name = \"low_a\",     fn = snip_lowest(column = \"a\")   ) %>%   info_columns(     columns = vars(a),     info = \"From {low_a} to {high_a}.\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values.\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`.\"   ) %>%   incorporate()  # The informant report can be written # to an HTML file with `export_report()`; # let's do this with `affix_date()` so # the filename has a datestamp export_report(   informant,   filename = affix_date(     \"informant-small_table.html\"   ) )  # C: Writing a table scan as HTML  # We can get an report that describes all # of the data in the `storms` dataset tbl_scan <- scan_data(tbl = dplyr::storms)  # The table scan object can be written # to an HTML file with `export_report()` export_report(   tbl_scan,   filename = \"tbl_scan-storms.html\" )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/file_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtener una tabla de un archivo local o remoto ‚Äî file_tbl","title":"Obtener una tabla de un archivo local o remoto ‚Äî file_tbl","text":"target table file, stored either locally remotely, file_tbl() function can make possible access single function call. Compatible file types function : CSV (.csv), TSV (.tsv), RDA (.rda), RDS (.rds) files. function generates -memory tbl_dbl object, can used target table create_agent() create_informant(). ideal option data access file_tbl() using function read_fn parameter either aforementioned create_*() functions. can done using leading ~ (e.g,. read_fn = ~file_tbl(...)). remote data use case, can specify URL starting http://, https://, etc., ending file containing data table. data files available GitHub repository can use from_github() function specify name location table data repository.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/file_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtener una tabla de un archivo local o remoto ‚Äî file_tbl","text":"","code":"file_tbl(file, type = NULL, ..., keep = FALSE, verify = TRUE)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/file_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtener una tabla de un archivo local o remoto ‚Äî file_tbl","text":"file complete file path leading compatible data table either user system http://, https://, ftp://, ftps:// URL. file hosted GitHub repository, call from_github() function can used . type file type. normally inferred file extension default NULL indicate extension dictate type file reading performed internally. However, extension (valid extensions .csv, .tsv, .rda, .rds), can provide type either csv, tsv, rda, rds. ... Options passed readr's read_csv() read_tsv() function. functions arguments one used internally based file extension explicit value given type. keep case downloaded file, stored working directory (keep = TRUE) downloaded temporary directory? default, FALSE. verify TRUE (default) verification data object data.frame class carried .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/file_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtener una tabla de un archivo local o remoto ‚Äî file_tbl","text":"Un objeto tbl_df.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/file_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtener una tabla de un archivo local o remoto ‚Äî file_tbl","text":"1-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/file_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtener una tabla de un archivo local o remoto ‚Äî file_tbl","text":"","code":"# A local CSV file can be obtained as # a tbl object by supplying a path to # the file and some CSV reading options # (the ones used by `readr::read_csv()`) # to the `file_tbl()` function; for # this example we could obtain a path # to a CSV file in the pointblank # package with `system.file()`: csv_path <-    system.file(     \"data_files\", \"small_table.csv\",     package = \"pointblank\"   )  # Then use that path in `file_tbl()` # with the option to specify the column # types in that CSV   tbl <-    file_tbl(     file = csv_path,     col_types = \"TDdcddlc\"   )    # Now that we have a `tbl` object that # is a tibble, it can be introduced to # `create_agent()` for validation agent <- create_agent(tbl = tbl)  # A different strategy is to provide # the data-reading function call # directly to `create_agent()`: agent <-    create_agent(     read_fn = ~ file_tbl(       file = system.file(         \"data_files\", \"small_table.csv\",         package = \"pointblank\"       ),       col_types = \"TDdcddlc\"     )   ) %>%   col_vals_gt(vars(a), value = 0)  # All of the file-reading instructions # are encapsulated in the `read_fn` so # the agent will always obtain the most # recent version of the dataset (and the # logic can be translated to YAML, for # later use)  if (interactive()) {  # A CSV can be obtained from a public # GitHub repo by using the `from_github()` # helper function; let's create an agent # a supply a table-prep formula that # gets the same CSV file from the GitHub # repository for the pointblank package  agent <-    create_agent(     read_fn = ~ file_tbl(       file = from_github(         file = \"inst/data_files/small_table.csv\",         repo = \"rich-iannone/pointblank\"       ),       col_types = \"TDdcddlc\"     )   ) %>%   col_vals_gt(vars(a), value = 0) %>%   interrogate()  # This interrogated the data that was # obtained from the remote source file, # and, there's nothing to clean up (by # default, the downloaded file goes into # a system temp directory)  # Storing table-prep formulas in a table # store makes it easier to work with # tabular data originating from files; # here's how to generate a table store # with two named entries for table # preparations tbls <-   tbl_store(     small_table_file ~ file_tbl(       file = system.file(         \"data_files\", \"small_table.csv\",         package = \"pointblank\"       ),       col_types = \"TDdcddlc\"     ),     small_high_file ~ file_tbl(       file = system.file(         \"data_files\", \"small_table.csv\",         package = \"pointblank\"       ),       col_types = \"TDdcddlc\"     ) %>%       dplyr::filter(f == \"high\")   )  # Now it's easy to access either of these # tables (the second is a mutated version) # via the `tbl_get()` function tbl_get(\"small_table_file\", store = tbls) tbl_get(\"small_high_file\", store = tbls)  # The table-prep formulas in `tbls` # could also be used in functions with # the `read_fn` argument; this is thanks # to the `tbl_source()` function agent <-    create_agent(     read_fn = ~ tbl_source(       \"small_table_file\",       store = tbls     )   )  informant <-    create_informant(     read_fn = ~ tbl_source(       \"small_high_file\",       store = tbls     )   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/from_github.html","id":null,"dir":"Reference","previous_headings":"","what":"Especificar un archivo para descargar desde GitHub ‚Äî from_github","title":"Especificar un archivo para descargar desde GitHub ‚Äî from_github","text":"from_github() function helpful generating valid URL points data file public GitHub repository. function can used file argument file_tbl() function anywhere else GitHub URLs raw user content needed.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/from_github.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Especificar un archivo para descargar desde GitHub ‚Äî from_github","text":"","code":"from_github(file, repo, subdir = NULL, default_branch = \"main\")"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/from_github.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Especificar un archivo para descargar desde GitHub ‚Äî from_github","text":"file name file target GitHub repository. can path leading including file. combined path given subdir. repo GitHub repository address format username/repo[/subdir][@ref|#pull|@*release]. subdir path string representing subdirectory GitHub repository. combined path components included file.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/from_github.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Especificar un archivo para descargar desde GitHub ‚Äî from_github","text":"character vector length 1 contains URL.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/from_github.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Especificar un archivo para descargar desde GitHub ‚Äî from_github","text":"13-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/from_github.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Especificar un archivo para descargar desde GitHub ‚Äî from_github","text":"","code":"# A valid URL to a data file in GitHub can be # obtained from the HEAD of the default branch # from_github( #   file = \"inst/data_files/small_table.csv\", #   repo = \"rich-iannone/pointblank\" # )  # The path to the file location can be supplied # fully or partially to `subdir` # from_github( #   file = \"small_table.csv\", #   repo = \"rich-iannone/pointblank\", #   subdir = \"inst/data_files\" # )  # We can use the first call in combination with # `file_tbl()` and `create_agent()`; this # supplies a table-prep formula that gets # a CSV file from the GitHub repository for the # pointblank package  # agent <-  #   create_agent( #     read_fn = ~ file_tbl( #       file = from_github( #         file = \"inst/data_files/small_table.csv\", #         repo = \"rich-iannone/pointblank\" #       ), #       col_types = \"TDdcddlc\" #     ) #   ) %>% #   col_vals_gt(vars(a), 0) %>% #   interrogate()  # The `from_github()` helper function is # pretty powerful and can get at lots of # different files in a repository  # A data file from GitHub can be obtained from # a commit at release time # from_github( #   file = \"inst/extdata/small_table.csv\", #   repo = \"rich-iannone/pointblank@v0.2.1\" # )  # A file may also be obtained from a repo at the # point in time of a specific commit (partial or # full SHA-1 hash for the commit can be used) # from_github( #   file = \"data-raw/small_table.csv\", #   repo = \"rich-iannone/pointblank@e04a71\" # )  # A file may also be obtained from an # *open* pull request # from_github( #   file = \"data-raw/small_table.csv\", #   repo = \"rich-iannone/pointblank#248\" # )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue.html","id":null,"dir":"Reference","previous_headings":"","what":"Una tabla con datos de ingresos del juego ‚Äî game_revenue","title":"Una tabla con datos de ingresos del juego ‚Äî game_revenue","text":"Esta tabla es un subconjunto de la tabla sj_all_revenue del paquete de datos intendo. Son las primeras 2000 filas de esa tabla donde los registros de ingresos van desde 2015-01-01 hasta 2015-01-21.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Una tabla con datos de ingresos del juego ‚Äî game_revenue","text":"","code":"game_revenue"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Una tabla con datos de ingresos del juego ‚Äî game_revenue","text":"tibble 2,000 rows 11 variables: player_id character column unique identifiers user/player. session_id character column contains unique identifiers player session. session_start date-time column indicates session (containing revenue event) started. time date-time column indicates exactly player purchase (revenue event) occurred. item_type character column provides class item purchased. item_name character column provides name item purchased. item_revenue numeric column revenue amounts per item purchased. session_duration numeric column states length session (minutes) purchase occurred. start_day Date column provides date first login player making purchase. acquisition character column provides method acquisition player. country character column provides probable country residence player.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Una tabla con datos de ingresos del juego ‚Äî game_revenue","text":"14-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Una tabla con datos de ingresos del juego ‚Äî game_revenue","text":"","code":"# Aqu√≠ hay un vistazo a los datos # disponibles en `game_revenue` dplyr::glimpse(game_revenue) #> Rows: 2,000 #> Columns: 11 #> $ player_id        <chr> \"ECPANOIXLZHF896\", \"ECPANOIXLZHF896\", \"ECPANOIXLZHF89‚Ä¶ #> $ session_id       <chr> \"ECPANOIXLZHF896-eol2j8bs\", \"ECPANOIXLZHF896-eol2j8bs‚Ä¶ #> $ session_start    <dttm> 2015-01-01 01:31:03, 2015-01-01 01:31:03, 2015-01-01‚Ä¶ #> $ time             <dttm> 2015-01-01 01:31:27, 2015-01-01 01:36:57, 2015-01-01‚Ä¶ #> $ item_type        <chr> \"iap\", \"iap\", \"iap\", \"ad\", \"ad\", \"ad\", \"ad\", \"ad\", \"a‚Ä¶ #> $ item_name        <chr> \"offer2\", \"gems3\", \"gold7\", \"ad_20sec\", \"ad_5sec\", \"a‚Ä¶ #> $ item_revenue     <dbl> 8.991, 22.491, 107.991, 0.760, 0.030, 0.070, 0.080, 1‚Ä¶ #> $ session_duration <dbl> 16.3, 16.3, 16.3, 16.3, 35.2, 35.2, 35.2, 35.2, 35.2,‚Ä¶ #> $ start_day        <date> 2015-01-01, 2015-01-01, 2015-01-01, 2015-01-01, 2015‚Ä¶ #> $ acquisition      <chr> \"google\", \"google\", \"google\", \"google\", \"google\", \"go‚Ä¶ #> $ country          <chr> \"Germany\", \"Germany\", \"Germany\", \"Germany\", \"Germany\"‚Ä¶"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Una tabla con metadatos para el conjunto de datos game_revenue ‚Äî game_revenue_info","title":"Una tabla con metadatos para el conjunto de datos game_revenue ‚Äî game_revenue_info","text":"table contains metadata game_revenue table. first column (named column) provides column names game_revenue. second column (info) contains descriptions columns dataset. table correct format use info_columns_from_tbl() function.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Una tabla con metadatos para el conjunto de datos game_revenue ‚Äî game_revenue_info","text":"","code":"game_revenue_info"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue_info.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Una tabla con metadatos para el conjunto de datos game_revenue ‚Äî game_revenue_info","text":"tibble 11 rows 2 variables: column character column unique identifiers user/player. info character column contains unique identifiers player session.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue_info.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Una tabla con metadatos para el conjunto de datos game_revenue ‚Äî game_revenue_info","text":"14-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/game_revenue_info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Una tabla con metadatos para el conjunto de datos game_revenue ‚Äî game_revenue_info","text":"","code":"# Here is a glimpse at the data # available in `game_revenue_info` dplyr::glimpse(game_revenue_info) #> Rows: 11 #> Columns: 2 #> $ column <chr> \"player_id\", \"session_id\", \"session_start\", \"time\", \"item_type\"‚Ä¶ #> $ info   <chr> \"A `character` column with unique identifiers for each user/pla‚Ä¶"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtenga un informe resumido de una agent ‚Äî get_agent_report","title":"Obtenga un informe resumido de una agent ‚Äî get_agent_report","text":"can get informative summary table agent using get_agent_report() function. table can provided two substantially different forms: gt based display table (default), , tibble. amount fields intel different depending whether agent performed interrogation (interrogate() function). Basically, interrogate() called, agent contain just validation plan (however many rows depends many validation functions supplied part plan). Post-interrogation, information passing failing test units provided, along indicators whether certain failure states entered (provided set actions). display table variant agent report, default form, following columns: (unlabeled): validation step number STEP: name validation function used validation step COLUMNS: names target columns used validation step (applicable) VALUES: values used validation step, applicable; literal values, column names, expression, set sub-validations (conjointly() validation step), etc. TBL: indicates whether preconditions apply interrogation; , script '' stands 'identity' , , right-facing arrow appears EVAL: character value denotes result validation step functions' evaluation interrogation N: total number test units validation step PASS: number test units received pass FAIL: fraction test units received pass W, S, N: indicators show whether warn, stop, notify states entered; unset states appear dashes, states set thresholds appear unfilled circles entered filled thresholds exceeded (colors W, S, N amber, red, blue) EXT: column provides buttons data extracts validation step failed rows available (CSV files) small version display table (obtained using size = \"small\") omits COLUMNS, TBL, EXT columns. width small table 575px; standard table 875px wide. choosing get tibble (display_table = FALSE), following columns: : validation step number type: name validation function used validation step columns: names target columns used validation step (applicable) values: values used validation step, applicable; conjointly() validation step, listing sub-validations precon: indicates whether preconditions apply interrogation , , number statements used active: logical value indicates whether validation step set \"active\" interrogation eval: character value denotes result validation step functions' evaluation interrogation units: total number test units validation step n_pass: number test units received pass f_pass: fraction test units received pass W, S, N: logical value stating whether warn, stop, notify states entered extract: logical value indicates whether data extract available validation step","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtenga un informe resumido de una agent ‚Äî get_agent_report","text":"","code":"get_agent_report(   agent,   arrange_by = c(\"i\", \"severity\"),   keep = c(\"all\", \"fail_states\"),   display_table = TRUE,   size = \"standard\",   title = \":default:\",   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtenga un informe resumido de una agent ‚Äî get_agent_report","text":"agent Un objeto de agente de clase ptblank_agent. arrange_by choice arrange report table rows validation step number (\"\", default), , arrange descending order severity failure state (\"severity\"). keep option keep \"\" report's table rows (default), , keep rows reflect one \"fail_states\". display_table display table generated? TRUE (default), gt package installed, display table report shown Viewer. FALSE, gt available, tibble returned. size size display table, can either \"standard\" (default) \"small\". applies display table (display_table = TRUE). title Options customizing title report. default keyword \":default:\" produces generic title text refers pointblank package language governed lang option. Another keyword option \":tbl_name:\", presents name table title report. title wanted, \":none:\" keyword option can used. Aside keyword options, text can provided title glue::glue() calls can used construct text string. providing text, interpreted Markdown text transformed internally HTML. circumvent transformation, use text () explicitly state supplied text transformed. lang language use automatic creation briefs (short descriptions validation step) agent report (summary table provides validation plan results interrogation. De forma predeterminada, NULL crear√° texto en ingl√©s (\"en\"). Otras opciones incluyen franc√©s (\"fr\"), alem√°n (\"de\"), italiano (\"\"), espa√±ol (\"es\"), portugu√©s (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), dan√©s (\"da\"), sueco (\"sv\" ) y holand√©s (\"nl\"). lang option override previously set language setting (e.g., create_agent() call). locale optional locale ID use formatting values agent report summary table according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). locale option override previously set locale value (e.g., create_agent() call).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtenga un informe resumido de una agent ‚Äî get_agent_report","text":"gt table object display_table = TRUE tibble display_table = FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtenga un informe resumido de una agent ‚Äî get_agent_report","text":"6-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtenga un informe resumido de una agent ‚Äî get_agent_report","text":"","code":"# Create a simple table with a # column of numerical values tbl <-    dplyr::tibble(a = c(5, 7, 8, 5))  # Validate that values in column # `a` are always greater than 4 agent <-   create_agent(tbl = tbl) %>%   col_vals_gt(vars(a), value = 4) %>%   interrogate()  # Get a tibble-based report from the # agent by using `get_agent_report()` # with `display_table = FALSE` agent %>%   get_agent_report(display_table = FALSE) #> # A tibble: 1 √ó 14 #>       i type  columns values precon active eval  units n_pass f_pass W     S     #>   <int> <chr> <chr>   <chr>  <chr>  <lgl>  <chr> <dbl>  <dbl>  <dbl> <lgl> <lgl> #> 1     1 col_‚Ä¶ a       4      NA     TRUE   OK        4      4      1 NA    NA    #> # ‚Ä¶ with 2 more variables: N <lgl>, extract <int>    # View a the report by printing the # `agent` object anytime, but, return a # gt table object by using this with # `display_table = TRUE` (the default) report <- get_agent_report(agent) class(report) #> [1] \"ptblank_agent_report\" \"gt_tbl\"               \"list\"                  # What can you do with the report? # Print it from an R Markdown code, # use it in an email, put it in a # webpage, or further modify it with # the **gt** package  # The agent report as a **gt** display # table comes in two sizes: \"standard\" # (the default) and \"small\" small_report <-    get_agent_report(     agent = agent,     size = \"small\"   )  class(small_report) #> [1] \"ptblank_agent_report\" \"gt_tbl\"               \"list\"                  # The standard report is 875px wide # the small one is 575px wide"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_x_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtenga la x-list del agente ‚Äî get_agent_x_list","title":"Obtenga la x-list del agente ‚Äî get_agent_x_list","text":"agent's x-list record information agent possesses given time. x-list contain complete information interrogation taken place (, data largely reflects validation plan). x-list can constrained particular validation step (supplying step number argument), , can get information validation steps leaving unspecified. x-list indeed R list object contains veritable cornucopia information. x-list obtained specified validation step, following components available: time_start: time interrogation began (POSIXct [0 1]) time_end: time interrogation ended (POSIXct [0 1]) label: optional label given agent (chr [1]) tbl_name: name table object, available (chr [1]) tbl_src: type table used validation (chr [1]) tbl_src_details: table database table, provides details DB table (chr [1]) tbl: table object col_names: table's column names (chr [ncol(tbl)]) col_types: table's column types (chr [ncol(tbl)]) : validation step index (int [1]) type: type validation, value validation function name (chr [1]) columns: columns specified validation function (chr [variable length]) values: values specified validation function (mixed types [variable length]) briefs: brief validation step specified lang (chr [1]) eval_error, eval_warning: indicates whether evaluation step function, interrogation, resulted error warning (lgl [1]) capture_stack: list captured errors warnings step-function evaluation interrogation time (list [1]) n: number test units validation step (num [1]) n_passed, n_failed: number passing failing test units validation step (num [1]) f_passed: fraction passing test units validation step, n_passed / n (num [1]) f_failed: fraction failing test units validation step, n_failed / n (num [1]) warn, stop, notify: logical value indicating whether level failing test units caused corresponding conditions entered (lgl [1]) lang: two-letter language code indicates language used briefs, agent report, reporting generated scan_data() function (chr [1]) unspecified (.e., constrained specific validation step) certain length-one components x-list expanded total number validation steps (: , type, columns, values, briefs, eval_error, eval_warning, capture_stack, n, n_passed, n_failed, f_passed, f_failed, warn, stop, notify). x-list also additional components NULL, : report_object: gt table object, also presented default print method ptblank_agent email_object: blastula email_message object default set components report_html: HTML source report_object, provided length-one character vector report_html_small: HTML source narrower, condensed version report_object, provided length-one character vector; HTML inlined styles, making suitable email message bodies","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_x_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtenga la x-list del agente ‚Äî get_agent_x_list","text":"","code":"get_agent_x_list(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_x_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtenga la x-list del agente ‚Äî get_agent_x_list","text":"agent Un objeto de agente de clase ptblank_agent. validation step number, assigned validation step order invocation. NULL (default), x-list provide information validation steps. valid step number provided x-list information pertaining step.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_x_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtenga la x-list del agente ‚Äî get_agent_x_list","text":"Un objeto list.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_x_list.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtenga la x-list del agente ‚Äî get_agent_x_list","text":"8-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_agent_x_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtenga la x-list del agente ‚Äî get_agent_x_list","text":"","code":"# Create a simple data frame with # a column of numerical values tbl <- dplyr::tibble(a = c(5, 7, 8, 5))  # Create an `action_levels()` list # with fractional values for the # `warn`, `stop`, and `notify` states al <-   action_levels(     warn_at = 0.2,     stop_at = 0.8,     notify_at = 0.345   )  # Create an agent (giving it the # `tbl` and the `al` objects), # supply two validation step # functions, then interrogate agent <-   create_agent(     tbl = tbl,     actions = al   ) %>%   col_vals_gt(vars(a), value = 7) %>%   col_is_numeric(vars(a)) %>%   interrogate()    # Get the agent x-list x <- get_agent_x_list(agent)  # Print the x-list object `x` x #> ‚îÄ‚îÄ The x-list for `tbl` ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ALL STEPS ‚îÄ‚îÄ #> $time_start $time_end (POSIXct [1]) #> $label $tbl_name $tbl_src $tbl_src_details (chr [1]) #> $tbl (tbl_df, tbl, and data.frame) #> $col_names $col_types (chr [1]) #> $i $type $columns $values $label $briefs (mixed [2]) #> $eval_error $eval_warning (lgl [2]) #> $capture_stack (list [2]) #> $n $n_passed $n_failed $f_passed $f_failed (num [2]) #> $warn $stop $notify (lgl [2]) #> $validation_set (tbl_df [2, 35]) #> $lang (chr [1]) #> $report_object (gt_tbl) #> $email_object (blastula_message) #> $report_html $report_html_small (chr [1]) #> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # Get the `f_passed` component # of the x-list x$f_passed #> [1] 0.25 1.00"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_data_extracts.html","id":null,"dir":"Reference","previous_headings":"","what":"Recopile extractos de datos de un paso de validaci√≥n ‚Äî get_data_extracts","title":"Recopile extractos de datos de un paso de validaci√≥n ‚Äî get_data_extracts","text":"agent-based workflow (.e., initiating create_agent()), interrogation interrogate(), can extract row data pass row-based validation steps get_data_extracts() function. one discrete extract per row-based validation step amount data available particular extract depends fraction test units pass validation step level sampling explicit collection set units. extracts can collected programmatically get_data_extracts() may also downloaded CSV files HTML report generated agent's print method use get_agent_report(). availability data extracts row-based validation step depends whether extract_failed set TRUE within interrogate() call (default). amount fail rows extracted depends collection parameters interrogate(), default behavior collect first 5000 fail rows. Row-based validation steps based validation functions form col_vals_*() also include conjointly() rows_distinct(). functions combined set validation functions can yield data extracts.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_data_extracts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recopile extractos de datos de un paso de validaci√≥n ‚Äî get_data_extracts","text":"","code":"get_data_extracts(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_data_extracts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recopile extractos de datos de un paso de validaci√≥n ‚Äî get_data_extracts","text":"agent Un objeto de agente de clase ptblank_agent. interrogate() called , validation steps carried sample rows non-passing validations potentially available object. validation step number, assigned validation step pointblank order definition. NULL (default), data extract tables provided list object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_data_extracts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recopile extractos de datos de un paso de validaci√≥n ‚Äî get_data_extracts","text":"list tables provided, , standalone table given.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_data_extracts.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Recopile extractos de datos de un paso de validaci√≥n ‚Äî get_data_extracts","text":"8-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_data_extracts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recopile extractos de datos de un paso de validaci√≥n ‚Äî get_data_extracts","text":"","code":"# Create a series of two validation # steps focused on testing row values # for part of the `small_table` object; # `interrogate()` immediately agent <-   create_agent(     read_fn = ~ small_table %>%       dplyr::select(a:f),     label = \"`get_data_extracts()`\"   ) %>%   col_vals_gt(vars(d), value = 1000) %>%   col_vals_between(     vars(c),     left = vars(a), right = vars(d),     na_pass = TRUE   ) %>%   interrogate()  # Using `get_data_extracts()` with its # defaults returns of a list of tables, # where each table is named after the # validation step that has an extract # available agent %>% get_data_extracts() #> $`1` #> # A tibble: 6 √ó 6 #>       a b             c     d e     f     #>   <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1     8 3-ldm-038     7  284. TRUE  low   #> 2     7 1-knw-093     3  843. TRUE  high  #> 3     3 5-bce-642     9  838. FALSE high  #> 4     3 5-bce-642     9  838. FALSE high  #> 5     4 2-dmx-010     7  834. TRUE  low   #> 6     2 7-dmx-010     8  108. FALSE low   #>  #> $`2` #> # A tibble: 4 √ó 6 #>       a b             c     d e     f     #>   <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1     6 8-kdg-938     3 2343. TRUE  high  #> 2     8 3-ldm-038     7  284. TRUE  low   #> 3     7 1-knw-093     3  843. TRUE  high  #> 4     4 5-boe-639     2 1036. FALSE low   #>   # We can get an extract for a specific # step by specifying it in the `i` # argument; let's get the failing rows # from the first validation step # (`col_vals_gt`) agent %>% get_data_extracts(i = 1) #> # A tibble: 6 √ó 6 #>       a b             c     d e     f     #>   <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1     8 3-ldm-038     7  284. TRUE  low   #> 2     7 1-knw-093     3  843. TRUE  high  #> 3     3 5-bce-642     9  838. FALSE high  #> 4     3 5-bce-642     9  838. FALSE high  #> 5     4 2-dmx-010     7  834. TRUE  low   #> 6     2 7-dmx-010     8  108. FALSE low"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_informant_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtener un informe de informaci√≥n de la tabla de un objeto informant ‚Äî get_informant_report","title":"Obtener un informe de informaci√≥n de la tabla de un objeto informant ‚Äî get_informant_report","text":"can get table information report informant object generated create_informant() function. report provided gt based display table. amount information shown depends extent added via use info_*() functions direct editing pointblank YAML file (informant can written pointblank YAML yaml_write(informant = <informant>, ...)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_informant_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtener un informe de informaci√≥n de la tabla de un objeto informant ‚Äî get_informant_report","text":"","code":"get_informant_report(   informant,   size = \"standard\",   title = \":default:\",   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_informant_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtener un informe de informaci√≥n de la tabla de un objeto informant ‚Äî get_informant_report","text":"informant informant object class ptblank_informant. size size display table, can either \"standard\" (default, width 875px) \"small\" (width 575px). title Options customizing title report. default keyword \":default:\" produces generic title text refers pointblank package language governed lang option. Another keyword option \":tbl_name:\", presents name table title report. title wanted, \":none:\" keyword option can used. Aside keyword options, text can provided title glue::glue() calls can used construct text string. providing text, interpreted Markdown text transformed internally HTML. circumvent transformation, use text () explicitly state supplied text transformed. lang language use information report (summary table provides validation plan results interrogation. De forma predeterminada, NULL crear√° texto en ingl√©s (\"en\"). Otras opciones incluyen franc√©s (\"fr\"), alem√°n (\"de\"), italiano (\"\"), espa√±ol (\"es\"), portugu√©s (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), dan√©s (\"da\"), sueco (\"sv\" ) y holand√©s (\"nl\"). lang option override previously set language setting (e.g., create_agent() call). locale optional locale ID use formatting values information report summary table according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). locale option override previously set locale value (e.g., create_agent() call).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_informant_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtener un informe de informaci√≥n de la tabla de un objeto informant ‚Äî get_informant_report","text":"gt table object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_informant_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtener un informe de informaci√≥n de la tabla de un objeto informant ‚Äî get_informant_report","text":"7-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_informant_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtener un informe de informaci√≥n de la tabla de un objeto informant ‚Äî get_informant_report","text":"","code":"# Generate an informant object using # the `small_table` dataset informant <- create_informant(small_table)  # This function creates some information # without any extra help by profiling # the supplied table object; it adds # the sections 'table' and columns' and # we can print the object to see the # table information report  # Alternatively, we can get the same report # by using `get_informant_report()` report <- get_informant_report(informant) class(report) #> [1] \"ptblank_informant_report\" \"gt_tbl\"                   #> [3] \"list\""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtenga un informe resumido utilizando varios agentes ‚Äî get_multiagent_report","title":"Obtenga un informe resumido utilizando varios agentes ‚Äî get_multiagent_report","text":"can get informative summary table collective agents using get_multiagent_report() function. Information multiple agent can provided three forms: (1) Long Display (stacked reports), (2) Wide Display (comparison report), (3) tibble packed columns.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtenga un informe resumido utilizando varios agentes ‚Äî get_multiagent_report","text":"","code":"get_multiagent_report(   multiagent,   display_table = TRUE,   display_mode = c(\"long\", \"wide\"),   title = \":default:\",   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtenga un informe resumido utilizando varios agentes ‚Äî get_multiagent_report","text":"multiagent multiagent object class ptblank_multiagent. display_table display table generated? TRUE (default) display table report shown Viewer. FALSE tibble returned. display_mode getting display table, agent data presented \"long\" \"wide\" form? default \"long\" comparing multiple runs target table might preferable choose \"wide\". title Options customizing title report display_table = TRUE. default keyword \":default:\" produces generic title text. title wanted, \":none:\" keyword option can used. Another keyword option \":tbl_name:\", presents name table title report (can used display_mode = \"long\"). Aside keyword options, text can provided title glue::glue() calls can used construct text string. providing text, interpreted Markdown text transformed internally HTML. circumvent transformation, use text () explicitly state supplied text transformed. lang language use long wide report forms. De forma predeterminada, NULL crear√° texto en ingl√©s (\"en\"). Otras opciones incluyen franc√©s (\"fr\"), alem√°n (\"de\"), italiano (\"\"), espa√±ol (\"es\"), portugu√©s (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), dan√©s (\"da\"), sueco (\"sv\" ) y holand√©s (\"nl\"). locale optional locale ID use formatting values long wide report forms (according locale's rules). Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). locale option override previously set locale values.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtenga un informe resumido utilizando varios agentes ‚Äî get_multiagent_report","text":"gt table object display_table = TRUE tibble display_table = FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"the-long-display","dir":"Reference","previous_headings":"","what":"The Long Display","title":"Obtenga un informe resumido utilizando varios agentes ‚Äî get_multiagent_report","text":"displayed \"long\" multiagent report stack individual agent reports single document order agents multiagent object. validation plan (possibly interrogation info) provided output equivalent calling get_agent_report() agents within multiagent object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"the-wide-display","dir":"Reference","previous_headings":"","what":"The Wide Display","title":"Obtenga un informe resumido utilizando varios agentes ‚Äî get_multiagent_report","text":"displayed \"wide\" multiagent report show data individual agents columns, rows standing validation steps common across agents. validation step represented icon (standing name validation function) associated SHA1 hash. highly trustworthy way ascertaining validation steps effectively identical across interrogations. way organizing report beneficial different agents may used different steps want track validation results validation step change target table (.e., new rows added, existing rows updated, etc.). single table display mode following columns: STEP: SHA1 hash validation step, possibly shared among several interrogations. subsequent columns: column beyond STEP represents separate interrogation agent object. time stamp completion interrogation shown column label.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtenga un informe resumido utilizando varios agentes ‚Äî get_multiagent_report","text":"10-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_multiagent_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtenga un informe resumido utilizando varios agentes ‚Äî get_multiagent_report","text":"","code":"if (interactive()) {  # Let's walk through several theoretical # data quality analyses of an extremely # small table; that table is called # `small_table` and we can find it as a # dataset in this package small_table  # To set failure limits and signal # conditions, we designate proportional # failure thresholds to the `warn`, `stop`, # and `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.05,     stop_at = 0.10,     notify_at = 0.20   )  # We will create four different agents # and have slightly different validation # steps in each of them; in the first, # `agent_1`, eight different validation # steps are created and the agent will # interrogate the `small_table` agent_1 <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`get_multiagent_report()`\",     actions = al   ) %>%   col_vals_gt(     vars(date_time),     value = vars(date),     na_pass = TRUE   ) %>%   col_vals_gt(     vars(b),      value = vars(g),     na_pass = TRUE   ) %>%   rows_distinct() %>%   col_vals_equal(     vars(d),      value = vars(d),     na_pass = TRUE   ) %>%   col_vals_between(     vars(c),      left = vars(a), right = vars(d)   ) %>%   col_vals_not_between(     vars(c),     left = 10, right = 20,     na_pass = TRUE   ) %>%   rows_distinct(vars(d, e, f)) %>%   col_is_integer(vars(a)) %>%   interrogate()  # The second agent, `agent_2`, retains # all of the steps of `agent_1` and adds # two more (the last of which is inactive) agent_2 <-    agent_1 %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),      regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     active = FALSE   ) %>%   interrogate()  # The third agent, `agent_3`, adds a single # validation step, removes the fifth one, # and deactivates the first agent_3 <-    agent_2 %>%   col_vals_in_set(     vars(f),     set = c(\"low\", \"mid\", \"high\")   ) %>%   remove_steps(i = 5) %>%   deactivate_steps(i = 1) %>%   interrogate()  # The fourth and final agent, `agent_4`, # reactivates steps 1 and 10, and removes # the sixth step agent_4 <-   agent_3 %>%   activate_steps(i = 1) %>%   activate_steps(i = 10) %>%   remove_steps(i = 6) %>%   interrogate()  # While all the agents are slightly # different from each other, we can still # get a combined report of them by # creating a 'multiagent' multiagent <-   create_multiagent(     agent_1, agent_2, agent_3, agent_4   )  # Calling `multiagent` in the console # prints the multiagent report; but we # can use some non-default option with # the `get_multiagent_report()` function  # By default, `get_multiagent_report()` # gives you a tall report with agent # reports being stacked report_1 <-    get_multiagent_report(multiagent)    # We can modify the title with that's # more suitable or use a keyword like # `:tbl_name:` to give us the target # table name in each section report_2 <-    get_multiagent_report(     multiagent,     title = \":tbl_name:\"   )  # We can opt for a wide display of # the reporting info, and this is # great when reporting on multiple # validations of the same target # table report_3 <-    get_multiagent_report(     multiagent,     display_mode = \"wide\"   ) }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Divida los datos, dividi√©ndolos en partes de 'pasa' y 'falla' ‚Äî get_sundered_data","title":"Divida los datos, dividi√©ndolos en partes de 'pasa' y 'falla' ‚Äî get_sundered_data","text":"Validation data one thing , sometimes, want use best part input dataset something else. get_sundered_data() function works agent object intel (.e., post interrogate()) gets either 'pass' data piece (rows failing test units across row-based validation functions), , 'fail' data piece (rows least one failing test unit across series validations). final option, can emit data new column (called .pb_combined) labels row passing failing across validation steps. labels \"pass\" \"fail\" default values can easily customized.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Divida los datos, dividi√©ndolos en partes de 'pasa' y 'falla' ‚Äî get_sundered_data","text":"","code":"get_sundered_data(   agent,   type = c(\"pass\", \"fail\", \"combined\"),   pass_fail = c(\"pass\", \"fail\"),   id_cols = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Divida los datos, dividi√©ndolos en partes de 'pasa' y 'falla' ‚Äî get_sundered_data","text":"agent Un objeto de agente de clase ptblank_agent. interrogate() called , validation steps actually carried . type desired piece data resulting splitting. Options returning single table \"pass\" (default) \"fail\". options return single table , \"pass\" case, rows passed across validation steps (.e., failing test units part row validation step), , complementary set rows \"fail\" case. Providing NULL returns split data tables list (names \"pass\" \"fail\"). option \"combined\" applies categorical (pass/fail) label (settable pass_fail argument) new .pb_combined flag column. case ordering rows fully retained input table. pass_fail vector encoding flag column 'pass' 'fail' values type = \"combined\". default c(\"pass\", \"fail\") options c(TRUE, FALSE), c(1, 0), c(1L, 0L). id_cols optional specification one identifying columns. taken together, can count single column grouping columns distinguish rows. table undergoing validation data frame tibble, columns need specified id_cols.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Divida los datos, dividi√©ndolos en partes de 'pasa' y 'falla' ‚Äî get_sundered_data","text":"list table objects type NULL, , single table type given.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Divida los datos, dividi√©ndolos en partes de 'pasa' y 'falla' ‚Äî get_sundered_data","text":"caveats sundering. validation steps considered splitting row-based variety (e.g., col_vals_*() functions conjointly(), rows_distinct()). Furthermore, validation steps experienced evaluation issues interrogation considered, , validation steps active = FALSE disregarded. collection validation steps fulfill requirements sundering termed -consideration validation steps. using preconditions validation steps, must ensure -consideration validation steps use specified preconditions function. Put another way, split target table using collection -consideration validation steps use different forms input table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Divida los datos, dividi√©ndolos en partes de 'pasa' y 'falla' ‚Äî get_sundered_data","text":"8-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_sundered_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Divida los datos, dividi√©ndolos en partes de 'pasa' y 'falla' ‚Äî get_sundered_data","text":"","code":"# Create a series of two validation # steps focused on testing row values # for part of the `small_table` object; # `interrogate()` immediately agent <-   create_agent(     read_fn = ~ small_table %>%       dplyr::select(a:f),     label = \"`get_sundered_data()`\"   ) %>%   col_vals_gt(vars(d), value = 1000) %>%   col_vals_between(     vars(c),     left = vars(a), right = vars(d),     na_pass = TRUE   ) %>%   interrogate()  # Get the sundered data piece that # contains only rows that passed both # validation steps (the default piece); # this yields 5 of 13 total rows agent %>% get_sundered_data() #> # A tibble: 5 √ó 6 #>       a b             c      d e     f     #>   <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1     2 1-bcd-345     3  3423. TRUE  high  #> 2     3 5-egh-163     8 10000. TRUE  low   #> 3     2 5-jdo-903    NA  3892. FALSE mid   #> 4     4 2-dhe-923     4  3291. TRUE  mid   #> 5     1 3-dka-303    NA  2230. TRUE  high   # Get the complementary data piece: # all of those rows that failed either # of the two validation steps; # this yields 8 of 13 total rows agent %>%   get_sundered_data(type = \"fail\") #> # A tibble: 8 √ó 6 #>       a b             c     d e     f     #>   <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1     6 8-kdg-938     3 2343. TRUE  high  #> 2     8 3-ldm-038     7  284. TRUE  low   #> 3     7 1-knw-093     3  843. TRUE  high  #> 4     4 5-boe-639     2 1036. FALSE low   #> 5     3 5-bce-642     9  838. FALSE high  #> 6     3 5-bce-642     9  838. FALSE high  #> 7     4 2-dmx-010     7  834. TRUE  low   #> 8     2 7-dmx-010     8  108. FALSE low      # We can get all of the input data # returned with a flag column (called # `.pb_combined`); this is done by # using `type = \"combined\"` and that # rightmost column will contain `\"pass\"` # and `\"fail\"` values agent %>%   get_sundered_data(type = \"combined\") #> # A tibble: 13 √ó 7 #>        a b             c      d e     f     .pb_combined #>    <int> <chr>     <dbl>  <dbl> <lgl> <chr> <chr>        #>  1     2 1-bcd-345     3  3423. TRUE  high  pass         #>  2     3 5-egh-163     8 10000. TRUE  low   pass         #>  3     6 8-kdg-938     3  2343. TRUE  high  fail         #>  4     2 5-jdo-903    NA  3892. FALSE mid   pass         #>  5     8 3-ldm-038     7   284. TRUE  low   fail         #>  6     4 2-dhe-923     4  3291. TRUE  mid   pass         #>  7     7 1-knw-093     3   843. TRUE  high  fail         #>  8     4 5-boe-639     2  1036. FALSE low   fail         #>  9     3 5-bce-642     9   838. FALSE high  fail         #> 10     3 5-bce-642     9   838. FALSE high  fail         #> 11     4 2-dmx-010     7   834. TRUE  low   fail         #> 12     2 7-dmx-010     8   108. FALSE low   fail         #> 13     1 3-dka-303    NA  2230. TRUE  high  pass          # We can change the `\"pass\"` or `\"fail\"` # text values to another type of coding # with the `pass_fail` argument; one # possibility is TRUE/FALSE agent %>%   get_sundered_data(     type = \"combined\",     pass_fail = c(TRUE, FALSE)   ) #> # A tibble: 13 √ó 7 #>        a b             c      d e     f     .pb_combined #>    <int> <chr>     <dbl>  <dbl> <lgl> <chr> <lgl>        #>  1     2 1-bcd-345     3  3423. TRUE  high  TRUE         #>  2     3 5-egh-163     8 10000. TRUE  low   TRUE         #>  3     6 8-kdg-938     3  2343. TRUE  high  FALSE        #>  4     2 5-jdo-903    NA  3892. FALSE mid   TRUE         #>  5     8 3-ldm-038     7   284. TRUE  low   FALSE        #>  6     4 2-dhe-923     4  3291. TRUE  mid   TRUE         #>  7     7 1-knw-093     3   843. TRUE  high  FALSE        #>  8     4 5-boe-639     2  1036. FALSE low   FALSE        #>  9     3 5-bce-642     9   838. FALSE high  FALSE        #> 10     3 5-bce-642     9   838. FALSE high  FALSE        #> 11     4 2-dmx-010     7   834. TRUE  low   FALSE        #> 12     2 7-dmx-010     8   108. FALSE low   FALSE        #> 13     1 3-dka-303    NA  2230. TRUE  high  TRUE          # ...and using `0` and `1` might be # worthwhile in some situations agent %>%   get_sundered_data(     type = \"combined\",     pass_fail = 0:1   ) #> # A tibble: 13 √ó 7 #>        a b             c      d e     f     .pb_combined #>    <int> <chr>     <dbl>  <dbl> <lgl> <chr>        <int> #>  1     2 1-bcd-345     3  3423. TRUE  high             0 #>  2     3 5-egh-163     8 10000. TRUE  low              0 #>  3     6 8-kdg-938     3  2343. TRUE  high             1 #>  4     2 5-jdo-903    NA  3892. FALSE mid              0 #>  5     8 3-ldm-038     7   284. TRUE  low              1 #>  6     4 2-dhe-923     4  3291. TRUE  mid              0 #>  7     7 1-knw-093     3   843. TRUE  high             1 #>  8     4 5-boe-639     2  1036. FALSE low              1 #>  9     3 5-bce-642     9   838. FALSE high             1 #> 10     3 5-bce-642     9   838. FALSE high             1 #> 11     4 2-dmx-010     7   834. TRUE  low              1 #> 12     2 7-dmx-010     8   108. FALSE low              1 #> 13     1 3-dka-303    NA  2230. TRUE  high             0"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_tt_param.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtener un valor de par√°metro de una tabla de resumen ‚Äî get_tt_param","title":"Obtener un valor de par√°metro de una tabla de resumen ‚Äî get_tt_param","text":"get_tt_param() function can help obtain single parameter value summary table generated tt_*() functions tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_tbl_colnames(). following parameters used depending input tbl: tt_summary_stats(): \"min\", \"p05\", \"q_1\", \"med\", \"q_3\", \"p95\", \"max\", \"iqr\", \"range\" tt_string_info(): \"length_mean\", \"length_min\", \"length_max\" tt_tbl_dims(): \"rows\", \"columns\" tt_tbl_colnames(): integer present .param. column tt_summary_stats() tt_string_info() functions generate summary tables columns mirror numeric character columns input tables, respectively. reason, column name must supplied column argument get_tt_param().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_tt_param.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtener un valor de par√°metro de una tabla de resumen ‚Äî get_tt_param","text":"","code":"get_tt_param(tbl, param, column = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_tt_param.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtener un valor de par√°metro de una tabla de resumen ‚Äî get_tt_param","text":"tbl summary table generated either tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_tbl_colnames() functions. param parameter name associated value gotten. parameter names always available first column (.param.) summary table obtained tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_tbl_colnames(). column column summary table data value obtained. must supplied summary tables generated tt_summary_stats() tt_string_info() (tt_tbl_dims() tt_tbl_colnames() functions always generate two-column summary table).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_tt_param.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtener un valor de par√°metro de una tabla de resumen ‚Äî get_tt_param","text":"12-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/get_tt_param.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtener un valor de par√°metro de una tabla de resumen ‚Äî get_tt_param","text":"","code":"# Get summary statistics for the # first quarter of the `game_revenue` # dataset that's included in the package stat_tbl <-    game_revenue %>%   tt_time_slice(slice_point = 0.25) %>%   tt_summary_stats()  # Based on player behavior for the first # quarter of the year, test whether the # maximum session duration during the # rest of the year is never higher game_revenue %>%   tt_time_slice(     slice_point = 0.25,     keep = \"right\"   ) %>%   test_col_vals_lte(     columns = vars(session_duration),      value = get_tt_param(       tbl = stat_tbl,       param = \"max\",       column = \"session_duration\"     )   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/has_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Determinar si existen una o m√°s columnas en una tabla ‚Äî has_columns","title":"Determinar si existen una o m√°s columnas en una tabla ‚Äî has_columns","text":"utility function can help easily determine whether column specified name present table object. function works well enough table object can also used part formula validation function's active argument. Using active = ~ . %>% has_columns(\"column_1\") means validation step inactive target table contain column named column_1. can also use multiple columns vars() active = ~ . %>% has_columns(vars(column_1, column_2)) validation step make inactive interrogate() time unless columns column_1 column_2 present.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/has_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determinar si existen una o m√°s columnas en una tabla ‚Äî has_columns","text":"","code":"has_columns(x, columns)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/has_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determinar si existen una o m√°s columnas en una tabla ‚Äî has_columns","text":"x table object. columns One column names checked existence table x.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/has_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determinar si existen una o m√°s columnas en una tabla ‚Äî has_columns","text":"length-1 logical vector.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/has_columns.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Determinar si existen una o m√°s columnas en una tabla ‚Äî has_columns","text":"13-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/has_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determinar si existen una o m√°s columnas en una tabla ‚Äî has_columns","text":"","code":"# The `small_table` dataset in the # package has the columns `date_time`, # `date`, and the `a` through `f` # columns small_table #> # A tibble: 13 √ó 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # With `has_columns()` we can check for # column existence by using it directly # with the table; a column name can be # verified as present by using it in # double quotes small_table %>% has_columns(\"date\") #> [1] TRUE  # Multiple column names can be supplied; # this is `TRUE` because both columns are # present in `small_table` small_table %>% has_columns(c(\"a\", \"b\")) #> [1] TRUE  # It's possible to supply column names # in `vars()` as well small_table %>% has_columns(vars(a, b)) #> [1] TRUE  # Because column `h` isn't present, this # returns `FALSE` (all specified columns # need to be present to obtain `TRUE`) small_table %>% has_columns(vars(a, h)) #> [1] FALSE  # The `has_columns()` function can be # useful in expressions that involve the # target table, especially if it is # uncertain that the table will contain # a column that's involved in a validation  # In the following agent-based validation, # the first two steps will be 'active' # because all columns checked for in the # expressions are present; the third step # is inactive because column `j` isn't # there (without the `active` statement we # would get an evaluation failure in the # agent report) agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\"   ) %>%   col_vals_gt(     vars(c), value = vars(a),     active = ~ . %>% has_columns(vars(a, c))   ) %>%   col_vals_lt(     vars(h), value = vars(d),     preconditions = ~ . %>% dplyr::mutate(h = d - a),     active = ~ . %>% has_columns(vars(a, d))   ) %>%   col_is_character(     vars(j),     active = ~ . %>% has_columns(\"j\")   ) %>%   interrogate()  #> ‚Ñπ Step 3 is not set as active. Skipping."},{"path":"https://rich-iannone.github.io/pointblank/es/reference/incorporate.html","id":null,"dir":"Reference","previous_headings":"","what":"Dado un objeto informant, actualice e incorpore fragmentos de tabla ‚Äî incorporate","title":"Dado un objeto informant, actualice e incorpore fragmentos de tabla ‚Äî incorporate","text":"informant object number snippets available (using info_snippet()) strings use (using info_*() functions {<snippet_name>} text elements), process incorporating aspects table info text can occur using incorporate() function. , information fully updated (getting current state table dimensions, re-rendering info text, etc.) can print informant object use get_informant_report() function see information report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/incorporate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dado un objeto informant, actualice e incorpore fragmentos de tabla ‚Äî incorporate","text":"","code":"incorporate(informant)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/incorporate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dado un objeto informant, actualice e incorpore fragmentos de tabla ‚Äî incorporate","text":"informant informant object class ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/incorporate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dado un objeto informant, actualice e incorpore fragmentos de tabla ‚Äî incorporate","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/incorporate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Dado un objeto informant, actualice e incorpore fragmentos de tabla ‚Äî incorporate","text":"7-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/incorporate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dado un objeto informant, actualice e incorpore fragmentos de tabla ‚Äî incorporate","text":"","code":"if (interactive()) {  # Take the `small_table` and # assign it to `test_table`; we'll # modify it later test_table <- small_table  # Generate an informant object, add # two snippets with `info_snippet()`, # add information with some other # `info_*()` functions and then # `incorporate()` the snippets into # the info text informant <-    create_informant(     read_fn = ~ test_table,     tbl_name = \"test_table\"   ) %>%   info_snippet(     snippet_name = \"row_count\",     fn = ~ . %>% nrow()   ) %>%   info_snippet(     snippet_name = \"col_count\",     fn = ~ . %>% ncol()   ) %>%   info_columns(     columns = vars(a),     info = \"In the range of 1 to 10. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`. (CALC)\"   ) %>%   info_section(     section_name = \"rows\",     row_count = \"There are {row_count} rows available.\"   ) %>%   incorporate()  # We can print the `informant` object # to see the information report  # Let's modify `test_table` to give # it more rows and an extra column test_table <-    dplyr::bind_rows(test_table, test_table) %>%   dplyr::mutate(h = a + c)  # Using `incorporate()` will cause # the snippets to be reprocessed, and, # the strings to be updated informant <-   informant %>% incorporate()    # When printed again, we'll see that the # row and column counts in the header # have been updated to reflect the # changed `test_table`  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Agregar informaci√≥n que se centre en aspectos de las columnas de una tabla de\ndatos ‚Äî info_columns","title":"Agregar informaci√≥n que se centre en aspectos de las columnas de una tabla de\ndatos ‚Äî info_columns","text":"Upon creation informant object (create_informant() function), two sections containing properties: (1) 'table' (2) 'columns'. 'columns' section initialized table's column names types (_type). Beyond , useful provide details nature column can info_columns() function. single column (multiple columns) targeted, series named arguments (form entry_name = \"*info text*.\") serves additional information column columns.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Agregar informaci√≥n que se centre en aspectos de las columnas de una tabla de\ndatos ‚Äî info_columns","text":"","code":"info_columns(x, columns, ..., .add = TRUE)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Agregar informaci√≥n que se centre en aspectos de las columnas de una tabla de\ndatos ‚Äî info_columns","text":"x informant object class ptblank_informant. columns column set columns focus . Can defined column name quotes (e.g., \"<column_name>\"), one column names vars() (e.g., vars(<column_name>)), select helper (e.g., starts_with(\"date\")). ... Information entries series named arguments. names refer subsection titles within COLUMN -> <COLUMN_NAME> RHS contains info text (informational text can written Markdown styled Text Tricks). .add new text added existing text? TRUE default; setting FALSE replaces existing text property.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Agregar informaci√≥n que se centre en aspectos de las columnas de una tabla de\ndatos ‚Äî info_columns","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"info-text","dir":"Reference","previous_headings":"","what":"Info Text","title":"Agregar informaci√≥n que se centre en aspectos de las columnas de una tabla de\ndatos ‚Äî info_columns","text":"info text used info_*() functions readily accepts Markdown formatting, , Text Tricks can used spice presentation. Markdown links written < link url > [ link text ]( link url ) get nicely-styled links. dates expressed ISO-8601 standard parentheses, \"(2004-12-01)\", styled font variation (monospaced) underlined purple. Spans text can converted label-style text using: (1) double parentheses around text rectangular border ((label text)), (2) triple parentheses around text rounded-rectangular border like (((label text))). CSS style rules can applied spans info text following form: [[ info text ]]<< CSS style rules >> example practice suppose like change color text red make font appear somewhat thinner. variation following might used: \"[[factor]]<<color: red; font-weight: 300;>> value.\" quite CSS style rules can used great effect. might like: color: <color value>; (text color) background-color: <color value>; (text's background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); examples, 'length value' refers CSS length can expressed different units measure (e.g., 12px, 1em, etc.). lengths can expressed positive negative values (e.g., letter-spacing). Color values can expressed ways, common form hexadecimal color values CSS color names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Agregar informaci√≥n que se centre en aspectos de las columnas de una tabla de\ndatos ‚Äî info_columns","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). way information table columns represented YAML works like : info text goes subsections YAML keys named columns, part top-level columns key. example several calls info_columns() expressed R code result corresponds YAML representation. Subsections represented column names automatically generated creating informant. Within , can multiple subsections used holding info text column. subsections used across different columns needn't either, commonality enforced presence _type key (automatically updated every incorporate() invocation). safest use single quotation marks around info text directly editing YAML file. Note Markdown formatting info snippet placeholders (shown {snippet_1}, see info_snippet() information) preserved YAML. Markdown HTML conversion done printing informant (invoking get_informant_report() informant) processing snippets (generation insertion) done using incorporate() function. Thus, source text always maintained YAML representation never written processed form.","code":"# C√≥digo R informant %>%    info_columns(     columns = \"date_time\",     info = \"*info text* 1.\"   ) %>%   info_columns(     columns = \"date\",     info = \"*info text* 2.\"   ) %>%   info_columns(     columns = \"item_count\",     info = \"*info text* 3. Statistics: {snippet_1}.\"   ) %>%   info_columns(     columns = vars(date, date_time),     info = \"UTC time.\"   )  # Representaci√≥n YAML columns:   date_time:     _type: POSIXct, POSIXt     info: '*info text* 1. UTC time.'   date:     _type: Date     info: '*info text* 2. UTC time.'   item_count:     _type: integer     info: '*info text* 3. Statistics: {snippet_1}.'"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Agregar informaci√≥n que se centre en aspectos de las columnas de una tabla de\ndatos ‚Äî info_columns","text":"3-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Agregar informaci√≥n que se centre en aspectos de las columnas de una tabla de\ndatos ‚Äî info_columns","text":"","code":"# Create a pointblank `informant` # object with `create_informant()`; # we specify a `read_fn` with the # `~` followed by a statement that # gets the `small_table` dataset informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   )  # We can add *info text* to describe # the columns in the table with multiple # `info_columns()` calls; the *info text* # calls are additive to existing content # in subsections informant <-   informant %>%   info_columns(     columns = vars(a),     info = \"In the range of 1 to 10. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`. (CALC)\"   )  # Upon printing the `informant` object, we see # the additions made to the 'Columns' section  if (interactive()) {  # The `informant` object can be written to # a YAML file with the `yaml_write()` # function; then, information can # be directly edited or modified yaml_write(   informant = informant,   filename = \"informant.yml\" )  # The YAML file can then be read back # into an informant object with the # `yaml_read_informant()` function informant <-   yaml_read_informant(     filename = \"informant.yml\"   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns_from_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Agregar informaci√≥n de columna de otra tabla de datos ‚Äî info_columns_from_tbl","title":"Agregar informaci√≥n de columna de otra tabla de datos ‚Äî info_columns_from_tbl","text":"info_columns_from_tbl() function wrapper around info_columns() function useful wish apply info text columns information already exists data frame (form can readily coaxed data frame). form input tbl (one contains column metadata) basic requirements: data frame must two columns columns must class character first column contain column names second contain info text column matches across tables (.e., tbl target table informant) new entry \"info\" property. Empty missing info text pruned tbl.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns_from_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Agregar informaci√≥n de columna de otra tabla de datos ‚Äî info_columns_from_tbl","text":"","code":"info_columns_from_tbl(x, tbl, .add = TRUE)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns_from_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Agregar informaci√≥n de columna de otra tabla de datos ‚Äî info_columns_from_tbl","text":"x informant object class ptblank_informant. tbl two-column data frame contains metadata target table informant object. .add new text added existing text? TRUE default; setting FALSE replaces existing text \"info\" property.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns_from_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Agregar informaci√≥n de columna de otra tabla de datos ‚Äî info_columns_from_tbl","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns_from_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Agregar informaci√≥n de columna de otra tabla de datos ‚Äî info_columns_from_tbl","text":"3-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_columns_from_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Agregar informaci√≥n de columna de otra tabla de datos ‚Äî info_columns_from_tbl","text":"","code":"# Create a pointblank `informant` # object with `create_informant()`; # we specify a `read_fn` with the # `~` followed by a statement that # gets the `game_revenue` dataset informant <-    create_informant(     read_fn = ~ game_revenue,     tbl_name = \"game_revenue\",     label = \"Un ejemplo.\"   )  # We can add *info text* to describe # the columns in the table by using # information in another table; the # `info_columns_from_tbl()` takes a # table object where the first column # has the column names and the second # contains the *info text* (the # `game_revenue_info` dataset contains # metadata for `game_revenue`) informant <-   informant %>%   info_columns_from_tbl(     tbl = game_revenue_info   )  # We can continue to add more *info # text* since the process is additive; # the `info_columns_from_tbl()` # function populates the `info` # subsection informant <-   informant %>%   info_columns(     columns = \"item_revenue\",     info = \"Revenue reported in USD.\"   ) %>%   info_columns(     columns = \"acquisition\",     `top list` = \"{top5_aq}\"   ) %>%   info_snippet(     snippet_name = \"top5_aq\",     fn = snip_list(column = \"acquisition\")   ) %>%   incorporate() #>  #> ‚îÄ‚îÄ Incorporation Started - there is a single snippet to process ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚úî Information gathered. #> ‚úî Snippets processed. #> ‚úî Information built. #>  #> ‚îÄ‚îÄ Incorporation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":null,"dir":"Reference","previous_headings":"","what":"Agregue informaci√≥n que se centre en alg√∫n aspecto clave de la tabla de datos ‚Äî info_section","title":"Agregue informaci√≥n que se centre en alg√∫n aspecto clave de la tabla de datos ‚Äî info_section","text":"info_tabular() info_columns() functions allow us add/modify info text specific sections, info_section() makes possible add sections choosing information make sense sections. Define section_name provide series named arguments (form entry_name = \"*info text*.\") build informational content section.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Agregue informaci√≥n que se centre en alg√∫n aspecto clave de la tabla de datos ‚Äî info_section","text":"","code":"info_section(x, section_name, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Agregue informaci√≥n que se centre en alg√∫n aspecto clave de la tabla de datos ‚Äî info_section","text":"x informant object class ptblank_informant. section_name name section information pertains. ... Information entries series named arguments. names refer subsection titles within section defined section_name RHS info text (informational text can written Markdown styled Text Tricks).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Agregue informaci√≥n que se centre en alg√∫n aspecto clave de la tabla de datos ‚Äî info_section","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"info-text","dir":"Reference","previous_headings":"","what":"Info Text","title":"Agregue informaci√≥n que se centre en alg√∫n aspecto clave de la tabla de datos ‚Äî info_section","text":"info text used info_*() functions readily accepts Markdown formatting, , Text Tricks can used spice presentation. Markdown links written < link url > [ link text ]( link url ) get nicely-styled links. dates expressed ISO-8601 standard parentheses, \"(2004-12-01)\", styled font variation (monospaced) underlined purple. Spans text can converted label-style text using: (1) double parentheses around text rectangular border ((label text)), (2) triple parentheses around text rounded-rectangular border like (((label text))). CSS style rules can applied spans info text following form: [[ info text ]]<< CSS style rules >> example practice suppose like change color text red make font appear somewhat thinner. variation following might used: \"[[factor]]<<color: red; font-weight: 300;>> value.\" quite CSS style rules can used great effect. might like: color: <color value>; (text color) background-color: <color value>; (text's background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); examples, 'length value' refers CSS length can expressed different units measure (e.g., 12px, 1em, etc.). lengths can expressed positive negative values (e.g., letter-spacing). Color values can expressed ways, common form hexadecimal color values CSS color names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Agregue informaci√≥n que se centre en alg√∫n aspecto clave de la tabla de datos ‚Äî info_section","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). Extra sections (.e., neither table columns sections) can generated filled info text using one calls info_section(). expressed R code YAML representation. Subsections represented column names automatically generated creating informant. Within top-level sections (.e., History Additional Notes) can multiple subsections used holding info text. safest use single quotation marks around info text directly editing YAML file. Note Markdown formatting info snippet placeholders (shown {snippet}, see info_snippet() information) preserved YAML. Markdown HTML conversion done printing informant (invoking get_informant_report() informant) processing snippets (generation insertion) done using incorporate() function. Thus, source text always maintained YAML representation never written processed form.","code":"# C√≥digo R informant %>%    info_section(     section_name = \"History\",     Changes = \" - Change 1 - Change 2 - Change 3\",     `Last Update` = \"(2020-10-23) at 3:28 PM.\"   ) %>%   info_section(     section_name = \"Additional Notes\",     `Notes 1` = \"Notes with a {snippet}.\",     `Notes 2` = \"**Bold notes**.\"   )  # Representaci√≥n YAML History:   Changes: |2-        - Change 1     - Change 2     - Change 3   Last Update: (2020-10-23) at 3:28 PM. Additional Notes:   Notes 1: Notes with a {snippet}.   Notes 2: '**Bold notes**.'"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Agregue informaci√≥n que se centre en alg√∫n aspecto clave de la tabla de datos ‚Äî info_section","text":"3-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_section.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Agregue informaci√≥n que se centre en alg√∫n aspecto clave de la tabla de datos ‚Äî info_section","text":"","code":"# Create a pointblank `informant` # object with `create_informant()`; # we specify a `read_fn` with the # `~` followed by a statement that # gets the `small_table` dataset informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   )  # The `informant` object has the 'table' # and 'columns' sections; we can create # entirely different sections with their # own properties using `info_section()`  # We can add *info text* to sections # entirely different than `table` and # `columns` with `info_section()` informant <-   informant %>%   info_section(     section_name = \"Notes\",     creation = \"Dataset generated on (2020-01-15).\",     usage = \"`small_table %>% dplyr::glimpse()`\"   ) %>%   incorporate() #>  #> ‚îÄ‚îÄ Incorporation Started ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚úî Information gathered. #> ‚úî Information built. #>  #> ‚îÄ‚îÄ Incorporation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # Upon printing the `informant` object, we see # the addition of the 'Notes' section and its # own information  if (interactive()) {  # The `informant` object can be written to # a YAML file with the `yaml_write()` # function; then, information can # be directly edited or modified yaml_write(   informant = informant,   filename = \"informant.yml\" )  # The YAML file can then be read back # into an informant object with the # `yaml_read_informant()` function informant <-   yaml_read_informant(     filename = \"informant.yml\"   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":null,"dir":"Reference","previous_headings":"","what":"Genere un 'snippet' de texto √∫til a partir de la tabla de destino ‚Äî info_snippet","title":"Genere un 'snippet' de texto √∫til a partir de la tabla de destino ‚Äî info_snippet","text":"Getting little snippets information table goes hand--hand mixing bits info table info. Call info_snippet() define snippet get target table. snippet definition supplied either formula, , pointblank-supplied snip_*() function. long know interact table extract information, can easily define snippets informant object. snippets defined, can insert info text defined info_*() functions (info_tabular(), info_columns(), info_section()). Use curly braces just snippet_name inside (e.g., \"column {n_cat} categories.\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Genere un 'snippet' de texto √∫til a partir de la tabla de destino ‚Äî info_snippet","text":"","code":"info_snippet(x, snippet_name, fn)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Genere un 'snippet' de texto √∫til a partir de la tabla de destino ‚Äî info_snippet","text":"x informant object class ptblank_informant. snippet_name name snippet, used interpolating result snippet formula info text defined info_*() function. fn formula obtains snippet data target table. best use leading dot (.) stands table use pipes construct series operations performed table (e.g., ~ . %>% dplyr::pull(column_2) %>% max(na.rm = TRUE)). long result length-1 vector, 'll likely valid insertion info text. Alternatively, snip_*() function can used (functions always return formula suitable types data sources).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Genere un 'snippet' de texto √∫til a partir de la tabla de destino ‚Äî info_snippet","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"snip-functions-provided-in-pointblank","dir":"Reference","previous_headings":"","what":"Snip functions provided in pointblank","title":"Genere un 'snippet' de texto √∫til a partir de la tabla de destino ‚Äî info_snippet","text":"convenience, several snip_*() functions provided package work column data informant's target table. : snip_list(): get list column categories snip_stats(): get inline statistical summary snip_lowest(): get lowest value column snip_highest() : get highest value column understood target table , column functions necessary obtaining resultant text.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Genere un 'snippet' de texto √∫til a partir de la tabla de destino ‚Äî info_snippet","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). Snippets stored YAML representation expressed R code YAML output (showing meta_snippets columns keys demonstrate relationship ).","code":"# C√≥digo R informant %>%    info_columns(     columns = \"date_time\",     `Latest Date` = \"The latest date is {latest_date}.\"   ) %>%   info_snippet(     snippet_name = \"latest_date\",     fn = ~ . %>% dplyr::pull(date) %>% max(na.rm = TRUE)   ) %>%   incorporate()  # Representaci√≥n YAML meta_snippets:   latest_date: ~. %>% dplyr::pull(date) %>% max(na.rm = TRUE) ... columns:   date_time:     _type: POSIXct, POSIXt     Latest Date: The latest date is {latest_date}.   date:     _type: Date   item_count:     _type: integer"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Genere un 'snippet' de texto √∫til a partir de la tabla de destino ‚Äî info_snippet","text":"3-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_snippet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Genere un 'snippet' de texto √∫til a partir de la tabla de destino ‚Äî info_snippet","text":"","code":"# Take the `small_table` and # assign it to `test_table`; we'll # modify it later test_table <- small_table  # Generate an informant object, add # two snippets with `info_snippet()`, # add information with some other # `info_*()` functions and then # `incorporate()` the snippets into # the info text informant <-    create_informant(     read_fn = ~ test_table,     tbl_name = \"test_table\",     label = \"Un ejemplo.\"   ) %>%   info_snippet(     snippet_name = \"row_count\",     fn = ~ . %>% nrow()   ) %>%   info_snippet(     snippet_name = \"max_a\",     fn = snip_highest(column = \"a\")   ) %>%   info_columns(     columns = vars(a),     info = \"In the range of 1 to {max_a}. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`. (CALC)\"   ) %>%   info_section(     section_name = \"rows\",     row_count = \"There are {row_count} rows available.\"   ) %>%   incorporate() #> Error in rlang::eval_tidy(., env = caller_env(n = 1)): object 'test_table' not found  # We can print the `informant` object # to see the information report  # Let's modify `test_table` to give # it more rows and an extra column test_table <-    dplyr::bind_rows(test_table, test_table) %>%   dplyr::mutate(h = a + c)  # Using `incorporate()` will cause # the snippets to be reprocessed, and, # the info text to be updated informant <-   informant %>% incorporate() #> Error in incorporate(.): object 'informant' not found"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":null,"dir":"Reference","previous_headings":"","what":"Agregue informaci√≥n que se centre en aspectos de la tabla de datos en su\nconjunto ‚Äî info_tabular","title":"Agregue informaci√≥n que se centre en aspectos de la tabla de datos en su\nconjunto ‚Äî info_tabular","text":"informant object created create_informant() function, two starter sections: (1) 'table' (2) 'columns'. 'table' section contain properties upon creation, supplied table name (name) table dimensions (_columns _rows). can add table-based properties info_tabular() function. providing series named arguments (form entry_name = \"*info text*.\"), can add information makes sense describing table whole.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Agregue informaci√≥n que se centre en aspectos de la tabla de datos en su\nconjunto ‚Äî info_tabular","text":"","code":"info_tabular(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Agregue informaci√≥n que se centre en aspectos de la tabla de datos en su\nconjunto ‚Äî info_tabular","text":"x informant object class ptblank_informant. ... Information entries series named arguments. names refer subsection titles within TABLE section RHS info text (informational text can written Markdown styled Text Tricks).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Agregue informaci√≥n que se centre en aspectos de la tabla de datos en su\nconjunto ‚Äî info_tabular","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"info-text","dir":"Reference","previous_headings":"","what":"Info Text","title":"Agregue informaci√≥n que se centre en aspectos de la tabla de datos en su\nconjunto ‚Äî info_tabular","text":"info text used info_*() functions readily accepts Markdown formatting, , Text Tricks can used spice presentation. Markdown links written < link url > [ link text ]( link url ) get nicely-styled links. dates expressed ISO-8601 standard parentheses, \"(2004-12-01)\", styled font variation (monospaced) underlined purple. Spans text can converted label-style text using: (1) double parentheses around text rectangular border ((label text)), (2) triple parentheses around text rounded-rectangular border like (((label text))). CSS style rules can applied spans info text following form: [[ info text ]]<< CSS style rules >> example practice suppose like change color text red make font appear somewhat thinner. variation following might used: \"[[factor]]<<color: red; font-weight: 300;>> value.\" quite CSS style rules can used great effect. might like: color: <color value>; (text color) background-color: <color value>; (text's background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); examples, 'length value' refers CSS length can expressed different units measure (e.g., 12px, 1em, etc.). lengths can expressed positive negative values (e.g., letter-spacing). Color values can expressed ways, common form hexadecimal color values CSS color names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Agregue informaci√≥n que se centre en aspectos de la tabla de datos en su\nconjunto ‚Äî info_tabular","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). info_tabular() represented YAML, info text goes subsections top-level table key. example call info_tabular() expressed R code corresponding YAML representation. Subsection titles defined info_tabular() can set backticks syntactically correct argument name without (e.g., using spaces, hyphens, etc.). safest use single quotation marks around info text directly editing YAML file. Note Markdown formatting info snippet placeholders (shown {snippet_1}, see info_snippet() information) preserved YAML. Markdown HTML conversion done printing informant (invoking get_informant_report() informant) processing snippets (generation insertion) done using incorporate() function. Thus, source text always maintained YAML representation never written processed form.","code":"# C√≥digo R informant %>%    info_tabular(     section_1 = \"*info text* 1.\",     `section 2` = \"*info text* 2 and {snippet_1}\"   )  # Representaci√≥n YAML table:   _columns: 23   _rows: 205.0   _type: tbl_df   section_1: '*info text* 1.'   section 2: '*info text* 2 and {snippet_1}'"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Agregue informaci√≥n que se centre en aspectos de la tabla de datos en su\nconjunto ‚Äî info_tabular","text":"3-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/info_tabular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Agregue informaci√≥n que se centre en aspectos de la tabla de datos en su\nconjunto ‚Äî info_tabular","text":"","code":"# Create a pointblank `informant` # object with `create_informant()`; # we specify a `read_fn` with the # `~` followed by a statement that # gets the `small_table` dataset informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   )  # We can add *info text* to describe # the table with `info_tabular()` informant <-   informant %>%   info_tabular(     `Row Definition` = \"A row has randomized values.\",     Source = c(       \"- From the **pointblank** package.\",       \"- [https://rich-iannone.github.io/pointblank/]()\"      )    )  # Upon printing the `informant` object, we see # the additions made to the 'Table' section  if (interactive()) {  # The `informant` object can be written to # a YAML file with the `yaml_write()` # function; then information can # be directly edited or modified yaml_write(   informant = informant,   filename = \"informant.yml\" )  # The YAML file can then be read back # into an informant object with the # `yaml_read_informant()` function informant <-   yaml_read_informant(     filename = \"informant.yml\"   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/interrogate.html","id":null,"dir":"Reference","previous_headings":"","what":"Dado un agente que tiene un plan de validaci√≥n, realice un interrogatorio ‚Äî interrogate","title":"Dado un agente que tiene un plan de validaci√≥n, realice un interrogatorio ‚Äî interrogate","text":"agent information (.e., validation plan series validation steps), interrogation process can occur according plan. , agent gathered intel, can use functions like get_agent_report() all_passed() understand interrogation went .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/interrogate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dado un agente que tiene un plan de validaci√≥n, realice un interrogatorio ‚Äî interrogate","text":"","code":"interrogate(   agent,   extract_failed = TRUE,   get_first_n = NULL,   sample_n = NULL,   sample_frac = NULL,   sample_limit = 5000 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/interrogate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dado un agente que tiene un plan de validaci√≥n, realice un interrogatorio ‚Äî interrogate","text":"agent agent object class ptblank_agent created create_agent(). extract_failed option collect rows pass particular validation step. default TRUE options allow fine control rows collected. get_first_n option collect non-passing rows chosen, option collect first n rows . Supply number rows extract top non-passing rows table (ordering data original table retained). sample_n option collect non-passing rows chosen, option allows sampling n rows. Supply number rows sample non-passing rows table. n greater number non-passing rows, rows returned. sample_frac option collect non-passing rows chosen, option allows sampling fraction rows. Provide number range 0 1. number rows return may extremely large (especially querying remote databases), however, sample_limit option apply hard limit returned rows. sample_limit value limits possible number rows returned sampling non-passing rows using sample_frac option.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/interrogate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dado un agente que tiene un plan de validaci√≥n, realice un interrogatorio ‚Äî interrogate","text":"Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/interrogate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Dado un agente que tiene un plan de validaci√≥n, realice un interrogatorio ‚Äî interrogate","text":"6-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/interrogate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dado un agente que tiene un plan de validaci√≥n, realice un interrogatorio ‚Äî interrogate","text":"","code":"if (interactive()) {  # Create a simple table with two # columns of numerical values tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 0, 3)   )  # Validate that values in column # `a` from `tbl` are always > 5, # using `interrogate()` carries out # the validation plan and completes # the whole process agent <-   create_agent(tbl = tbl) %>%   col_vals_gt(vars(a), value = 5) %>%   interrogate()  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/log4r_step.html","id":null,"dir":"Reference","previous_headings":"","what":"Habilite el registro de condiciones de falla en el nivel del paso de\nvalidaci√≥n ‚Äî log4r_step","title":"Habilite el registro de condiciones de falla en el nivel del paso de\nvalidaci√≥n ‚Äî log4r_step","text":"log4r_step() function can used action action_levels() function (list component fns list). Place call function every failure condition produce log (.e., warn, stop, notify). failure condition highest severity given validation step produce log entry (skipping failure conditions lower severity) long call log4r_step() present.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/log4r_step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Habilite el registro de condiciones de falla en el nivel del paso de\nvalidaci√≥n ‚Äî log4r_step","text":"","code":"log4r_step(x, message = NULL, append_to = \"pb_log_file\")"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/log4r_step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Habilite el registro de condiciones de falla en el nivel del paso de\nvalidaci√≥n ‚Äî log4r_step","text":"x reference x-list object prepared agent. version x-list generated via get_agent_x_list(<agent>, = <step>) except version internally generated hence available internal evaluation context. message message use log entry. provided, default glue string used messaging. dynamic since internal glue::glue() call occurs environment x, x-list constrained validation step. default message, used message = NULL glue string \"Step {x$} exceeded {level} failure threshold (f_failed = {x$f_failed}) ['{x$type}']\". can seen, custom message can crafted uses elements x-list {x$<component>} construction. append_to file log entries warn level appended. can alternatively one log4r appenders.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/log4r_step.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Habilite el registro de condiciones de falla en el nivel del paso de\nvalidaci√≥n ‚Äî log4r_step","text":"5-1","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator ‚Äî %>%","title":"Pipe operator ‚Äî %>%","text":"See magrittr::[\\%>\\%][magrittr::\\%>\\%] details.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator ‚Äî %>%","text":"","code":"lhs %>% rhs"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.action_levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto action_levels ‚Äî print.action_levels","title":"Imprime el objeto action_levels ‚Äî print.action_levels","text":"function allow action_levels nicely printed.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.action_levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto action_levels ‚Äî print.action_levels","text":"","code":"# S3 method for action_levels print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.action_levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto action_levels ‚Äî print.action_levels","text":"x object class action_levels. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto ptblank_agent ‚Äî print.ptblank_agent","title":"Imprime el objeto ptblank_agent ‚Äî print.ptblank_agent","text":"function allow agent object print useful HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto ptblank_agent ‚Äî print.ptblank_agent","text":"","code":"# S3 method for ptblank_agent print(x, view = interactive(), ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto ptblank_agent ‚Äî print.ptblank_agent","text":"x object class ptblank_agent. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_informant.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto  ptblank_informant ‚Äî print.ptblank_informant","title":"Imprime el objeto  ptblank_informant ‚Äî print.ptblank_informant","text":"function allow informant object print useful HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_informant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto  ptblank_informant ‚Äî print.ptblank_informant","text":"","code":"# S3 method for ptblank_informant print(x, view = interactive(), ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_informant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto  ptblank_informant ‚Äî print.ptblank_informant","text":"x informant object class ptblank_informant. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_multiagent.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto ptblank_multiagent ‚Äî print.ptblank_multiagent","title":"Imprime el objeto ptblank_multiagent ‚Äî print.ptblank_multiagent","text":"function allow multiagent object print useful HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_multiagent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto ptblank_multiagent ‚Äî print.ptblank_multiagent","text":"","code":"# S3 method for ptblank_multiagent print(x, view = interactive(), ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_multiagent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto ptblank_multiagent ‚Äî print.ptblank_multiagent","text":"x object class ptblank_multiagent. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_multiagent_report.long.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto ptblank_multiagent_report.long ‚Äî print.ptblank_multiagent_report.long","title":"Imprime el objeto ptblank_multiagent_report.long ‚Äî print.ptblank_multiagent_report.long","text":"function print ptblank_multiagent_report.long object, HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_multiagent_report.long.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto ptblank_multiagent_report.long ‚Äî print.ptblank_multiagent_report.long","text":"","code":"# S3 method for ptblank_multiagent_report.long print(x, view = interactive(), ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_multiagent_report.long.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto ptblank_multiagent_report.long ‚Äî print.ptblank_multiagent_report.long","text":"x object class ptblank_multiagent_report.long. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_tbl_scan.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto ptblank_tbl_scan ‚Äî print.ptblank_tbl_scan","title":"Imprime el objeto ptblank_tbl_scan ‚Äî print.ptblank_tbl_scan","text":"function print ptblank_tbl_scan object, HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_tbl_scan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto ptblank_tbl_scan ‚Äî print.ptblank_tbl_scan","text":"","code":"# S3 method for ptblank_tbl_scan print(x, ..., view = interactive())"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.ptblank_tbl_scan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto ptblank_tbl_scan ‚Äî print.ptblank_tbl_scan","text":"x object class ptblank_tbl_scan. ... additional parameters. view value print()s browse argument.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.read_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto read_fn ‚Äî print.read_fn","title":"Imprime el objeto read_fn ‚Äî print.read_fn","text":"function allow read_fn nicely printed.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.read_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto read_fn ‚Äî print.read_fn","text":"","code":"# S3 method for read_fn print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.read_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto read_fn ‚Äî print.read_fn","text":"x object class read_fn. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.tbl_store.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprime el objeto tbl_store ‚Äî print.tbl_store","title":"Imprime el objeto tbl_store ‚Äî print.tbl_store","text":"function allow tbl_store nicely printed.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.tbl_store.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprime el objeto tbl_store ‚Äî print.tbl_store","text":"","code":"# S3 method for tbl_store print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.tbl_store.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprime el objeto tbl_store ‚Äî print.tbl_store","text":"x object class tbl_store. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.x_list_i.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprima una x-list de un solo paso en la consola ‚Äî print.x_list_i","title":"Imprima una x-list de un solo paso en la consola ‚Äî print.x_list_i","text":"function print x-list object, single step, console.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.x_list_i.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprima una x-list de un solo paso en la consola ‚Äî print.x_list_i","text":"","code":"# S3 method for x_list_i print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.x_list_i.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprima una x-list de un solo paso en la consola ‚Äî print.x_list_i","text":"x x-list object class x_list_i. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.x_list_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Imprima una x-list que incluya todos los pasos de validaci√≥n en la consola ‚Äî print.x_list_n","title":"Imprima una x-list que incluya todos los pasos de validaci√≥n en la consola ‚Äî print.x_list_n","text":"function print x-list object, validation steps included, console.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.x_list_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imprima una x-list que incluya todos los pasos de validaci√≥n en la consola ‚Äî print.x_list_n","text":"","code":"# S3 method for x_list_n print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/print.x_list_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imprima una x-list que incluya todos los pasos de validaci√≥n en la consola ‚Äî print.x_list_n","text":"x x-list object class x_list_n. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/read_disk_multiagent.html","id":null,"dir":"Reference","previous_headings":"","what":"Leer objetos pointblank agent almacenados en el disco como multiagent ‚Äî read_disk_multiagent","title":"Leer objetos pointblank agent almacenados en el disco como multiagent ‚Äî read_disk_multiagent","text":"agent informant can written disk x_write_disk() function. useful later retrieving stored agent x_read_disk() also possible read series -disk agents read_disk_multiagent() function, creates ptblank_multiagent object. multiagent object can also generated via create_multiagent() function less convenient use one just using agents previous written disk.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/read_disk_multiagent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leer objetos pointblank agent almacenados en el disco como multiagent ‚Äî read_disk_multiagent","text":"","code":"read_disk_multiagent(filenames = NULL, pattern = NULL, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/read_disk_multiagent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leer objetos pointblank agent almacenados en el disco como multiagent ‚Äî read_disk_multiagent","text":"filenames names files (holding agent objects) previously written x_write_disk(). pattern regex pattern accessing saved--disk agent files located directory (specified path argument). path path collection files. either optional case files specified filenames (path combined filenames), , required providing pattern file names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/read_disk_multiagent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leer objetos pointblank agent almacenados en el disco como multiagent ‚Äî read_disk_multiagent","text":"Un objeto ptblank_multiagent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/read_disk_multiagent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Leer objetos pointblank agent almacenados en el disco como multiagent ‚Äî read_disk_multiagent","text":"10-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages ‚Äî reexports","title":"Objects exported from other packages ‚Äî reexports","text":"objects imported packages. Follow links see documentation. blastula creds, creds_anonymous, creds_file, creds_key dplyr , case_when, vars rlang expr tidyselect contains, ends_with, everything, matches, starts_with","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_read_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Eliminar una f√≥rmula de preparaci√≥n de tablas asociada con un agent o\ninformant ‚Äî remove_read_fn","title":"Eliminar una f√≥rmula de preparaci√≥n de tablas asociada con un agent o\ninformant ‚Äî remove_read_fn","text":"Removing agent informant's association table-pre formula can done remove_read_fn(). may good idea interactive session needing rely direct association 'fixed' data table (settable create_agent() create_informant()'s tbl argument set_tbl()) instead using table-prep formula might produce different different table expected. table-prep formula can always set set_read_fn().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_read_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Eliminar una f√≥rmula de preparaci√≥n de tablas asociada con un agent o\ninformant ‚Äî remove_read_fn","text":"","code":"remove_read_fn(x)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_read_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Eliminar una f√≥rmula de preparaci√≥n de tablas asociada con un agent o\ninformant ‚Äî remove_read_fn","text":"x agent object class ptblank_agent, , informant class ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_read_fn.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Eliminar una f√≥rmula de preparaci√≥n de tablas asociada con un agent o\ninformant ‚Äî remove_read_fn","text":"9-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_read_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Eliminar una f√≥rmula de preparaci√≥n de tablas asociada con un agent o\ninformant ‚Äî remove_read_fn","text":"","code":"# Set proportional failure thresholds # to the `warn`, `stop`, and `notify` # states using `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Create an agent that directly ingests # the `small_table` object and also has # a table-prep formula (when both are # present the latter always obtains the # table); apply the actions, add some # validation steps and then interrogate # the data that was read in agent_1 <-    create_agent(     tbl = small_table,     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate()    # In a situation where `small_table` # changes frequently and it's desirable # to have a snapshot of the table, we # can remove the table-prep formula so # that the ingested `small_table` will # be used agent_2 <-   agent_1 %>%   remove_read_fn() %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_steps.html","id":null,"dir":"Reference","previous_headings":"","what":"Eliminar uno o m√°s de los pasos de validaci√≥n de un objeto agent ‚Äî remove_steps","title":"Eliminar uno o m√°s de los pasos de validaci√≥n de un objeto agent ‚Äî remove_steps","text":"Validation steps can removed agent object use remove_steps() function. useful, instance, getting agent disk (via x_read_disk() function) omitting one steps agent's validation plan. Please note removing validation steps stored data extracts removed agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_steps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Eliminar uno o m√°s de los pasos de validaci√≥n de un objeto agent ‚Äî remove_steps","text":"","code":"remove_steps(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_steps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Eliminar uno o m√°s de los pasos de validaci√≥n de un objeto agent ‚Äî remove_steps","text":"agent Un objeto de agente de clase ptblank_agent. validation step number, assigned validation step order definition. NULL (default) step removal occur index.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_steps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Eliminar uno o m√°s de los pasos de validaci√≥n de un objeto agent ‚Äî remove_steps","text":"Un objeto ptblank_agent. Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_steps.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Eliminar uno o m√°s de los pasos de validaci√≥n de un objeto agent ‚Äî remove_steps","text":"9-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_steps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Eliminar uno o m√°s de los pasos de validaci√≥n de un objeto agent ‚Äî remove_steps","text":"","code":"# Create an agent that has the # `small_table` object as the # target table, add a few # validation steps, and then use # `interrogate()` agent_1 <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%   col_exists(vars(date)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]\"   ) %>%   interrogate()    # The second validation step has # been determined to be unneeded and # is to be removed; this can be done # by used `remove_steps()` with the # agent object agent_2 <-   agent_1 %>%   remove_steps(i = 2) %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Eliminar una tabla de datos asociada con un agent o informant ‚Äî remove_tbl","title":"Eliminar una tabla de datos asociada con un agent o informant ‚Äî remove_tbl","text":"Removing agent informant's association data table can done remove_tbl() function. can useful ensure table data unintentionally written disk. usually best avoid directly associating table agent informant tbl argument, instead opting setting table-prep formula (via create_agent() create_informant()'s read_fn argument, , set_read_fn()). necessary, association table can set set_tbl().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Eliminar una tabla de datos asociada con un agent o informant ‚Äî remove_tbl","text":"","code":"remove_tbl(x)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Eliminar una tabla de datos asociada con un agent o informant ‚Äî remove_tbl","text":"x agent object class ptblank_agent, , informant class ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Eliminar una tabla de datos asociada con un agent o informant ‚Äî remove_tbl","text":"9-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/remove_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Eliminar una tabla de datos asociada con un agent o informant ‚Äî remove_tbl","text":"","code":"# Set proportional failure thresholds # to the `warn`, `stop`, and `notify` # states using `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Create an agent that has # `small_table` set as the target # table via `tbl`; apply the actions, # add some validation steps and then # interrogate the data agent_1 <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate()    # In this case where `small_table` # changes (and the aim is to have # validations run periodically) it is # better to obtain the table from the # source with a table-prep formula; # while doing this, the direct # association to `small_table` can be # removed with `remove_tbl()` so it's # no longer part of the agent object agent_2 <-   agent_1 %>%   remove_tbl() %>%   set_read_fn(read_fn = ~ small_table) %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Does the row count match that of a different table? ‚Äî row_count_match","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"row_count_match() validation function, expect_row_count_match() expectation function, test_row_count_match() test function check whether row count target table matches comparison table. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation, single test unit hinges whether row counts two tables (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"","code":"row_count_match(   x,   tbl_compare,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_row_count_match(   object,   tbl_compare,   preconditions = NULL,   threshold = 1 )  test_row_count_match(object, tbl_compare, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). tbl_compare table compare target table terms row count values. can either table object, table-prep formula.can table object data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, table-prep formula (~ <table reading code>) function (function() <table reading code>) can used lazily read table interrogation time. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires operation target table row count comparison takes place. Using preconditions can useful times since since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed. Alternatively, function instead supplied.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. Using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). row_count_match() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call row_count_match() validation step expressed R code corresponding YAML representation. practice, often shorter. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    row_count_match(     tbl_compare = ~ file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       ),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `row_count_match()` step.\",     active = FALSE   )  # YAML representation steps: - row_count_match:     tbl_compare: ~ file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       )     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `row_count_match()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"2-31","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/row_count_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"","code":"# Create a simple table with three # columns and four rows of values tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5),     b = c(7, 1, 0, 0),     c = c(1, 1, 1, 3)   )  # Create a second table which is # quite different but has the # same number of rows as `tbl` tbl_2 <-   dplyr::tibble(     e = c(\"a\", NA, \"a\", \"c\"),     f = c(2.6, 1.2, 0, NA)   )  # Validate that the count of rows # in the target table (`tbl`) matches # that of the comparison table # (`tbl_2`) agent <-   create_agent(tbl = tbl) %>%   row_count_match(tbl_compare = tbl_2) %>%   interrogate()  # Determine if this validation passed # by using `all_passed()` all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øEst√°n completos los datos de las filas? ‚Äî rows_complete","title":"¬øEst√°n completos los datos de las filas? ‚Äî rows_complete","text":"La funci√≥n de validaci√≥n rows_complete(), la funci√≥n de expectativa expect_rows_complete() y la funci√≥n de prueba test_rows_complete() comprueban si las filas contienen alg√∫n valor NA/NULL (opcionalmente restringido una selecci√≥n de columns). La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions). Podemos especificar los nombres de las columnas restrictivas entre comillas, en var(), y con las siguientes funciones auxiliares tidyselect: starts_with(), ends_with(), contains(), matches() y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øEst√°n completos los datos de las filas? ‚Äî rows_complete","text":"","code":"rows_complete(   x,   columns = NULL,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_rows_complete(   object,   columns = NULL,   preconditions = NULL,   threshold = 1 )  test_rows_complete(object, columns = NULL, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øEst√°n completos los datos de las filas? ‚Äî rows_complete","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øEst√°n completos los datos de las filas? ‚Äî rows_complete","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øEst√°n completos los datos de las filas? ‚Äî rows_complete","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øEst√°n completos los datos de las filas? ‚Äî rows_complete","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øEst√°n completos los datos de las filas? ‚Äî rows_complete","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øEst√°n completos los datos de las filas? ‚Äî rows_complete","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øEst√°n completos los datos de las filas? ‚Äî rows_complete","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando rows_complete() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de rows_complete() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos. Un valor para columns s√≥lo es s√≥lo es necesario si se buscan valores √∫nicos en un subconjunto de columnas. Los argumentos con valores por defecto se escribir√°n en YAML cuando se utilice yaml_write() (aunque es aceptable incluirlos con su valor por defecto al generar el YAML por otros medios). Tambi√©n es posible previsualizar la transformaci√≥n de un agente YAML sin necesidad de escribirlo en el disco, utilizando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    rows_complete(     columns = vars(a, b),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `rows_complete()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - rows_complete:     columns: vars(a, b)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `rows_complete()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øEst√°n completos los datos de las filas? ‚Äî rows_complete","text":"2-21","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_complete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øEst√°n completos los datos de las filas? ‚Äî rows_complete","text":"","code":"# Cree una tabla sencilla con tres # columnas de valores num√©ricos tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 8, 3),     c = c(1, 1, 1, 3, 3, 3)   )  # Validar que al considerar s√≥lo # los datos de las columnas `a` y # `b`, s√≥lo hay filas completas (es # decir, todas las filas no tienen # valores `NA`) agent <-   create_agent(tbl = tbl) %>%   rows_complete(vars(a, b)) %>%   interrogate()  # Determine si esta validaci√≥n # pas√≥ usando `all_passed()` all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øSon distintos los datos de las filas? ‚Äî rows_distinct","title":"¬øSon distintos los datos de las filas? ‚Äî rows_distinct","text":"La funci√≥n de validaci√≥n rows_distinct(), la funci√≥n de expectativa expect_rows_distinct() y la funci√≥n de prueba test_rows_distinct() comprueban si los valores de las filas (opcionalmente restringidos una selecci√≥n de columns especificadas) son, cuando se toman como una unidad completa, distintos de todas las dem√°s unidades de la tabla. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Cada paso de validaci√≥n o expectativa operar√° sobre el n√∫mero de unidades de prueba que es igual al n√∫mero de filas en la tabla (despu√©s de que se hayan aplicado las preconditions). Podemos especificar los nombres de las columnas restrictivas entre comillas, en var(), y con las siguientes funciones auxiliares tidyselect: starts_with(), ends_with(), contains(), matches() y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øSon distintos los datos de las filas? ‚Äî rows_distinct","text":"","code":"rows_distinct(   x,   columns = NULL,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_rows_distinct(   object,   columns = NULL,   preconditions = NULL,   threshold = 1 )  test_rows_distinct(object, columns = NULL, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øSon distintos los datos de las filas? ‚Äî rows_distinct","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). columns La columna (o un conjunto de columnas, proporcionado como un vector de caracteres) la que se debe aplicar esta validaci√≥n. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øSon distintos los datos de las filas? ‚Äî rows_distinct","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øSon distintos los datos de las filas? ‚Äî rows_distinct","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øSon distintos los datos de las filas? ‚Äî rows_distinct","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øSon distintos los datos de las filas? ‚Äî rows_distinct","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop() en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øSon distintos los datos de las filas? ‚Äî rows_distinct","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øSon distintos los datos de las filas? ‚Äî rows_distinct","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando rows_distinct() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de rows_distinct() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos. Un valor para columns s√≥lo es s√≥lo es necesario si se buscan valores √∫nicos en un subconjunto de columnas. Los argumentos con valores por defecto se escribir√°n en YAML cuando se utilice yaml_write() (aunque es aceptable incluirlos con su valor por defecto al generar el YAML por otros medios). Tambi√©n es posible previsualizar la transformaci√≥n de un agente YAML sin necesidad de escribirlo en el disco, utilizando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    rows_distinct(     columns = vars(a, b),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `rows_distinct()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - rows_distinct:     columns: vars(a, b)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `rows_distinct()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øSon distintos los datos de las filas? ‚Äî rows_distinct","text":"2-20","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/rows_distinct.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øSon distintos los datos de las filas? ‚Äî rows_distinct","text":"","code":"# Create a simple table with three # columns of numerical values tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 8, 3),     c = c(1, 1, 1, 3, 3, 3)   )  # Validate that when considering only # data in columns `a` and `b`, there # are no duplicate rows (i.e., all # rows are distinct) agent <-   create_agent(tbl = tbl) %>%   rows_distinct(vars(a, b)) %>%   interrogate()  # Determine si esta validaci√≥n # pas√≥ usando `all_passed()` all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/scan_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Escanee minuciosamente una tabla para comprenderla mejor ‚Äî scan_data","title":"Escanee minuciosamente una tabla para comprenderla mejor ‚Äî scan_data","text":"Generar un informe HTML que recorra los datos de la tabla de entrada. Antes de llamar un agente para validar los datos, es una buena idea entender los datos con cierto nivel de precisi√≥n. Haga que este sea el paso inicial de un flujo de trabajo bien equilibrado de  *flujo de trabajo de informaci√≥n sobre la calidad de los datos. La salida del informe contiene varias secciones para hacer todo m√°s digerible, y estas son: Overview Dimensiones de la tabla, recuento de filas duplicadas, tipos de columnas y informaci√≥n de reproducibilidad Variables Un resumen para cada variable de la tabla y m√°s estad√≠sticas y res√∫menes en funci√≥n del tipo de variable Interactions Un gr√°fico matricial que muestra las interacciones entre las variables Correlations Un conjunto de gr√°ficos de matrices de correlaci√≥n para variables num√©ricas variables num√©ricas Missing Values Una figura de resumen que muestra el grado de ausencia en todas las variables Sample Una tabla que proporciona las filas de cabeza y cola del conjunto de datos El informe HTML de salida aparecer√° en el visor de RStudio y tambi√©n puede integrarse en la salida HTML de R Markdown. Si necesita el HTML de salida como una cadena, es posible obtenerlo utilizando .character() (por ejemplo, scan_data(tbl = mtcars) %>% .character()). La cadena HTML resultante es un documento HTML completo donde Bootstrap y jQuery est√°n incrustados en su interior.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/scan_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Escanee minuciosamente una tabla para comprenderla mejor ‚Äî scan_data","text":"","code":"scan_data(   tbl,   sections = \"OVICMS\",   navbar = TRUE,   width = NULL,   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/scan_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Escanee minuciosamente una tabla para comprenderla mejor ‚Äî scan_data","text":"tbl La tabla de entrada. Puede ser un marco de datos, un tibble, un objeto tbl_dbi o un objeto tbl_spark. sections Las secciones incluir en el informe finalizado de Escaneo de Tablas. Aqu√≠ se requiere una cadena con caracteres clave que representen los nombres de las secciones. La cadena por defecto es \"OVICMS\" donde cada letra representa las siguientes secciones en su orden por defecto: \"O\": \"overview\"; \"V\": \"variables\"; \"\": \"interactions\"; \"C\": \"correlations\"; \"M\": \"missing\"; y \"S\": \"sample\". Esta cadena puede estar compuesta por menos caracteres y el orden puede cambiarse para adaptarse al dise√±o deseado del informe. En el caso de los objetos tbl_dbi y tbl_spark suministrados tbl, las secciones de \"interactions\" y \"correlations\" est√°n excluidas. navbar ¬øDebe haber una barra de navegaci√≥n anclada en la parte superior de la p√°gina del informe? Por defecto es TRUE. width Una anchura fija opcional (en p√≠xeles) para el informe HTML. Por defecto se aplica ninguna anchura fija. lang El idioma que se utilizar√° para el texto de la etiqueta en el informe. De forma predeterminada, NULL crear√° texto en ingl√©s (\"en\"). Otras opciones incluyen franc√©s (\"fr\"), alem√°n (\"de\"), italiano (\"\"), espa√±ol (\"es\"), portugu√©s (\"pt\"), turco (\"tr\"), chino (\"zh\"), ruso (\"ru\"), polaco (\"pl\"), dan√©s (\"da\"), sueco (\"sv\" ) y holand√©s (\"nl\"). locale Un identificador opcional de la configuraci√≥n regional que se utilizar√° para formatear los valores en el informe de acuerdo con las reglas de la configuraci√≥n regional. Los ejemplos incluyen \"en_US\" para el ingl√©s (Estados Unidos) y \"fr_FR\" para el franc√©s (Francia); m√°s sencillamente, puede ser un identificador de idioma sin designaci√≥n de pa√≠s, como \"es\" para espa√±ol (Espa√±a, igual que \"es_ES\").","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/scan_data.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Escanee minuciosamente una tabla para comprenderla mejor ‚Äî scan_data","text":"1-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/scan_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Escanee minuciosamente una tabla para comprenderla mejor ‚Äî scan_data","text":"","code":"if (interactive()) {  # Obtener un documento HTML que describa # los datos de la tabla `dplyr::storms` tbl_scan <- scan_data(tbl = dplyr::storms)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":null,"dir":"Reference","previous_headings":"","what":"Ejecutar varias pruebas y una validaci√≥n final en serie ‚Äî serially","title":"Ejecutar varias pruebas y una validaci√≥n final en serie ‚Äî serially","text":"La funci√≥n de validaci√≥n serially() permite ejecutar una serie de pruebas en secuencia antes de culminar con un paso de validaci√≥n final o simplemente salir de la serie. Esta construcci√≥n permite realizar pruebas previas que pueden tener sentido antes de un paso de validaci√≥n. Por ejemplo, puede haber situaciones en las que es vital comprobar el tipo de columna antes de realizar una validaci√≥n en la misma columna (ya que tener un tipo incorrecto puede dar lugar un error de evaluaci√≥n para la validaci√≥n posterior). Otro flujo de trabajo en serie podr√≠a implicar tener un conjunto de comprobaciones en un orden prescrito y, si todas pasan, entonces el objetivo de estas pruebas se ha alcanzado (por ejemplo, comprobar si una tabla coincide con otra trav√©s de una serie de pruebas cada vez m√°s espec√≠ficas). Una serie como se especifica dentro de serially() se compone con un listado de llamadas, y nos basar√≠amos en las funciones de prueba (T) para describir las pruebas y opcionalmente proporcionar una llamada final con una funci√≥n de validaci√≥n (V). Se aplican las siguientes restricciones: debe haber al menos una funci√≥n de prueba en la serie (T -> V es buena, V es ) s√≥lo puede haber una llamada la funci√≥n de validaci√≥n, V; es opcional pero, si se incluye, debe colocarse al final (T -> T -> V es buena, estas secuencias son malas: (1) T -> V -> T, (2) T -> T -> V -> V) una llamada la funci√≥n de validaci√≥n (V), si se incluye, debe producir por s√≠ misma m√∫ltiples pasos de validaci√≥n (esto puede ocurrir cuando se proporcionan m√∫ltiples columns o cualquier segments) Este es un ejemplo de c√≥mo organizar las expresiones: Esta serie se concentra en la columna llamada count y primero comprueba si la columna existe, luego comprueba si esa columna es num√©rica, y luego finalmente valida si todos los valores de la columna son mayores que 2. Tenga en cuenta que en la lista de llamadas anterior, el . representa la tabla de destino y siempre es necesario aqu√≠. Tambi√©n es importante que todas las funciones test_*() tienen un argumento threshold que se establece en 1 por defecto. Si necesita aumentar el valor del umbral, puede cambiarlo un valor entero diferente (como umbral absoluto de unidades de prueba que fallan) o un valor decimal entre 0 y 1 (que sirve como umbral fraccionario de unidades de prueba que fallan). unidades de prueba que fallan).","code":"~ test_col_exists(., columns = vars(count)), ~ test_col_is_numeric(., columns = vars(count)), ~ col_vals_gt(., columns = vars(count), value = 2)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ejecutar varias pruebas y una validaci√≥n final en serie ‚Äî serially","text":"","code":"serially(   x,   ...,   .list = list2(...),   preconditions = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_serially(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )  test_serially(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ejecutar varias pruebas y una validaci√≥n final en serie ‚Äî serially","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). ... Una colecci√≥n de f√≥rmulas unilaterales que consisten en llamadas funciones test_*() (por ejemplo, test_col_vals_between(), etc.) dispuestas en la secuencia del orden de interrogaci√≥n previsto. T√≠picamente, las validaciones hasta la final tendr√≠an alg√∫n valor de threshold establecido (por defecto es 1) para el cortocircuito dentro de la serie. Una llamada la funci√≥n de validaci√≥n final (por ejemplo, col_vals_increasing(), etc.) puede insertarse opcionalmente al final de la serie, sirviendo como un paso de validaci√≥n que s√≥lo se somete interrogaci√≥n si las pruebas anteriores pasan adecuadamente. Un ejemplo de esto es ~ test_column_exists(., vars()), ~ col_vals_not_null(., vars())). .list Permite el uso de una lista como alternativa de entrada .... preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ejecutar varias pruebas y una validaci√≥n final en serie ‚Äî serially","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"nombres-de-columnas","dir":"Reference","previous_headings":"","what":"Nombres de columnas","title":"Ejecutar varias pruebas y una validaci√≥n final en serie ‚Äî serially","text":"Si se proporcionan varios nombres de columna en cualquiera de los pasos de validaci√≥n suministrados, el resultado ser√° una expansi√≥n de los pasos de subvalidaci√≥n ese n√∫mero de nombres de columna. Aparte de los nombres de columnas entre comillas y en vars(), las funciones de ayuda tidyselect est√°n disponibles para especificar columnas. Son: starts_with(), ends_with(), contains(), matches() y everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Ejecutar varias pruebas y una validaci√≥n final en serie ‚Äî serially","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Ejecutar varias pruebas y una validaci√≥n final en serie ‚Äî serially","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop()s en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Ejecutar varias pruebas y una validaci√≥n final en serie ‚Äî serially","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Ejecutar varias pruebas y una validaci√≥n final en serie ‚Äî serially","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando serially() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de serially() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo son necesarias las expresiones para los pasos de validaci√≥n. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    serially(     ~ col_vals_lt(., vars(a), 8),     ~ col_vals_gt(., vars(c), vars(a)),     ~ col_vals_not_null(., vars(b)),     preconditions = ~ . %>% dplyr::filter(a < 10),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),      label = \"El paso `serially()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - serially:     fns:     - ~col_vals_lt(., vars(a), 8)     - ~col_vals_gt(., vars(c), vars(a))     - ~col_vals_not_null(., vars(b))     preconditions: ~. %>% dplyr::filter(a < 10)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `serially()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Ejecutar varias pruebas y una validaci√≥n final en serie ‚Äî serially","text":"2-32","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/serially.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ejecutar varias pruebas y una validaci√≥n final en serie ‚Äî serially","text":"","code":"# Para todos los ejemplos aqu√≠, # usaremos una tabla simple con tres # columnas num√©ricas (`a`, `b` y `c`); # esta es una tabla muy b√°sica pero # ser√° m√°s √∫til a la hora de explicar # las cosas m√°s adelante tbl <-   dplyr::tibble(     a = c(5, 2, 6),     b = c(6, 4, 9),     c = c(1, 2, 3)   )    tbl #> # A tibble: 3 √ó 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     6     1 #> 2     2     4     2 #> 3     6     9     3    # A: Usando un `agent` con funciones de #    validaci√≥n y luego `interrogate()`  # La funci√≥n `serially()` puede # configurarse para realizar una serie # de pruebas y luego realizar una # validaci√≥n (s√≥lo si se superan todas # las pruebas); en este caso, vamos a # (1) comprobar si las columnas `a` y `b` # son num√©ricas, (2) comprobar que ambas # no tienen ning√∫n valor `NA`, y # (3) realizar una validaci√≥n final que # compruebe si los valores de `b` son # mayores que los valores de `a`. agent_1 <-   create_agent(tbl = tbl) %>%   serially(     ~ test_col_is_numeric(., vars(a, b)),     ~ test_col_vals_not_null(., vars(a, b)),     ~ col_vals_gt(., vars(b), vars(a))     ) %>%   interrogate()    # Determine si esta validaci√≥n no tuvo # unidades de prueba fallidas (hay 4 # pruebas y una validaci√≥n final) all_passed(agent_1) #> [1] TRUE  # Llamar a `agent` en la consola imprime # el informe del agente; pero podemos # obtener un objeto `gt_tbl` directamente # con `get_agent_report(agent_1)`  # ¬øQu√© ocurre? Las cuatro pruebas han # sido aprobadas y, por tanto, se ha # producido la validaci√≥n final; # ¬°tampoco ha habido unidades de prueba # que hayan fallado!  # La validaci√≥n final es opcional; # aqu√≠ hay un agente diferente en el # que s√≥lo se realizan las pruebas en # serie se realizan agent_2 <-   create_agent(tbl = tbl) %>%   serially(     ~ test_col_is_numeric(., vars(a, b)),     ~ test_col_vals_not_null(., vars(a, b))   ) %>%   interrogate()    # Todo es bueno aqu√≠ tambi√©n: all_passed(agent_2) #> [1] TRUE  # B: Usando la funci√≥n de validaci√≥n #    directamente en los datos #    (sin `agent`)  # Esta forma de utilizar las funciones # de validaci√≥n act√∫a como un filtro de # datos: los datos se pasan a trav√©s, # pero deben `stop()` si hay una sola # unidad de prueba que falla; el # comportamiento de los efectos # secundarios se puede personalizar con # la opci√≥n `actions` tbl %>%   serially(     ~ test_col_is_numeric(., vars(a, b)),     ~ test_col_vals_not_null(., vars(a, b)),     ~ col_vals_gt(., vars(b), vars(a))   ) #> # A tibble: 3 √ó 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     6     1 #> 2     2     4     2 #> 3     6     9     3  # C: Usando la funci√≥n de expectativa  # Con el formulario `expect_*()`, # necesitamos ser m√°s exactos y # proporcionar una columna a la vez; # esto se usa principalmente en # pruebas `testthat` expect_serially(   tbl,   ~ test_col_is_numeric(., vars(a, b)),   ~ test_col_vals_not_null(., vars(a, b)),   ~ col_vals_gt(., vars(b), vars(a)) )  # D: Usando la funci√≥n de prueba  # Con la forma `test_*()`, deber√≠amos # obtener un √∫nico valor l√≥gico devuelto tbl %>%   test_serially(     ~ test_col_is_numeric(., vars(a, b)),     ~ test_col_vals_not_null(., vars(a, b)),     ~ col_vals_gt(., vars(b), vars(a))   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_read_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Establezca una f√≥rmula de preparaci√≥n de mesa para un agent o informant ‚Äî set_read_fn","title":"Establezca una f√≥rmula de preparaci√≥n de mesa para un agent o informant ‚Äî set_read_fn","text":"Una f√≥rmula de preparaci√≥n de tablas puede asociarse un agent o informant con set_read_fn(). En caso de que tanto un tbl *como un read_fn est√©n asociados al objeto agent o informant, el read_fn tendr√° prioridad. Podemos especificar un valor valor para read_fn con una expresi√≥n de f√≥rmula RHS (por ejemplo, ~ { <c√≥digo de lectura de tabla> }). La f√≥rmula de lectura de la tabla puede eliminarse con remove_read_fn() o reemplazada con set_read_fn().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_read_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Establezca una f√≥rmula de preparaci√≥n de mesa para un agent o informant ‚Äî set_read_fn","text":"","code":"set_read_fn(x, read_fn)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_read_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Establezca una f√≥rmula de preparaci√≥n de mesa para un agent o informant ‚Äî set_read_fn","text":"x Un objeto agent de la clase ptblank_agent, o, un objeto informant de clase ptblank_informant. read_fn Una expresi√≥n de f√≥rmula R (por ejemplo, ~ { <c√≥digo de lectura de la tabla> }) que se utiliza para preparar una tabla.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_read_fn.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Establezca una f√≥rmula de preparaci√≥n de mesa para un agent o informant ‚Äî set_read_fn","text":"9-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_read_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Establezca una f√≥rmula de preparaci√≥n de mesa para un agent o informant ‚Äî set_read_fn","text":"","code":"# Establecer umbrales de fallo # proporcionales a los estados # `warn`, `stop` y `notify` # utilizando `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Crear un objeto agente que # lea en `small_table` con una # f√≥rmula de preparaci√≥n de tabla; # aplicar las acciones, a√±adir # algunos pasos de validaci√≥n y # luego interrogar los datos agent_1 <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate()    # Cambie la f√≥rmula de preparaci√≥n # de la tabla para utilizar una # versi√≥n mutada de `small_table` # (que elimine las filas duplicadas); # a continuaci√≥n, interrogue la # tabla de destino de nuevo agent_2 <-   agent_1 %>%   set_read_fn(     read_fn = ~ small_table %>% dplyr::distinct()   ) %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Establecer una tabla de datos para un agent o informant ‚Äî set_tbl","title":"Establecer una tabla de datos para un agent o informant ‚Äî set_tbl","text":"Setting data table agent informant set_tbl() replaces associated table (data frame, tibble, objects class tbl_dbi tbl_spark). data table associated agent informant tbl argument object table-prep formula (settable create_agent() create_informant()'s read_fn argument set_read_fn()), table-prep formula take precedence. undesirable, removed remove_read_fn() function. association table can removed remove_tbl().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Establecer una tabla de datos para un agent o informant ‚Äî set_tbl","text":"","code":"set_tbl(x, tbl)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Establecer una tabla de datos para un agent o informant ‚Äî set_tbl","text":"x Un objeto agent de la clase ptblank_agent, o, un objeto informant de clase ptblank_informant. tbl input table agent. can data frame, tibble, tbl_dbi object, tbl_spark object. table already associated agent informant overwritten.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Establecer una tabla de datos para un agent o informant ‚Äî set_tbl","text":"9-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/set_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Establecer una tabla de datos para un agent o informant ‚Äî set_tbl","text":"","code":"# Establecer umbrales de fallo # proporcionales a los estados # `warn`, `stop` y `notify` # utilizando `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Crear un objeto agente que # lea en `small_table` con una # f√≥rmula de preparaci√≥n de tabla; # aplicar las acciones, a√±adir # algunos pasos de validaci√≥n y # luego interrogar los datos agent_1 <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate()    # Replace the agent's association to # `small_table` with a mutated version # of it (one that removes duplicate rows); # then, interrogate the new target table agent_2 <-   agent_1 %>%   set_tbl(     tbl = small_table %>% dplyr::distinct()   ) %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Una peque√±a tabla que es √∫til para realizar pruebas ‚Äî small_table","title":"Una peque√±a tabla que es √∫til para realizar pruebas ‚Äî small_table","text":"Esta es una peque√±a tabla con algunos tipos diferentes de columnas. Probablemente sea √∫til cuando se prueban las funciones desde pointblank. Las filas 9 y 10 son duplicados exactos. La columna c contiene dos valores NA.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Una peque√±a tabla que es √∫til para realizar pruebas ‚Äî small_table","text":"","code":"small_table"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Una peque√±a tabla que es √∫til para realizar pruebas ‚Äî small_table","text":"Un tibble con 13 filas y 8 variables: date_time Una columna de fecha y hora (de la clase POSIXct) con fechas que corresponden exactamente las de la columna date. Los valores de tiempo son algo aleatorios, pero todos los valores de 'segundos' son 00. date Una columna Date con fechas desde 2016-01-04 2016-01-30. Una columna integer con valores comprendidos entre 1 y 8. b Una columna de character con valores que se adhieren un patr√≥n com√∫n. c Una columna integer con valores comprendidos entre 2 y 9. Contiene dos valores NA. d Una columna num√©rica con valores que van desde 108 10000. e Una columna logical. f Una columna character con valores \"low\", \"mid\" y \"high\"","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Una peque√±a tabla que es √∫til para realizar pruebas ‚Äî small_table","text":"14-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Una peque√±a tabla que es √∫til para realizar pruebas ‚Äî small_table","text":"","code":"# Aqu√≠ hay un vistazo a los datos # disponibles en `small_table` dplyr::glimpse(small_table) #> Rows: 13 #> Columns: 8 #> $ date_time <dttm> 2016-01-04 11:00:00, 2016-01-04 00:32:00, 2016-01-05 13:32:‚Ä¶ #> $ date      <date> 2016-01-04, 2016-01-04, 2016-01-05, 2016-01-06, 2016-01-09,‚Ä¶ #> $ a         <int> 2, 3, 6, 2, 8, 4, 7, 4, 3, 3, 4, 2, 1 #> $ b         <chr> \"1-bcd-345\", \"5-egh-163\", \"8-kdg-938\", \"5-jdo-903\", \"3-ldm-0‚Ä¶ #> $ c         <dbl> 3, 8, 3, NA, 7, 4, 3, 2, 9, 9, 7, 8, NA #> $ d         <dbl> 3423.29, 9999.99, 2343.23, 3892.40, 283.94, 3291.03, 843.34,‚Ä¶ #> $ e         <lgl> TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, FAL‚Ä¶ #> $ f         <chr> \"high\", \"low\", \"high\", \"mid\", \"low\", \"mid\", \"high\", \"low\", \"‚Ä¶"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table_sqlite.html","id":null,"dir":"Reference","previous_headings":"","what":"Una versi√≥n SQLite del conjunto de datos small_table ‚Äî small_table_sqlite","title":"Una versi√≥n SQLite del conjunto de datos small_table ‚Äî small_table_sqlite","text":"La funci√≥n small_table_sqlite() crea una versi√≥n SQLite, tbl_dbi de la tabla small_table. Un requisito es la disponibilidad de los paquetes DBI y RSQLite. Estos paquetes se pueden instalar con install.packages(\"DBI\") y install.packages(\"RSQLite\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table_sqlite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Una versi√≥n SQLite del conjunto de datos small_table ‚Äî small_table_sqlite","text":"","code":"small_table_sqlite()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table_sqlite.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Una versi√≥n SQLite del conjunto de datos small_table ‚Äî small_table_sqlite","text":"14-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/small_table_sqlite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Una versi√≥n SQLite del conjunto de datos small_table ‚Äî small_table_sqlite","text":"","code":"# Utilice `small_table_sqlite()` # para crear una versi√≥n SQLite # de la tabla de la tabla # `small_table` # small_table_sqlite <- small_table_sqlite()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_highest.html","id":null,"dir":"Reference","previous_headings":"","what":"Un fn para info_snippet(): obtiene el valor m√°s alto de una columna ‚Äî snip_highest","title":"Un fn para info_snippet(): obtiene el valor m√°s alto de una columna ‚Äî snip_highest","text":"La funci√≥n snip_highest() puede utilizarse como una funci√≥n info_snippet() (es decir, proporcionada fn) para obtener el mayor valor num√©rico, temporal o valor alfab√©tico de una columna de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_highest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Un fn para info_snippet(): obtiene el valor m√°s alto de una columna ‚Äî snip_highest","text":"","code":"snip_highest(column)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_highest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Un fn para info_snippet(): obtiene el valor m√°s alto de una columna ‚Äî snip_highest","text":"column El nombre de la columna que contiene los valores de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_highest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Un fn para info_snippet(): obtiene el valor m√°s alto de una columna ‚Äî snip_highest","text":"Una f√≥rmula necesaria para el argumento fn de info_snippet().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_highest.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Un fn para info_snippet(): obtiene el valor m√°s alto de una columna ‚Äî snip_highest","text":"3-9","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_highest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Un fn para info_snippet(): obtiene el valor m√°s alto de una columna ‚Äî snip_highest","text":"","code":"# Generate an informant object, add # a snippet with `info_snippet()` # and `snip_highest()` (giving us a # method to get the highest value in # column `a`); define a location for # the snippet result in `{ }` and # then `incorporate()` the snippet # into the info text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%    info_columns(     columns = \"a\",     `Highest Value` = \"Highest value is {highest_a}.\"   ) %>%   info_snippet(     snippet_name = \"highest_a\",     fn = snip_highest(column = \"a\")   ) %>%   incorporate() #>  #> ‚îÄ‚îÄ Incorporation Started - there is a single snippet to process ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚úî Information gathered. #> ‚úî Snippets processed. #> ‚úî Information built. #>  #> ‚îÄ‚îÄ Incorporation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # We can print the `informant` object # to see the information report"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Un fn para info_snippet(): obtener una lista de categor√≠as de columnas ‚Äî snip_list","title":"Un fn para info_snippet(): obtener una lista de categor√≠as de columnas ‚Äî snip_list","text":"snip_list() function can used info_snippet() function (.e., provided fn) get catalog list table column. can limit items list limit value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Un fn para info_snippet(): obtener una lista de categor√≠as de columnas ‚Äî snip_list","text":"","code":"snip_list(   column,   limit = 5,   sorting = c(\"inorder\", \"infreq\", \"inseq\"),   reverse = FALSE,   sep = \",\",   and_or = NULL,   oxford = TRUE,   as_code = TRUE,   quot_str = NULL,   lang = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Un fn para info_snippet(): obtener una lista de categor√≠as de columnas ‚Äî snip_list","text":"column El nombre de la columna que contiene los valores de destino. limit limit items put generated list. returned text state remaining number items beyond limit. default, limit 5. sorting keyword used designate type sorting use list. three options \"inorder\" (default), \"infreq\", \"inseq\". \"inorder\", distinct items listed order firsts appear. Using \"infreq\" orders items decreasing frequency item. \"inseq\" option applies alphanumeric sorting distinct list items. reverse option reverse ordering list items. default, FALSE using TRUE reverse items applying limit. sep separator use list items. default, comma. and_or type conjunction use final penultimate list items (item length limit value). NULL (default) used, '' conjunction used. Alternatively, following keywords can used: \"\", \"\", empty string (conjunction ). oxford Whether use Oxford comma certain conditions. default, TRUE. as_code list item appear 'code font' (.e., monospaced text)? default TRUE. Using FALSE keeps list items font rest information report. quot_str option whether list items set double quotes. NULL (default), quotation marks mainly associated list items derived character factor values; numbers, dates, logical values quotation marks. can explicitly use quotations () either TRUE FALSE . lang language use joining words (and_or option) additional words generated list string. default, NULL use whichever lang setting available parent informant object (settable create_informant() lang argument). specified override, language options English (\"en\"), French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Un fn para info_snippet(): obtener una lista de categor√≠as de columnas ‚Äî snip_list","text":"Una f√≥rmula necesaria para el argumento fn de info_snippet().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_list.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Un fn para info_snippet(): obtener una lista de categor√≠as de columnas ‚Äî snip_list","text":"3-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Un fn para info_snippet(): obtener una lista de categor√≠as de columnas ‚Äî snip_list","text":"","code":"# Generate an informant object, add # a snippet with `info_snippet()` # and `snip_list()` (giving us a # method to get a distinct list of # column values for column `f`); # define a location for the snippet # result in `{ }` and then # `incorporate()` the snippet into # the info text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%    info_columns(     columns = \"f\",     `Items` = \"This column contains {values_f}.\"   ) %>%   info_snippet(     snippet_name = \"values_f\",     fn = snip_list(column = \"f\")   ) %>%   incorporate() #>  #> ‚îÄ‚îÄ Incorporation Started - there is a single snippet to process ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚úî Information gathered. #> ‚úî Snippets processed. #> ‚úî Information built. #>  #> ‚îÄ‚îÄ Incorporation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # We can print the `informant` object # to see the information report"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_lowest.html","id":null,"dir":"Reference","previous_headings":"","what":"Un fn para info_snippet(): obtener el valor m√°s bajo de una columna ‚Äî snip_lowest","title":"Un fn para info_snippet(): obtener el valor m√°s bajo de una columna ‚Äî snip_lowest","text":"snip_lowest() function can used info_snippet() function (.e., provided fn) get lowest numerical, time value, alphabetical value column target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_lowest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Un fn para info_snippet(): obtener el valor m√°s bajo de una columna ‚Äî snip_lowest","text":"","code":"snip_lowest(column)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_lowest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Un fn para info_snippet(): obtener el valor m√°s bajo de una columna ‚Äî snip_lowest","text":"column El nombre de la columna que contiene los valores de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_lowest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Un fn para info_snippet(): obtener el valor m√°s bajo de una columna ‚Äî snip_lowest","text":"Una f√≥rmula necesaria para el argumento fn de info_snippet().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_lowest.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Un fn para info_snippet(): obtener el valor m√°s bajo de una columna ‚Äî snip_lowest","text":"3-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_lowest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Un fn para info_snippet(): obtener el valor m√°s bajo de una columna ‚Äî snip_lowest","text":"","code":"# Generate an informant object, add # a snippet with `info_snippet()` # and `snip_lowest()` (giving us a # method to get the lowest value in # column `a`); define a location for # the snippet result in `{ }` and # then `incorporate()` the snippet # into the info text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%    info_columns(     columns = \"a\",     `Lowest Value` = \"Lowest value is {lowest_a}.\"   ) %>%   info_snippet(     snippet_name = \"lowest_a\",     fn = snip_lowest(column = \"a\")   ) %>%   incorporate() #>  #> ‚îÄ‚îÄ Incorporation Started - there is a single snippet to process ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚úî Information gathered. #> ‚úî Snippets processed. #> ‚úî Information built. #>  #> ‚îÄ‚îÄ Incorporation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # We can print the `informant` object # to see the information report"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Un fn para info_snippet(): obtener un resumen estad√≠stico en l√≠nea ‚Äî snip_stats","title":"Un fn para info_snippet(): obtener un resumen estad√≠stico en l√≠nea ‚Äî snip_stats","text":"snip_stats() function can used info_snippet() function (.e., provided fn) produce five- seven-number statistical summary. inline summary works well within paragraph text can help describing distribution numerical values column. given column, three different types inline statistical summaries can provided: five-number summary (\"5num\"): minimum, Q1, median, Q3, maximum seven-number summary (\"7num\"): P2, P9, Q1, median, Q3, P91, P98 Bowley's seven-figure summary (\"bowley\"): minimum, P10, Q1, median, Q3, P90, maximum","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Un fn para info_snippet(): obtener un resumen estad√≠stico en l√≠nea ‚Äî snip_stats","text":"","code":"snip_stats(column, type = c(\"5num\", \"7num\", \"bowley\"))"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Un fn para info_snippet(): obtener un resumen estad√≠stico en l√≠nea ‚Äî snip_stats","text":"column El nombre de la columna que contiene los valores de destino. type type summary. default, \"5num\" keyword used generate five-number summary. Two options provide seven-number summaries: \"7num\" \"bowley\".","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Un fn para info_snippet(): obtener un resumen estad√≠stico en l√≠nea ‚Äî snip_stats","text":"Una f√≥rmula necesaria para el argumento fn de info_snippet().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_stats.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Un fn para info_snippet(): obtener un resumen estad√≠stico en l√≠nea ‚Äî snip_stats","text":"3-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/snip_stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Un fn para info_snippet(): obtener un resumen estad√≠stico en l√≠nea ‚Äî snip_stats","text":"","code":"# Generate an informant object, add # a snippet with `info_snippet()` # and `snip_stats()` (giving us a # method to get some summary stats for # column `a`); define a location for # the snippet result in `{ }` and # then `incorporate()` the snippet # into the info text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Un ejemplo.\"   ) %>%    info_columns(     columns = \"a\",     `Stats` = \"Stats (fivenum): {stats_a}.\"   ) %>%   info_snippet(     snippet_name = \"stats_a\",     fn = snip_stats(column = \"a\")   ) %>%   incorporate() #>  #> ‚îÄ‚îÄ Incorporation Started - there is a single snippet to process ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚úî Information gathered. #> ‚úî Snippets processed. #> ‚úî Information built. #>  #> ‚îÄ‚îÄ Incorporation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # We can print the `informant` object # to see the information report"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":null,"dir":"Reference","previous_headings":"","what":"Realizar una validaci√≥n especializada con una funci√≥n definida por el usuario ‚Äî specially","title":"Realizar una validaci√≥n especializada con una funci√≥n definida por el usuario ‚Äî specially","text":"La funci√≥n de validaci√≥n specially() permite una validaci√≥n personalizada con una funci√≥n que usted proporciona. La principal condici√≥n para la funci√≥n proporcionada es que debe devolver un vector l√≥gico o una tabla donde la columna final sea l√≥gica. La funci√≥n operar√° sobre el objeto tabla o, como puede hacer lo que quiera, tambi√©n podr√≠a operar sobre otros tipos de objetos. Para ello, puede transformar la tabla de entrada en preconditions o inyectar all√≠ un objeto totalmente diferente. Durante la interrogaci√≥n, habr√° ninguna comprobaci√≥n para asegurar que los datos son un objeto de tabla.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Realizar una validaci√≥n especializada con una funci√≥n definida por el usuario ‚Äî specially","text":"","code":"specially(   x,   fn,   preconditions = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_specially(object, fn, preconditions = NULL, threshold = 1)  test_specially(object, fn, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Realizar una validaci√≥n especializada con una funci√≥n definida por el usuario ‚Äî specially","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). fn Una funci√≥n que realiza la validaci√≥n especializada de los datos. Debe devolver un vector l√≥gico o una tabla donde la √∫ltima columna es una columna l√≥gica. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Realizar una validaci√≥n especializada con una funci√≥n definida por el usuario ‚Äî specially","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Realizar una validaci√≥n especializada con una funci√≥n definida por el usuario ‚Äî specially","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que una validaci√≥n en particular requiera una columna calculada, alg√∫n filtrado de filas o la adici√≥n de columnas trav√©s de una combinaci√≥n, etc. Especialmente para un informe basado en agent, esto puede ser ventajoso ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realice ajustes menores en ella, seg√∫n sea necesario, lo largo del camino. Dentro de specially(), debido que esta funci√≥n es especial, habr√° comprobaci√≥n interna de si la salida basada en preconditions es una tabla. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar (por ejemplo, ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternativamente, se podr√≠a proporcionar una funci√≥n (por ejemplo, function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Realizar una validaci√≥n especializada con una funci√≥n definida por el usuario ‚Äî specially","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que es mejor producido por la funci√≥n action_levels(). Lea la documentaci√≥n de esa funci√≥n para obtener informaci√≥n sobre c√≥mo crear reacciones niveles de falla por encima del umbral en la validaci√≥n. La esencia b√°sica es que querr√° al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fallidas o un valor absoluto), menudo utilizando el argumento warn_at. Esto es especialmente cierto cuando x es un objeto de tabla porque, de lo contrario, sucede nada. Para las funciones de tipo col_vals_*(), usar action_levels(warn_at = 0.25) o action_levels(stop_at = 0.25) son buenas opciones dependiendo de la situaci√≥n (la primera produce una advertencia cuando una cuarta parte de la prueba total las unidades fallan, las otras stop()s en el mismo nivel de umbral).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Realizar una validaci√≥n especializada con una funci√≥n definida por el usuario ‚Äî specially","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Realizar una validaci√≥n especializada con una funci√≥n definida por el usuario ‚Äî specially","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando specially() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de specially() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos, ya que solo son necesarias las expresiones para los pasos de validaci√≥n. Los argumentos con valores predeterminados se escribir√°n en YAML cuando se use yaml_write() (aunque es aceptable incluirlos con sus valores predeterminados al generar el YAML por otros medios). Tambi√©n es posible obtener una vista previa de la transformaci√≥n de un agente YAML sin escribir en el disco usando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    specially(     fn = function(x) { ... },     preconditions = ~ . %>% dplyr::filter(a < 10),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),      label = \"El paso `specially()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - specially:     fn: function(x) { ... }     preconditions: ~. %>% dplyr::filter(a < 10)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `specially()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specially.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Realizar una validaci√≥n especializada con una funci√≥n definida por el usuario ‚Äî specially","text":"2-33","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specifications.html","id":null,"dir":"Reference","previous_headings":"","what":"Una tabla que contiene datos pertenecientes a varias especificaciones ‚Äî specifications","title":"Una tabla que contiene datos pertenecientes a varias especificaciones ‚Äî specifications","text":"La tabla specifications es √∫til para probar las funciones col_vals_within_spec(), test_col_vals_within_spec() y expect_col_vals_within_spec(). Para cada columna, que contiene valores de caracteres para diferentes especificaciones, las filas 1-5 contienen valores v√°lidos, la 6¬™ fila es un valor NA, y los dos √∫ltimos valores (filas 7 y 8) son inv√°lidos. Las diferentes palabras clave de especificaci√≥n (spec) se aplican cada una de las columnas cuando al validar con cualquiera de las funciones mencionadas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specifications.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Una tabla que contiene datos pertenecientes a varias especificaciones ‚Äî specifications","text":"","code":"specifications"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specifications.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Una tabla que contiene datos pertenecientes a varias especificaciones ‚Äî specifications","text":"tibble 8 rows 12 variables: isbn_numbers ISBN-13 numbers; can validated \"isbn\" specification. vin_numbers VIN numbers (identifiers motor vehicles); can validated \"vin\" specification. zip_codes Postal codes U.S.; can validated \"postal[USA]\" specification \"zip\" alias. credit_card_numbers Credit card numbers; can validated \"credit_card\" specification \"cc\" alias. iban_austria IBAN numbers Austrian accounts; can validated \"iban[AUT]\" specification. swift_numbers Swift-BIC numbers; can validated \"swift\" specification. phone_numbers Phone numbers; can validated \"phone\" specification. email_addresses Email addresses; can validated \"email\" specification. urls URLs; can validated  \"url\" specification. ipv4_addresses IPv4 addresses; can validated \"ipv4\" specification ipv6_addresses IPv6 addresses; can validated \"ipv6\" specification mac_addresses MAC addresses; can validated \"mac\" specification","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specifications.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Una tabla que contiene datos pertenecientes a varias especificaciones ‚Äî specifications","text":"14-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/specifications.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Una tabla que contiene datos pertenecientes a varias especificaciones ‚Äî specifications","text":"","code":"# He aqu√≠ un vistazo a los datos # disponibles en `specifications` dplyr::glimpse(specifications) #> Rows: 8 #> Columns: 12 #> $ isbn_numbers        <chr> \"978 1 85715 201 2\", \"978-1-84159-362-3\", \"978 1 8‚Ä¶ #> $ vin_numbers         <chr> \"4UZAANDH85CV12329\", \"JM1BL1S59A1134659\", \"1GCEK14‚Ä¶ #> $ zip_codes           <chr> \"99553\", \"36264\", \"71660\", \"85225\", \"90309\", NA, \"‚Ä¶ #> $ credit_card_numbers <chr> \"340000000000009\", \"378734493671000\", \"67034444444‚Ä¶ #> $ iban_austria        <chr> \"AT582774098454337653\", \"AT220332087576467472\", \"A‚Ä¶ #> $ swift_numbers       <chr> \"RBOSGGSX\", \"RZTIAT22263\", \"BCEELULL\", \"MARKDEFF\",‚Ä¶ #> $ phone_numbers       <chr> \"+5-555-555-5555\", \"+5 555 555 5555\", \"+5.555.555.‚Ä¶ #> $ email_addresses     <chr> \"test@test.com\", \"mail+mail@example.com\", \"mail.em‚Ä¶ #> $ urls                <chr> \"http://foo.com/blah_blah\", \"http://foo.com/blah_b‚Ä¶ #> $ ipv4_addresses      <chr> \"93.184.220.20\", \"161.148.172.130\", \"161.148.172.1‚Ä¶ #> $ ipv6_addresses      <chr> \"2001:0db8:0000:85a3:0000:0000:ac1f:8001\", \"2001:d‚Ä¶ #> $ mac_addresses       <chr> \"01-2d-4c-ef-89-ab\", \"01-2D-4C-EF-89-AB\", \"01:2d:4‚Ä¶"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_body.html","id":null,"dir":"Reference","previous_headings":"","what":"Proporcione componentes simples del cuerpo del mensaje de correo electr√≥nico:\n","title":"Proporcione componentes simples del cuerpo del mensaje de correo electr√≥nico:\n","text":"La funci√≥n stock_msg_body() simplemente proporciona un texto de stock para un mensaje de correo electr√≥nico enviado trav√©s de email_blast() u obtenido como un objeto independiente trav√©s de email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_body.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proporcione componentes simples del cuerpo del mensaje de correo electr√≥nico:\n","text":"","code":"stock_msg_body()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_body.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Proporcione componentes simples del cuerpo del mensaje de correo electr√≥nico:\n","text":"Texto adecuado para el argumento msg_body de email_blast() y email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_body.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Proporcione componentes simples del cuerpo del mensaje de correo electr√≥nico:\n","text":"4-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_footer.html","id":null,"dir":"Reference","previous_headings":"","what":"Proporcione componentes simples del cuerpo del mensaje de correo electr√≥nico:\n","title":"Proporcione componentes simples del cuerpo del mensaje de correo electr√≥nico:\n","text":"La funci√≥n stock_msg_footer() simplemente proporciona un texto de stock para un mensaje de correo electr√≥nico enviado trav√©s de email_blast() u obtenido como un objeto independiente trav√©s de email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_footer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Proporcione componentes simples del cuerpo del mensaje de correo electr√≥nico:\n","text":"","code":"stock_msg_footer()"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_footer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Proporcione componentes simples del cuerpo del mensaje de correo electr√≥nico:\n","text":"Texto adecuado para el argumento msg_footer de email_blast() y email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stock_msg_footer.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Proporcione componentes simples del cuerpo del mensaje de correo electr√≥nico:\n","text":"4-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stop_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"La pr√≥xima generaci√≥n de funciones de tipo stopifnot(): stop_if_not() ‚Äî stop_if_not","title":"La pr√≥xima generaci√≥n de funciones de tipo stopifnot(): stop_if_not() ‚Äî stop_if_not","text":"stopifnot() twist: works well standalone, replacement stopifnot() also customized use validation checks R Markdown documents pointblank loaded. Using stop_if_not() code chunk validate = TRUE option set yield correct reporting successes failures whereas stopifnot() .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stop_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"La pr√≥xima generaci√≥n de funciones de tipo stopifnot(): stop_if_not() ‚Äî stop_if_not","text":"","code":"stop_if_not(...)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stop_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"La pr√≥xima generaci√≥n de funciones de tipo stopifnot(): stop_if_not() ‚Äî stop_if_not","text":"... R expressions evaluate (logical vector ) TRUE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stop_if_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"La pr√≥xima generaci√≥n de funciones de tipo stopifnot(): stop_if_not() ‚Äî stop_if_not","text":"NULL statements ... TRUE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stop_if_not.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"La pr√≥xima generaci√≥n de funciones de tipo stopifnot(): stop_if_not() ‚Äî stop_if_not","text":"13-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/stop_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"La pr√≥xima generaci√≥n de funciones de tipo stopifnot(): stop_if_not() ‚Äî stop_if_not","text":"","code":"# This checks whether the number of # rows in `small_table` is greater # than `10` stop_if_not(nrow(small_table) > 10) #> NULL  # This will stop for sure: there # isn't a `time` column in `small_table` # (but there are the `date_time` and # `date` columns) # stop_if_not(\"time\" %in% colnames(small_table))  # You're not bound to using tabular # data here, any statements that # evaluate to logical vectors will work stop_if_not(1 < 20:25 - 18) #> NULL"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_get.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtenga una mesa materializada a trav√©s de una tienda de mesa ‚Äî tbl_get","title":"Obtenga una mesa materializada a trav√©s de una tienda de mesa ‚Äî tbl_get","text":"tbl_get() function gives us means materialize table entry table store (.e., table-prep formula unique name). table store used can form tbl_store object (created tbl_store() function) -disk YAML representation table store (created using yaml_write() tbl_store object). want table-prep formula table store use value read_fn (create_agent(), create_informant(), set_read_fn()), look tbl_source() function.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_get.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtenga una mesa materializada a trav√©s de una tienda de mesa ‚Äî tbl_get","text":"","code":"tbl_get(tbl, store = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_get.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtenga una mesa materializada a trav√©s de una tienda de mesa ‚Äî tbl_get","text":"tbl table retrieve table store. table identified name (e.g., tbl = \"large_table\") supplying reference using subset ($) tbl_store object (e.g., tbl = store$large_table). using latter method nothing needs supplied store. store Either table store object created tbl_store() function path table store YAML file created yaml_write().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_get.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtenga una mesa materializada a trav√©s de una tienda de mesa ‚Äî tbl_get","text":"table object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_get.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtenga una mesa materializada a trav√©s de una tienda de mesa ‚Äî tbl_get","text":"1-10","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_get.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtenga una mesa materializada a trav√©s de una tienda de mesa ‚Äî tbl_get","text":"","code":"if (interactive()) {  # Define a `tbl_store` object by adding # table-prep formulas in `tbl_store()` tbls <-    tbl_store(     small_table_duck ~ db_tbl(       table = small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     ~ db_tbl(       table = \"rna\",       dbname = \"pfmegrnargs\",       dbtype = \"postgres\",       host = \"hh-pgsql-public.ebi.ac.uk\",       port = 5432,       user = I(\"reader\"),       password = I(\"NWDMCE5xdipIjRrp\")     ),     all_revenue ~ db_tbl(       table = file_tbl(         file = from_github(           file = \"all_revenue_large.rds\",           repo = \"rich-iannone/intendo\",           subdir = \"data-large\"         )       ),       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     sml_table ~ pointblank::small_table   )  # Once this object is available, you can # check that the table of interest is # produced to your specification tbl_get(   tbl = \"small_table_duck\",   store = tbls )  # An alternative method for getting the # same table materialized is by using `$` # to get the formula of choice from `tbls` tbls$small_table_duck %>% tbl_get()  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":null,"dir":"Reference","previous_headings":"","what":"¬øLa tabla de destino coincide con una tabla de comparaci√≥n? ‚Äî tbl_match","title":"¬øLa tabla de destino coincide con una tabla de comparaci√≥n? ‚Äî tbl_match","text":"La funci√≥n de validaci√≥n tbl_match(), la funci√≥n de expectativa expect_tbl_match() y la funci√≥n de prueba test_tbl_match() comprueban si la composici√≥n de la tabla de destino coincide con la de una tabla de comparaci√≥n. La funci√≥n de validaci√≥n se puede usar directamente en una tabla de datos o con un objeto agent (t√©cnicamente, un objeto ptblank_agent) mientras que las funciones de expectativa y prueba solo se pueden usar con una tabla de datos. Los tipos de tablas de datos que se pueden utilizar incluyen marcos de datos, tibbles, tablas de base de datos (tbl_dbi) y Spark DataFrames (tbl_spark). Como paso de validaci√≥n o como expectativa, hay una sola unidad de prueba que depende de si las dos tablas son las son iguales (despu√©s de haber aplicado cualquier preconditions).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"¬øLa tabla de destino coincide con una tabla de comparaci√≥n? ‚Äî tbl_match","text":"","code":"tbl_match(   x,   tbl_compare,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_tbl_match(object, tbl_compare, preconditions = NULL, threshold = 1)  test_tbl_match(object, tbl_compare, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"¬øLa tabla de destino coincide con una tabla de comparaci√≥n? ‚Äî tbl_match","text":"x Un data.frame, tibble (tbl_df o tbl_dbi), Spark DataFrame (tbl_spark), o un agent objeto de clase ptblank_agent que se crea con create_agent(). tbl_compare Una tabla para comparar con la tabla de destino. Esto puede ser un objeto de tabla, una f√≥rmula de preparaci√≥n de tabla. Puede ser un objeto de tabla como un marco de datos, un tibble, un objeto tbl_dbi o un objeto tbl_spark. Como alternativa, se puede utilizar una f√≥rmula de preparaci√≥n de tabla (~ <c√≥digo de lectura de tabla>) o una funci√≥n (function() <c√≥digo de lectura de tabla>) para leer perezosamente la tabla en el momento de la interrogaci√≥n. preconditions Una expresi√≥n opcional para mutar la tabla de entrada antes de continuar con la validaci√≥n. Esto se puede proporcionar como una f√≥rmula R unilateral usando un ~ inicial (por ejemplo, ~ . %>% dplyr::mutate(col = col + 10) o como una funci√≥n (por ejemplo, function (x) dplyr::mutate(x, col = col + 10). Consulte la secci√≥n Preconditions para obtener m√°s informaci√≥n. segments Una expresi√≥n opcional o un conjunto de expresiones (contenidas en una lista) que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Consulte la secci√≥n Segments para obtener m√°s detalles sobre esto. actions Una lista que contiene los niveles de umbral para que el paso de validaci√≥n pueda reaccionar en consecuencia al superar los niveles establecidos. Esto se crear√° con la funci√≥n auxiliar action_levels(). step_id Uno o m√°s identificadores opcionales para los pasos de validaci√≥n √∫nicos o m√∫ltiples generados al llamar una funci√≥n de validaci√≥n. El uso de ID de pasos sirve para distinguir los pasos de validaci√≥n entre s√≠ y brinda la oportunidad de proporcionar una etiqueta m√°s significativa en comparaci√≥n con el √≠ndice de pasos. De forma predeterminada, es NULL, y pointblank generar√° autom√°ticamente el valor de ID de paso (basado en el √≠ndice de paso) en este caso. Se pueden proporcionar uno o m√°s valores, y el n√∫mero exacto de valores de ID debe (1) coincidir con el n√∫mero de pasos de validaci√≥n que producir√° la llamada la funci√≥n de validaci√≥n (influenciado por el n√∫mero de columns proporcionadas), (2) ser un ID cadena utilizada en ning√∫n paso de validaci√≥n anterior, y (3) ser un vector con valores √∫nicos. label Una etiqueta opcional para el paso de validaci√≥n. Esta etiqueta aparece en el informe del agent y, para una mejor apariencia, debe ser breve. brief Una descripci√≥n opcional basada en texto para el paso de validaci√≥n. Si se proporciona nada aqu√≠, el objeto agent genera un autobrief, utilizando el lenguaje proporcionado en el argumento lang de create_agent() (que por defecto es \"en\" o ingl√©s). El autobrief incorpora detalles del paso de validaci√≥n, por lo que menudo es la opci√≥n preferida en la mayor√≠a de los casos (donde un label podr√≠a ser m√°s adecuada para describir sucintamente la validaci√≥n). active Un valor l√≥gico que indica si el paso de validaci√≥n debe estar activo. Si la funci√≥n de validaci√≥n est√° trabajando con un objeto agent, FALSE har√° que el paso de validaci√≥n est√© inactivo (a√∫n informando su presencia y manteniendo los √≠ndices de los pasos sin cambios). Si la funci√≥n de validaci√≥n operar√° directamente en los datos (sin participaci√≥n de agent), entonces cualquier paso con active = FALSE simplemente pasar√° los datos sin validaci√≥n alguna. Aparte de un vector l√≥gico, una f√≥rmula R unilateral que usa un ~ inicial se puede usar con . (que sirve como la tabla de datos de entrada) para evaluar un solo valor l√≥gico. Con este enfoque, la funci√≥n pointblank has_columns() se puede utilizar para determinar si se debe activar un paso de validaci√≥n sobre la base de una o m√°s columnas existentes en la tabla (por ejemplo, ~ . %>% has_columns(vars(d, e))). El valor predeterminado de active es TRUE. object Un data.frame, tibble (tbl_df o tbl_dbi) o Spark DataFrame (tbl_spark) que sirve como tabla de destino para la funci√≥n de expectativa o la funci√≥n de prueba. threshold Un valor de umbral de falla simple para usar con las variantes de funci√≥n expectativa (expect_) y prueba (test_). De forma predeterminada, se establece en 1, lo que significa que cualquier unidad de falla en la validaci√≥n de datos da como resultado una falla general de la prueba. Los n√∫meros enteros m√°s all√° de 1 indican que cualquier unidad defectuosa hasta ese valor de umbral absoluto dar√° como resultado una thatthat prueba o eval√∫e como TRUE. Asimismo, los valores fraccionarios (entre 0 y 1) act√∫an como un umbral de falla proporcional, donde 0.15 significa que el 15 por ciento de las unidades de prueba que fallan dan como resultado una falla general de la prueba.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"¬øLa tabla de destino coincide con una tabla de comparaci√≥n? ‚Äî tbl_match","text":"Para la funci√≥n de validaci√≥n, el valor de retorno es un objeto ptblank_agent o un objeto de tabla (dependiendo de si se pas√≥ un objeto agent o una tabla x). La funci√≥n de expectativa devuelve invisiblemente su entrada pero, en el contexto de los datos de prueba, la funci√≥n se llama principalmente por sus posibles efectos secundarios (por ejemplo, falla de se√±alizaci√≥n). La funci√≥n de prueba devuelve un valor l√≥gico.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"¬øLa tabla de destino coincide con una tabla de comparaci√≥n? ‚Äî tbl_match","text":"Proporcionar expresiones como preconditions significa que pointblank preprocesar√° la tabla de destino durante la interrogaci√≥n como paso preparatorio. Puede suceder que esta validaci√≥n en particular requiera alguna operaci√≥n en la tabla de destino antes de que se lleve cabo la comparaci√≥n. El uso de preconditions puede ser √∫til en ocasiones, ya que podemos desarrollar un gran plan de validaci√≥n con una sola tabla de destino y realizarle peque√±os ajustes, seg√∫n sea necesario, lo largo del camino. La mutaci√≥n de la tabla est√° totalmente aislada en el alcance de los pasos de validaci√≥n en los que se utilizan las preconditions. Aqu√≠ se sugiere usar el c√≥digo dplyr ya que las declaraciones se pueden traducir SQL si es necesario (es decir, si la tabla de destino reside en una base de datos). El c√≥digo se proporciona m√°s f√°cilmente como una f√≥rmula R unilateral (utilizando un ~ inicial). En la representaci√≥n de la f√≥rmula, el . sirve como la tabla de datos de entrada que se va transformar. Como alternativa, se puede suministrar una funci√≥n.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"segmentos","dir":"Reference","previous_headings":"","what":"Segmentos","title":"¬øLa tabla de destino coincide con una tabla de comparaci√≥n? ‚Äî tbl_match","text":"Al usar el argumento segments, es posible definir una validaci√≥n particular con segmentos (o porciones de fila) de la tabla de destino. Una expresi√≥n opcional o un conjunto de expresiones que sirven para segmentar la tabla de destino por valores de columna. Cada expresi√≥n se puede dar de una de dos maneras: (1) como nombres de columna, o (2) como una f√≥rmula de dos lados donde el LHS contiene un nombre de columna y el RHS contiene los valores de columna para segmentar. Como ejemplo del primer tipo de expresi√≥n que se puede utilizar, vars(a_column) segmentar√° la tabla de destino en la forma en que est√©n presentes muchos valores √∫nicos en la columna llamada a_column. Esto es excelente si cada valor √∫nico en una columna en particular (como diferentes ubicaciones o diferentes fechas) requiere su propia validaci√≥n repetida. Con una f√≥rmula, podemos ser m√°s selectivos con los valores de columna que se deben usar para la segmentaci√≥n. El uso de a_column ~ c(\"group_1\", \"group_2\") intentar√° obtener dos segmentos donde uno es una porci√≥n de datos donde el valor \"group_1\" existe en la columna llamada \"a_column\", y el otro es un segmento donde existe \"group_2\" en la misma columna. Cada grupo de filas resuelto partir de la f√≥rmula dar√° como resultado un paso de validaci√≥n independiente. La segmentaci√≥n siempre ocurrir√° despu√©s de que se apliquen las preconditions (es decir, declaraciones que mutan la tabla de destino), si las hay. Con este tipo de combinaci√≥n, es posible generar etiquetas para la segmentaci√≥n usando una expresi√≥n para preconditions y hacer referencia esas etiquetas en segments sin tener que generar una versi√≥n separada de la tabla de destino.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"¬øLa tabla de destino coincide con una tabla de comparaci√≥n? ‚Äî tbl_match","text":"menudo, querremos especificar actions para la validaci√≥n. Este argumento, presente en cada funci√≥n de validaci√≥n, toma un objeto de lista especialmente dise√±ado que se produce mejor con la funci√≥n action_levels(). Lee esa funci√≥n documentaci√≥n para la verdad sobre c√≥mo crear reacciones por encima del umbral niveles de falla en la validaci√≥n. La esencia b√°sica es que querr√°s al menos un nivel de umbral √∫nico (especificado como la fracci√≥n de unidades de prueba fall√≥, o un valor absoluto), menudo usando el argumento warn_at. Utilizando action_levels(warn_at = 1) o action_levels(stop_at = 1) son buenas opciones dependiendo de la situaci√≥n (el primero produce una advertencia, el otro stop()).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"¬øLa tabla de destino coincide con una tabla de comparaci√≥n? ‚Äî tbl_match","text":"¬øQuiere describir este paso de validaci√≥n con alg√∫n detalle? Tenga en cuenta que esto s√≥lo es √∫til si x es un objeto agent. Si ese es el caso, use un texto brief que se ajuste la situaci√≥n. se preocupe si quiere hacerlo. Un autobrief se activa cuando brief = NULL y el texto luego se generar√° autom√°ticamente.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"¬øLa tabla de destino coincide con una tabla de comparaci√≥n? ‚Äî tbl_match","text":"Se puede escribir un agente pointblank en YAML con yaml_write() y el YAML resultante se puede usar para regenerar un agente (con yaml_read_agent()) o interrogar la tabla de destino (trav√©s de yaml_agent_interrogate()). Cuando tbl_match() se representa en YAML (bajo la clave de nivel superior steps como un miembro de la lista), la sintaxis sigue de cerca la firma de la funci√≥n de validaci√≥n. continuaci√≥n se muestra un ejemplo de c√≥mo una llamada compleja de tbl_match() como paso de validaci√≥n se expresa en c√≥digo R y en la representaci√≥n YAML correspondiente. En la pr√°ctica, ambos ser√°n menudo m√°s cortos. Los argumentos con valores por defecto se escribir√°n en YAML cuando se utilice yaml_write() (aunque es aceptable incluirlos con su valor por defecto al generar el YAML por otros medios). Tambi√©n es posible previsualizar la transformaci√≥n de un agente YAML sin necesidad de escribirlo en el disco, utilizando la funci√≥n yaml_agent_string().","code":"# C√≥digo R agent %>%    tbl_match(     tbl_compare = ~ file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       ),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"El paso `tbl_match()`.\",     active = FALSE   )  # Representaci√≥n YAML steps: - tbl_match:     tbl_compare: ~ file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       )     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: El paso `tbl_match()`.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"¬øLa tabla de destino coincide con una tabla de comparaci√≥n? ‚Äî tbl_match","text":"2-32","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"¬øLa tabla de destino coincide con una tabla de comparaci√≥n? ‚Äî tbl_match","text":"","code":"# Cree una tabla simple con tres # columnas y cuatro filas de valores tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5),     b = c(7, 1, 0, 0),     c = c(1, 1, 1, 3)   )  # Crear una segunda tabla que sea # igual a `tbl`. tbl_2 <-   dplyr::tibble(     a = c(5, 7, 6, 5),     b = c(7, 1, 0, 0),     c = c(1, 1, 1, 3)   )  # Validar que la tabla de destino # (`tbl`) y la tabla de comparaci√≥n # (`tbl_2`) son equivalentes en # t√©rminos de contenido agent <-   create_agent(tbl = tbl) %>%   tbl_match(tbl_compare = tbl_2) %>%   interrogate()  # Determine si esta validaci√≥n # pas√≥ usando `all_passed()` all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_source.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtenga una f√≥rmula de preparaci√≥n de mesa en una tienda de mesa ‚Äî tbl_source","title":"Obtenga una f√≥rmula de preparaci√≥n de mesa en una tienda de mesa ‚Äî tbl_source","text":"La funci√≥n tbl_source() proporciona un medio conveniente para acceder una f√≥rmula de preparaci√≥n de tablas desde un objeto tbl_store o un archivo YAML de almacenamiento de tablas (que puede ser creado con la funci√≥n yaml_write()). Una llamada tbl_source() es m√°s √∫til como entrada al argumento read_fn de create_agent(), create_informant(), o set_read_fn(). Si necesita obtener la tabla propiamente dicha (que se genera trav√©s de la f√≥rmula f√≥rmula de preparaci√≥n de la tabla), se debe utilizar la funci√≥n tbl_get() para ello.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_source.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtenga una f√≥rmula de preparaci√≥n de mesa en una tienda de mesa ‚Äî tbl_source","text":"","code":"tbl_source(tbl, store = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_source.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtenga una f√≥rmula de preparaci√≥n de mesa en una tienda de mesa ‚Äî tbl_source","text":"tbl El nombre de la tabla asociado una f√≥rmula de preparaci√≥n de la tabla. Forma parte de la tabla store. Esta tabla puede identificarse por su nombre (por ejemplo, tbl = \"large_table\") o proporcionando una referencia utilizando un subconjunto (con $) del objeto tbl_store (por ejemplo, tbl = store$large_table). Si se utiliza este √∫ltimo m√©todo, es necesario suministrar nada store. store O bien un objeto de almac√©n de tablas creado por la funci√≥n tbl_store() o una ruta un archivo YAML del almac√©n de tablas creado por yaml_write().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_source.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtenga una f√≥rmula de preparaci√≥n de mesa en una tienda de mesa ‚Äî tbl_source","text":"Una f√≥rmula de preparaci√≥n de la tabla.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_source.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtenga una f√≥rmula de preparaci√≥n de mesa en una tienda de mesa ‚Äî tbl_source","text":"1-9","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_source.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtenga una f√≥rmula de preparaci√≥n de mesa en una tienda de mesa ‚Äî tbl_source","text":"","code":"if (interactive()) {  # Vamos a crear un objeto `tbl_store` # d√°ndole dos f√≥rmulas de preparaci√≥n # de la tabla a `tbl_store()` tbls <-    tbl_store(     small_table_duck ~ db_tbl(       table = small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     sml_table ~ pointblank::small_table   )  # Podemos pasar una f√≥rmula de # preparaci√≥n de la tabla a # `create_agent()` e interrogar la # tabla poco despu√©s agent <-    create_agent(     read_fn = ~ tbl_source(\"sml_table\", tbls),     label = \"An example that uses a table store.\",     actions = action_levels(warn_at = 0.10)   ) %>%    col_exists(vars(date, date_time)) %>%   interrogate()  # Tanto el objeto `tbl_store` como el # objeto `agent` pueden ser transformados # a YAML con la funci√≥n `yaml_write()`.  # Esto escribe el archivo `tbl_store.yml` # por defecto (pero un nombre diferente # podr√≠a usarse) yaml_write(tbls)  # Modifiquemos el `read_fn` del agente # para que apunte a la representaci√≥n # YAML del `tbl_store`. agent <-   agent %>%    set_read_fn(     ~ tbl_source(         tbl = \"sml_table\",         store = \"tbl_store.yml\"       )   )  # Entonces podemos escribir el agente # en un archivo YAML (escribe en # `agent-sml_table.yml` por defecto) yaml_write(agent)  # Ahora que ambos est√°n en este # formato en el disco se puede hacer # una interrogaci√≥n accediendo a el # agente YAML agent <-   yaml_agent_interrogate(     filename = \"agent-sml_table.yml\"   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":null,"dir":"Reference","previous_headings":"","what":"Definir un almac√©n de tablas con f√≥rmulas de preparaci√≥n de tablas: un ","title":"Definir un almac√©n de tablas con f√≥rmulas de preparaci√≥n de tablas: un ","text":"Puede ser √∫til configurar todas las fuentes de datos que necesites y s√≥lo extraerlas cuando sea necesario. Esta configuraci√≥n por adelantado con tbl_store() nos permite definir los m√©todos para obtener datos tabulares de fuentes mixtas (por ejemplo, tablas de bases de datos, tablas generadas partir de archivos planos, etc.) y proporcionar nombres para estos procedimientos de preparaci√≥n de datos. Entonces tenemos una forma conveniente de acceder las tablas materializadas con tbl_get(), o, las f√≥rmulas de preparaci√≥n de tablas con tbl_source(). Las f√≥rmulas table-prep pueden ser tan simples como obtener una tabla de una ubicaci√≥n, o, puede involucrar tanta mutaci√≥n como sea necesaria (imagine obtener varias variaciones mutadas de la misma tabla fuente, generar una tabla desde m√∫ltiples fuentes, o pre-filtrar una tabla de la base de datos de acuerdo al tiempo del sistema). Otro aspecto agradable de organizar las f√≥rmulas de preparaci√≥n de tablas en un solo objeto es suministrarlo al argumento read_fn de create_agent() o create_informant() mediante la notaci√≥n $ (por ejemplo, create_agent(read_fn = <tbl_store>$<nombre>)) o con tbl_source() (por ejemplo, create_agent(read_fn = ~ tbl_source(\"<nombre>\", <tbl_store>))).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Definir un almac√©n de tablas con f√≥rmulas de preparaci√≥n de tablas: un ","text":"","code":"tbl_store(..., .list = list2(...))"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Definir un almac√©n de tablas con f√≥rmulas de preparaci√≥n de tablas: un ","text":"... Expresiones que contienen f√≥rmulas de preparaci√≥n de tablas y nombres de tablas para la recuperaci√≥n de datos. Deben utilizarse f√≥rmulas de dos lados (por ejemplo, <LHS> ~ <RHS>), donde el lado izquierdo es un nombre dado y el derecho es la parte que se utiliza para obtener la tabla. .list Permite el uso de una lista como alternativa de entrada ....","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Definir un almac√©n de tablas con f√≥rmulas de preparaci√≥n de tablas: un ","text":"Un objeto tbl_store que contiene f√≥rmulas de preparaci√≥n de tablas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Definir un almac√©n de tablas con f√≥rmulas de preparaci√≥n de tablas: un ","text":"Un pointblank tbl_store se puede escribir en YAML con yaml_write() y el YAML resultante se puede utilizar de varias maneras. El escenario ideal es tener agentes e informantes pointblank tambi√©n en forma YAML. De esta manera el agente y el informante pueden referirse la tabla de almacenamiento YAML (trav√©s de tbl_source()), y, el procesamiento de ambos agentes e informantes puede realizarse con yaml_agent_interrogate() y yaml_informant_incorporate(). Con el siguiente c√≥digo de R, se genera un almac√©n de tablas con dos f√≥rmulas de preparaci√≥n de tablas y se escribe en YAML (si se da un nombre de archivo, el YAML se escribe en \"tbl_store.yml\"). Esto es √∫til cuando se quiere obtener tiradas frescas de datos preparados de una fuente materializada en una sesi√≥n de R (con la funci√≥n tbl_get(). Por ejemplo, la tabla sml_table_high puede obtenerse utilizando tbl_get(\"sml_table_high\", \"tbl_store.yml\"). Para conseguir que un agente compruebe estos datos preparados peri√≥dicamente, ser√° √∫til el siguiente ejemplo con tbl_source(): Ahora, siempre que la tabla sml_table_high necesite ser validada, se puede hacer con yaml_agent_interrogate() (por ejemplo, yaml_agent_interrogate(\"agent-sml_table_high.yml\")).","code":"# C√≥digo R para generar el archivo \"tbl_store.yml\" tbl_store(   tbl_duckdb ~ db_tbl(small_table, dbname = \":memory:\", dbtype = \"duckdb\"),   sml_table_high ~ small_table %>% dplyr::filter(f == \"high\") ) %>%   yaml_write()  # Representaci√≥n YAML (\"tbl_store.yml\") tbls:   tbl_duckdb: ~ db_tbl(small_table, dbname = \":memory:\", dbtype = \"duckdb\")   sml_table_high: ~ small_table %>% dplyr::filter(f == \"high\") # Generar un objeto agente que compruebe # `sml_table_high`, escribirlo en YAML create_agent(   read_fn = ~ tbl_source(\"sml_table_high\", \"tbl_store.yml\"),   label = \"An example that uses a table store.\",   actions = action_levels(warn_at = 0.10) ) %>%    col_exists(vars(date, date_time)) %>%   write_yaml()    # Representaci√≥n YAML (\"agent-sml_table_high.yml\") read_fn: ~ tbl_source(\"sml_table_high\", \"tbl_store.yml\") tbl_name: sml_table_high label: An example that uses a table store. actions:   warn_fraction: 0.1 locale: en steps:   - col_exists:     columns: vars(date, date_time)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Definir un almac√©n de tablas con f√≥rmulas de preparaci√≥n de tablas: un ","text":"1-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tbl_store.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Definir un almac√©n de tablas con f√≥rmulas de preparaci√≥n de tablas: un ","text":"","code":"if (interactive()) {  # Definir un objeto `tbl_store` a√±adiendo # f√≥rmulas de preparaci√≥n de tablas # dentro de la `tbl_store()` llamada tbls <-    tbl_store(     small_table_duck ~ db_tbl(       table = small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     ~ db_tbl(       table = \"rna\",       dbname = \"pfmegrnargs\",       dbtype = \"postgres\",       host = \"hh-pgsql-public.ebi.ac.uk\",       port = 5432,       user = I(\"reader\"),       password = I(\"NWDMCE5xdipIjRrp\")     ),     all_revenue ~ db_tbl(       table = file_tbl(         file = from_github(           file = \"all_revenue_large.rds\",           repo = \"rich-iannone/intendo\",           subdir = \"data-large\"         )       ),       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     sml_table ~ pointblank::small_table   )  # Una vez que este objeto est√° disponible, # se puede comprobar que la tabla de # inter√©s se produce a su especificaci√≥n # con la funci√≥n `tbl_get()`. tbl_get(   tbl = \"small_table_duck\",   store = tbls )  # Otra forma m√°s sencilla de obtener la # misma tabla materializada es utilizando # `$` para obtener la entrada de # elecci√≥n para `tbl_get()`. tbls$small_table_duck %>% tbl_get()  # La creaci√≥n de un agente es f√°cil # cuando todas las f√≥rmulas de # preparaci√≥n de tablas est√°n # encapsuladas en un objeto `tbl_store`; # utilice la notaci√≥n `$` para pasar el # procedimiento apropiado para leer una # tabla al argumento `read_fn` agent_1 <-   create_agent(     read_fn = tbls$small_table_duck   )    # Existen otras formas de utilizar el # almac√©n de tablas para asignar una # tabla de destino a un agente, como # el uso de la funci√≥n `tbl_source()` agent_2 <-   create_agent(     read_fn = ~ tbl_source(       tbl = \"small_table_duck\",       store = tbls       )   )  # El almac√©n de tablas puede ser # trasladado a YAML con `yaml_write` # y la llamada `tbl_source()` podr√≠a # entonces referirse a ese almac√©n # de tablas en disco; hagamos esa # conversi√≥n a YAML yaml_write(tbls)  # Lo anterior escribe el archivo # `tbl_store.yml` (al no # proporcionar un `filename` se # elige este nombre de archivo por # defecto); a continuaci√≥n, modifica # el `tbl_source()` para que `store` # haga referencia al archivo YAML  agent_3 <-   create_agent(     read_fn = ~ tbl_source(       tbl = \"small_table_duck\",       store = \"tbl_store.yml\"     )   )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_string_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: obtenga una tabla de resumen para columnas de cadena ‚Äî tt_string_info","title":"Table Transformer: obtenga una tabla de resumen para columnas de cadena ‚Äî tt_string_info","text":"table object, can produce summary table scoped string-based columns. output summary table leading column called \".param.\" labels three rows, corresponding following pieces information pertaining string length: Mean String Length (\"length_mean\") Minimum String Length (\"length_min\") Maximum String Length (\"length_max\") string data input table generate columns output table. Column names input used output, preserving order well.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_string_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: obtenga una tabla de resumen para columnas de cadena ‚Äî tt_string_info","text":"","code":"tt_string_info(tbl)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_string_info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: obtenga una tabla de resumen para columnas de cadena ‚Äî tt_string_info","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_string_info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: obtenga una tabla de resumen para columnas de cadena ‚Äî tt_string_info","text":"Un objeto tibble.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_string_info.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: obtenga una tabla de resumen para columnas de cadena ‚Äî tt_string_info","text":"12-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_string_info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: obtenga una tabla de resumen para columnas de cadena ‚Äî tt_string_info","text":"","code":"# Get string information for the # string-based columns in the # `game_revenue` dataset tt_string_info(game_revenue) #> # A tibble: 3 √ó 7 #>   .param.     player_id session_id item_type item_name acquisition country #>   <chr>           <dbl>      <dbl>     <dbl>     <dbl>       <dbl>   <dbl> #> 1 length_mean        15         24      2.22      7.35        7.97    8.53 #> 2 length_min         15         24      2         5           5       5    #> 3 length_max         15         24      3        11          14      14     # Ensure that `player_id` and # `session_id` values always have # the same number of characters # throughout the table tt_string_info(game_revenue) %>%   col_vals_equal(     columns = vars(player_id),     value = 15   ) %>%   col_vals_equal(     columns = vars(session_id),     value = 24   ) #> # A tibble: 3 √ó 7 #>   .param.     player_id session_id item_type item_name acquisition country #>   <chr>           <dbl>      <dbl>     <dbl>     <dbl>       <dbl>   <dbl> #> 1 length_mean        15         24      2.22      7.35        7.97    8.53 #> 2 length_min         15         24      2         5           5       5    #> 3 length_max         15         24      3        11          14      14     # Check that the maximum string # length in column `f` of the # `small_table` dataset is no # greater than `4` tt_string_info(small_table) %>%   test_col_vals_lte(     columns = vars(f),     value = 4   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_summary_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: obtener una tabla de estad√≠sticas de resumen para columnas\nnum√©ricas ‚Äî tt_summary_stats","title":"Table Transformer: obtener una tabla de estad√≠sticas de resumen para columnas\nnum√©ricas ‚Äî tt_summary_stats","text":"table object, can produce summary table scoped numeric column values. output summary table leading column called \".param.\" labels nine rows, corresponding following summary statistics: Minimum (\"min\") 5th Percentile (\"p05\") 1st Quartile (\"q_1\") Median (\"med\") 3rd Quartile (\"q_3\") 95th Percentile (\"p95\") Maximum (\"max\") Interquartile Range (\"iqr\") Range (\"range\") numerical data input table generate columns output table. Column names input used output, preserving order well.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_summary_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: obtener una tabla de estad√≠sticas de resumen para columnas\nnum√©ricas ‚Äî tt_summary_stats","text":"","code":"tt_summary_stats(tbl)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_summary_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: obtener una tabla de estad√≠sticas de resumen para columnas\nnum√©ricas ‚Äî tt_summary_stats","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_summary_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: obtener una tabla de estad√≠sticas de resumen para columnas\nnum√©ricas ‚Äî tt_summary_stats","text":"Un objeto tibble.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_summary_stats.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: obtener una tabla de estad√≠sticas de resumen para columnas\nnum√©ricas ‚Äî tt_summary_stats","text":"12-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_summary_stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: obtener una tabla de estad√≠sticas de resumen para columnas\nnum√©ricas ‚Äî tt_summary_stats","text":"","code":"# Get summary statistics for the # `game_revenue` dataset that is # included in the package tt_summary_stats(game_revenue) #> # A tibble: 9 √ó 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0                 3.2 #> 2 p05             0.02              8.2 #> 3 q_1             0.09             18.5 #> 4 med             0.38             26.5 #> 5 q_3             1.25             33.8 #> 6 p95            22.0              39.5 #> 7 max           143.               41   #> 8 iqr             1.16             15.3 #> 9 range         143.               37.8  # Ensure that the maximum revenue # for individual purchases in the # `game_revenue` table is less than # $150 tt_summary_stats(game_revenue) %>%   col_vals_lt(     columns = vars(item_revenue),     value = 150,     segments = .param. ~ \"max\"   ) #> # A tibble: 9 √ó 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0                 3.2 #> 2 p05             0.02              8.2 #> 3 q_1             0.09             18.5 #> 4 med             0.38             26.5 #> 5 q_3             1.25             33.8 #> 6 p95            22.0              39.5 #> 7 max           143.               41   #> 8 iqr             1.16             15.3 #> 9 range         143.               37.8  # For in-app purchases in the # `game_revenue` table, check that # median revenue is somewhere # between $8 and $12 game_revenue %>%    dplyr::filter(item_type == \"iap\") %>%   tt_summary_stats() %>%   col_vals_between(     columns = vars(item_revenue),     left = 8, right = 12,     segments = .param. ~ \"med\"   ) #> # A tibble: 9 √ó 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0.4              3.2  #> 2 p05             1.39             5.99 #> 3 q_1             4.49            14.0  #> 4 med            10.5             22.6  #> 5 q_3            20.3             30.6  #> 6 p95            66.0             38.8  #> 7 max           143.              41    #> 8 iqr            15.8             16.7  #> 9 range         143.              37.8   # While performing validations of the # `game_revenue` table with an agent # we can include the same revenue # check by using `tt_summary_stats()` # in the `preconditions` argument (this # will transform the target table for # the validation step); we also need # to get just a segment of that table # (the row with the median values) agent <-    create_agent(     read_fn = ~ game_revenue,     tbl_name = \"game_revenue\",     label = \"Un ejemplo.\",     actions = action_levels(       warn_at = 0.10,       stop_at = 0.25,       notify_at = 0.35     )   ) %>%   rows_complete() %>%   rows_distinct() %>%   col_vals_between(     columns = vars(item_revenue),     left = 8, right = 12,     preconditions = ~ . %>%       dplyr::filter(item_type == \"iap\") %>%       tt_summary_stats(),     segments = .param. ~ \"med\"   ) %>%   interrogate()  # This should all pass but let's check: all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_colnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: obtener los nombres de las columnas de una tabla ‚Äî tt_tbl_colnames","title":"Table Transformer: obtener los nombres de las columnas de una tabla ‚Äî tt_tbl_colnames","text":"table object, can produce summary table contains table's column names. output summary table two columns many rows columns input table. first column \".param.\" column, integer-based column containing indices columns input table. second column, \"value\", contains column names input table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_colnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: obtener los nombres de las columnas de una tabla ‚Äî tt_tbl_colnames","text":"","code":"tt_tbl_colnames(tbl)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_colnames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: obtener los nombres de las columnas de una tabla ‚Äî tt_tbl_colnames","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_colnames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: obtener los nombres de las columnas de una tabla ‚Äî tt_tbl_colnames","text":"Un objeto tibble.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_colnames.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: obtener los nombres de las columnas de una tabla ‚Äî tt_tbl_colnames","text":"12-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_colnames.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: obtener los nombres de las columnas de una tabla ‚Äî tt_tbl_colnames","text":"","code":"# Get the column names of the # `game_revenue` dataset that's # included in the package tt_tbl_colnames(game_revenue) #> # A tibble: 11 √ó 2 #>    .param. value            #>      <int> <chr>            #>  1       1 player_id        #>  2       2 session_id       #>  3       3 session_start    #>  4       4 time             #>  5       5 item_type        #>  6       6 item_name        #>  7       7 item_revenue     #>  8       8 session_duration #>  9       9 start_day        #> 10      10 acquisition      #> 11      11 country           # This output table is useful when # you want to validate the # column names of the table; here, # we check that `game_revenue` has # certain column names present tt_tbl_colnames(game_revenue) %>%   test_col_vals_make_subset(     columns = vars(value),     set = c(\"acquisition\", \"country\")   ) #> [1] TRUE  # We can check to see whether the # column names in the `specifications` # table are all less than 15 # characters in length specifications %>%   tt_tbl_colnames() %>%   tt_string_info() %>%   test_col_vals_lt(     columns = vars(value),     value = 15   ) #> [1] FALSE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_dims.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: obtener las dimensiones de una mesa ‚Äî tt_tbl_dims","title":"Table Transformer: obtener las dimensiones de una mesa ‚Äî tt_tbl_dims","text":"table object, can produce summary table contains nothing table's dimensions: number rows number columns. output summary table two columns two rows. first \".param.\" column labels \"rows\" \"columns\"; second column, \"value\", contains row column counts.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_dims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: obtener las dimensiones de una mesa ‚Äî tt_tbl_dims","text":"","code":"tt_tbl_dims(tbl)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_dims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: obtener las dimensiones de una mesa ‚Äî tt_tbl_dims","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_dims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: obtener las dimensiones de una mesa ‚Äî tt_tbl_dims","text":"Un objeto tibble.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_dims.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: obtener las dimensiones de una mesa ‚Äî tt_tbl_dims","text":"12-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_tbl_dims.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: obtener las dimensiones de una mesa ‚Äî tt_tbl_dims","text":"","code":"# Get the dimensions of the # `game_revenue` dataset that's # included in the package tt_tbl_dims(game_revenue) #> # A tibble: 2 √ó 2 #>   .param. value #>   <chr>   <int> #> 1 rows     2000 #> 2 columns    11  # This output table is useful when # you want to validate the # dimensions of the table; here, # we check that `game_revenue` has # at least 1500 rows tt_tbl_dims(game_revenue) %>%   dplyr::filter(.param. == \"rows\") %>%   test_col_vals_gt(     columns = vars(value),     value = 1500   ) #> [1] TRUE  # We can check `small_table` for # an exact number of columns (`8`) tt_tbl_dims(small_table) %>%   dplyr::filter(.param. == \"columns\") %>%   test_col_vals_equal(     columns = vars(value),     value = 8   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: cambiar los tiempos de una mesa ‚Äî tt_time_shift","title":"Table Transformer: cambiar los tiempos de una mesa ‚Äî tt_time_shift","text":"table object containing date date-time columns, values can precisely shifted tt_time_shift() specification time shift. can either provide string time shift components shift direction (like \"-4y 10d\") difftime object (can created via lubridate expressions using base::difftime() function).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: cambiar los tiempos de una mesa ‚Äî tt_time_shift","text":"","code":"tt_time_shift(tbl, time_shift = \"0y 0m 0d 0H 0M 0S\")"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: cambiar los tiempos de una mesa ‚Äî tt_time_shift","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object. time_shift Either character-based representation specifies time difference time values time-based columns shifted, , difftime object. character string constructed format \"0y 0m 0d 0H 0M 0S\" individual time components can omitted (.e., \"1y 5d\" valid specification shifting time values ahead one year five days). Adding \"-\" beginning string (e.g., \"-2y\") shift time values back.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: cambiar los tiempos de una mesa ‚Äî tt_time_shift","text":"data frame, tibble, tbl_dbi object, tbl_spark object depending provided tbl.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Table Transformer: cambiar los tiempos de una mesa ‚Äî tt_time_shift","text":"time_shift specification higher time granularity least granular time column input table. Put simpler terms, date-based based columns (just single date-based column) time shifting can terms years, months, days. Using time_shift specification \"20d 6H\" presence dates result truncation \"20d\". Similarly, difftime object altered circumstances, however, object resolved exact number days rounding.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: cambiar los tiempos de una mesa ‚Äî tt_time_shift","text":"12-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_shift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: cambiar los tiempos de una mesa ‚Äî tt_time_shift","text":"","code":"# With the `game_revenue` dataset, # which has entries in the first # 21 days of 2015, move all of the # date and date-time values to the # beginning of 2021 tt_time_shift(   tbl = game_revenue,   time_shift = \"6y\" ) #> # A tibble: 2,000 √ó 11 #>    player_id       session_id  session_start       time                item_type #>    <chr>           <chr>       <dttm>              <dttm>              <chr>     #>  1 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 01:31:03 2021-01-01 01:31:27 iap       #>  2 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 01:31:03 2021-01-01 01:36:57 iap       #>  3 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 01:31:03 2021-01-01 01:37:45 iap       #>  4 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 01:31:03 2021-01-01 01:42:33 ad        #>  5 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 11:50:02 2021-01-01 11:55:20 ad        #>  6 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 11:50:02 2021-01-01 12:08:56 ad        #>  7 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 11:50:02 2021-01-01 12:14:08 ad        #>  8 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 11:50:02 2021-01-01 12:21:44 ad        #>  9 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 11:50:02 2021-01-01 12:24:20 ad        #> 10 FXWUORGYNJAE271 FXWUORGYNJ‚Ä¶ 2021-01-01 15:17:18 2021-01-01 15:19:36 ad        #> # ‚Ä¶ with 1,990 more rows, and 6 more variables: item_name <chr>, #> #   item_revenue <dbl>, session_duration <dbl>, start_day <date>, #> #   acquisition <chr>, country <chr>  # Keeping only the `date_time` and # `a`-`f` columns of `small_table`, # shift the times back 2 days and # 12 hours small_table %>%   dplyr::select(-date) %>%   tt_time_shift(\"-2d 12H\") #> # A tibble: 13 √ó 7 #>    date_time               a b             c      d e     f     #>    <dttm>              <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-01 23:00:00     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-01 12:32:00     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-03 01:32:00     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-04 05:23:00     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-07 00:36:00     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-08 18:15:00     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-13 06:46:00     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-14 23:27:00     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-17 16:30:00     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-17 16:30:00     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-24 08:07:00     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-25 14:51:00     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-27 23:23:00     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo ‚Äî tt_time_slice","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo ‚Äî tt_time_slice","text":"table object containing date, date-time columns, mixture thereof, one columns can used effectively slice data table two slice_point: get choose slices want keep. slice point can defined several ways. One method involves using decimal value 0 1, defines slice point time instant somewhere earliest time value (0) latest time value (1). Another way defining slice point supplying time value, following input types accepted: (1) ISO 8601 formatted time string (date date-time), (2) POSIXct time, (3) Date object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo ‚Äî tt_time_slice","text":"","code":"tt_time_slice(   tbl,   time_column = NULL,   slice_point = 0,   keep = c(\"left\", \"right\"),   arrange = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo ‚Äî tt_time_slice","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object. time_column time-based column used basis slicing. time column provided first one found used. slice_point location time_column slicing occur. can either decimal value 0 1, ISO 8601 formatted time string (date date-time), POSIXct time, Date object. keep slice kept? \"left\" side (default) contains data rows earlier slice_point \"right\" side rows later. arrange slice arranged time_column? may useful input tbl ordered time_column. default, FALSE original ordering retained.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo ‚Äî tt_time_slice","text":"data frame, tibble, tbl_dbi object, tbl_spark object depending provided tbl.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo ‚Äî tt_time_slice","text":"option arrange table date date-time values time_column. ordering always done ascending manner. NA/NULL values time_column result corresponding rows can removed (matter slice retained).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo ‚Äî tt_time_slice","text":"12-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/tt_time_slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: cortar una tabla con un punto de corte en una columna de\ntiempo ‚Äî tt_time_slice","text":"","code":"# With the `game_revenue` dataset, # which has entries in the first # 21 days of 2015, elect to get all # of the records where the `time` # values are strictly for the first # 15 days of 2015 tt_time_slice(   tbl = game_revenue,   time_column = \"time\",   slice_point = \"2015-01-16\" ) #> # A tibble: 1,208 √ó 11 #>    player_id       session_id  session_start       time                item_type #>    <chr>           <chr>       <dttm>              <dttm>              <chr>     #>  1 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 01:31:03 2015-01-01 01:31:27 iap       #>  2 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 01:31:03 2015-01-01 01:36:57 iap       #>  3 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 01:31:03 2015-01-01 01:37:45 iap       #>  4 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 01:31:03 2015-01-01 01:42:33 ad        #>  5 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 11:50:02 2015-01-01 11:55:20 ad        #>  6 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 11:50:02 2015-01-01 12:08:56 ad        #>  7 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 11:50:02 2015-01-01 12:14:08 ad        #>  8 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 11:50:02 2015-01-01 12:21:44 ad        #>  9 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 11:50:02 2015-01-01 12:24:20 ad        #> 10 FXWUORGYNJAE271 FXWUORGYNJ‚Ä¶ 2015-01-01 15:17:18 2015-01-01 15:19:36 ad        #> # ‚Ä¶ with 1,198 more rows, and 6 more variables: item_name <chr>, #> #   item_revenue <dbl>, session_duration <dbl>, start_day <date>, #> #   acquisition <chr>, country <chr>  # Omit the first 25% of records # from `small_table` on the basis # of a timeline that begins at  # `2016-01-04 11:00:00` and # ends at `2016-01-30 11:23:00` small_table %>%   tt_time_slice(     slice_point = 0.25,     keep = \"right\"   ) #> # A tibble: 8 √ó 8 #>   date_time           date           a b             c     d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4 3291. TRUE  mid   #> 2 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE  high  #> 3 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2 1036. FALSE low   #> 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high  #> 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high  #> 6 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7  834. TRUE  low   #> 7 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8  108. FALSE low   #> 8 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE  high"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/validate_rmd.html","id":null,"dir":"Reference","previous_headings":"","what":"Modificar las opciones de prueba de validaci√≥n pointblank dentro de los\ndocumentos de R Markdown ‚Äî validate_rmd","title":"Modificar las opciones de prueba de validaci√≥n pointblank dentro de los\ndocumentos de R Markdown ‚Äî validate_rmd","text":"Using pointblank R Markdown workflow enabled default pointblank library loaded. framework allows validation testing within specialized validation code chunks validate = TRUE option set. Using pointblank validation functions data marked code chunks flag overall failure stop threshold exceeded anywhere. errors reported validation code chunk rendering document HTML, green red status buttons indicate whether validations succeeded failures occurred. Clicking button reveals otherwise hidden validation statements error messages (). framework testing set default, validate_rmd() function offers opportunity set UI logging options.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/validate_rmd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modificar las opciones de prueba de validaci√≥n pointblank dentro de los\ndocumentos de R Markdown ‚Äî validate_rmd","text":"","code":"validate_rmd(summary = TRUE, log_to_file = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/validate_rmd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modificar las opciones de prueba de validaci√≥n pointblank dentro de los\ndocumentos de R Markdown ‚Äî validate_rmd","text":"summary TRUE (default), leading summary validations rendered R Markdown document. FALSE, element shown. log_to_file option log errors text file. default, logging done TRUE write log entries \"validation_errors.log\" working directory. enable logging specify file name, include path log file desired name.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/validate_rmd.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Modificar las opciones de prueba de validaci√≥n pointblank dentro de los\ndocumentos de R Markdown ‚Äî validate_rmd","text":"1-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":null,"dir":"Reference","previous_headings":"","what":"Transforma un agente pointblank en un testthat archivo de prueba ‚Äî write_testthat_file","title":"Transforma un agente pointblank en un testthat archivo de prueba ‚Äî write_testthat_file","text":"Con un objeto pointblank agent, podemos escribir un archivo de prueba testthat y optar por colocarlo en testthat/tests si est√° disponible en la ruta del proyecto (tambi√©n podemos especificar una ruta alternativa). Esto funciona transformando los pasos de validaci√≥n en una serie de llamadas expect_*() dentro de declaraciones individuales testthat::test_that(). Un requisito indispensable para utilizar write_testthat_file() en un agente es la presencia de una read_fn, que es una funci√≥n que se invoca para obtener la tabla de destino. La sentencia read_fn se colocar√° en la parte superior del archivo de prueba testthat para que la tabla de destino est√© disponible para cada una de las sentencias testthat::test_that() que le siguen. Si un objeto agent tiene una read_fn puede a√±adirse trav√©s de set_read_fn(). Los umbrales se obtendr√°n partir de los aplicados para el estado stop. Esto puede configurarse para un objeto agente* en blanco pasando un objeto action_levels al argumento actions de create_agent() o el mismo argumento de cualquier funci√≥n de validaci√≥n incluida. Si los umbrales stop est√°n disponibles, se utilizar√° un valor de umbral de 1 para cada sentencia expect_*() generada en el archivo de prueba testthat resultante. es necesario que el objeto agent se someta primero una interrogaci√≥n con interrogate(). Sin embargo, puede ser √∫til como prueba de funcionamiento realizar interactivamente una interrogaci√≥n en los datos de destino antes de generar el archivo de prueba testthat.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transforma un agente pointblank en un testthat archivo de prueba ‚Äî write_testthat_file","text":"","code":"write_testthat_file(   agent,   name = NULL,   path = NULL,   overwrite = FALSE,   skips = NULL,   quiet = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transforma un agente pointblank en un testthat archivo de prueba ‚Äî write_testthat_file","text":"agent Un objeto de agente de clase ptblank_agent. name Un nombre opcional para el archivo de prueba testhat. Debe ser un nombre sin extensi√≥n y sin el texto inicial \"test-\". Si se suministra nada, el nombre se derivar√° del tbl_name en el objeto agente. Si est√° presente, se utilizar√° un nombre gen√©rico. path Aqu√≠ se puede especificar una ruta si se debe intentar colocar el archivo en testthat/tests. overwrite ¬øDebe sobrescribirse un archivo testthat del mismo nombre? Por defecto, esto es FALSE. skips Se trata de un vector opcional de palabras clave de omisi√≥n de pruebas modelado partir de las funciones testthat skip_on_*(). Las siguientes palabras clave pueden utilizarse para incluir declaraciones skip_on_*(): \"cran\" (testthat::skip_on_cran()), \"travis\" (testthat::skip_on_travis()), \"appveyor\" (testthat::skip_on_appveyor()), \"ci\" (testthat::skip_on_ci()), \"covr\" (testthat::skip_on_covr()), \"bioc\" (testthat::skip_on_bioc()). Existen palabras clave para omitir pruebas en determinados sistemas operativos y todas ellas insertar√°n una llamada espec√≠fica testthat::skip_on_os(). Estas son \"windows\" (skip_on_os(\"windows\")), \"mac\" (skip_on_os(\"mac\")), \"linux\" (skip_on_os(\"linux\")) y \"solaris\" (skip_on_os(\"solaris\")). Estas declaraciones se colocar√°n en la parte superior del archivo de prueba testthat generado. quiet ¬øLa funci√≥n debe informar cuando se escribe el archivo? En por defecto es FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transforma un agente pointblank en un testthat archivo de prueba ‚Äî write_testthat_file","text":"Devuelve invisiblemente TRUE si el archivo testthat ha sido escrito.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transforma un agente pointblank en un testthat archivo de prueba ‚Äî write_testthat_file","text":"Las pruebas de los pasos de validaci√≥n inactivos se omitir√°n con un mensaje claro que indique que el motivo de la omisi√≥n se debe que la prueba est√° activa. Cualquier paso de validaci√≥n inactivo puede ser forzado un estado activo utilizando la funci√≥n activate_steps() en un objeto agent (lo contrario es posible con la funci√≥n deactivate_steps()). El paquete testthat viene con una serie de funciones skip_on_*() que convenientemente hacen que el archivo de prueba se salte por completo si se cumplen ciertas condiciones. Podemos establecer r√°pidamente cualquier n√∫mero de ellas en la parte superior del archivo de prueba testthat suministrando palabras clave como un vector la opci√≥n skips de write_testthat_file(). Por ejemplo, si establecemos skips = c(\"cran\", \"windows) a√±adiremos el c√≥digo skip_on_cran() y skip_on_os(\"windows\"), lo que significa que el archivo de prueba generado se ejecutar√° en un sistema CRAN o si el sistema operativo es Windows. Este es un ejemplo de la salida del archivo de prueba testthat: test-small_table.R Esto fue generado por el siguiente conjunto de declaraciones:","code":"# Generated by pointblank  tbl <- small_table  test_that(\"column `date_time` exists\", {      expect_col_exists(     tbl,     columns = vars(date_time),     threshold = 1   )  })  test_that(\"values in `c` should be <= `5`\", {      expect_col_vals_lte(     tbl,     columns = vars(c),     value = 5,     threshold = 0.25   )  }) library(pointblank)  agent <-    create_agent(     read_fn = ~ small_table,     actions = action_levels(stop_at = 0.25)   ) %>%   col_exists(vars(date_time)) %>%   col_vals_lte(vars(c), value = 5)    write_testthat_file(   agent = agent,   name = \"small_table\",   path = \".\" )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Transforma un agente pointblank en un testthat archivo de prueba ‚Äî write_testthat_file","text":"8-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/write_testthat_file.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transforma un agente pointblank en un testthat archivo de prueba ‚Äî write_testthat_file","text":"","code":"if (interactive()) {  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # A pointblank `agent` object is now # created and the `al` object is provided # to the agent; the static thresholds # provided by `al` make reports a bit # more useful after interrogation agent <-    create_agent(     read_fn = ~ small_table,     label = \"Un ejemplo.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5) %>%   interrogate()  # This agent and all of the checks can # be transformed into a testthat file # with `write_testthat_file()`; the `stop` # thresholds will be ported over write_testthat_file(   agent = agent,   name = \"small_table\",   path = \".\" )  # The above code will generate a file with # the name `test-small_table.R`; the path # was specified with `\".\"` but, by default, # the function will place the file in the # `tests/testthat` folder if it's available  # An agent on disk as a YAML file can be # made into a testthat file; the # 'agent-small_table.yml' file is # available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # Writing the testthat file into the # working directory is much the same # as before but we're reading the # agent from disk this time write_testthat_file(   agent = yaml_read_agent(yml_file),   name = \"from_agent_yaml\",   path = \".\" )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":null,"dir":"Reference","previous_headings":"","what":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco ‚Äî x_read_disk","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco ‚Äî x_read_disk","text":"agent, informant, multiagent, table scan written disk (x_write_disk()) can read back memory x_read_disk() function. agent informant object generated way, may data table associated (depending whether keep_tbl option TRUE FALSE writing disk) still able produce reporting (printing agent informant console using get_agent_report()/get_informant_report()). agent return x-list get_agent_x_list() yield available data extracts get_data_extracts(). Furthermore, agent's validation steps still present (along results last interrogation).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco ‚Äî x_read_disk","text":"","code":"x_read_disk(filename, path = NULL, quiet = FALSE)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco ‚Äî x_read_disk","text":"filename name file previously written x_write_disk(). path optional path file (combined filename). quiet function inform file read? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco ‚Äî x_read_disk","text":"Either ptblank_agent, ptblank_informant, ptblank_tbl_scan object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco ‚Äî x_read_disk","text":"written--disk agent informant possess table-prep formula (can set time set_read_fn()) specific table (settable set_tbl()) use interrogate() incorporate() function . data quality reporting workflow, useful interrogate() target tables evolve time. validation steps used, can added calling interrogate(). information management workflow informant object, using incorporate() update aspects reporting table dimensions, info snippets/text regenerated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco ‚Äî x_read_disk","text":"9-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_read_disk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Leer un agent, informant, multiagent o escaneo de tabla desde el disco ‚Äî x_read_disk","text":"","code":"if (interactive()) {  # A: Reading an agent from disk   # The process of developing an agent # and writing it to disk with the # `x_write_disk()` function is explained # in that function's documentation; # but suppose we have such a written file # that's named \"agent-small_table.rds\", # we could read that to a new agent # object with `x_read_disk()` agent <-   x_read_disk(\"agent-small_table.rds\")  # B: Reading an informant from disk  # If there is an informant written # to disk via `x_write_disk()` and it's # named \"informant-small_table.rds\", # we could read that to a new informant # object with `x_read_disk()` informant <-   x_read_disk(\"informant-small_table.rds\")  # C: Reading a multiagent from disk   # The process of creating a multiagent # and writing it to disk with the # `x_write_disk()` function is shown # in that function's documentation; # but should we have such a written file # called \"multiagent-small_table.rds\", # we could read that to a new multiagent # object with `x_read_disk()` agent <-   x_read_disk(\"multiagent-small_table.rds\")  # D: Reading a table scan from disk  # If there is a table scan written # to disk via `x_write_disk()` and it's # named \"tbl_scan-storms.rds\", we could # read it back into R with `x_read_disk()` tbl_scan <-   x_read_disk(\"tbl_scan-storms.rds\")  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":null,"dir":"Reference","previous_headings":"","what":"Escriba un agent, informant, multiagent o escaneo de tabla al disco ‚Äî x_write_disk","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco ‚Äî x_write_disk","text":"Writing agent, informant, multiagent, even table scan disk x_write_disk() can useful keeping data validation intel table information close hand later retrieval (x_read_disk()). default, data table agent informant may held committed disk expunged (applicable table scan since never hold table object). behavior can changed setting keep_tbl TRUE works case table tbl_dbi tbl_spark class.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco ‚Äî x_write_disk","text":"","code":"x_write_disk(   x,   filename,   path = NULL,   keep_tbl = FALSE,   keep_extracts = FALSE,   quiet = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco ‚Äî x_write_disk","text":"x agent object class ptblank_agent, informant class ptblank_informant, table scan class ptblank_tbl_scan. filename filename create disk agent, informant, table scan. path optional path file saved (automatically combined filename). keep_tbl option keep data table associated agent informant (case agent, example, created using create_agent(tbl = <data table, ...)). default FALSE data table removed writing disk. database tables class tbl_dbi Spark DataFrames (tbl_spark) table always removed (even keep_tbl set TRUE). keep_extracts option keep collected extract data failing rows. applies agent objects. default, FALSE (.e., extract data removed). quiet function inform file written? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco ‚Äî x_write_disk","text":"Invisibly returns TRUE file written.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco ‚Äî x_write_disk","text":"recommended set table-prep formula agent informant can access refreshed data read disk x_read_disk(). can done initially read_fn argument create_agent()/create_informant() , later, set_read_fn(). Alternatively, can reintroduce agent informant data table set_tbl() function.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco ‚Äî x_write_disk","text":"9-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/x_write_disk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Escriba un agent, informant, multiagent o escaneo de tabla al disco ‚Äî x_write_disk","text":"","code":"if (interactive()) {  # A: Writing an `agent` to disk   # Let's go through the process of (1) # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # (2) interrogating the agent with the # `interrogate()` function, and (3) writing # the agent and all its intel to a file  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`x_write_disk()`\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want; then, we `interrogate()` agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5) %>%   interrogate()  # The `agent` can be written to a file with # the `x_write_disk()` function x_write_disk(   agent,   filename = \"agent-small_table.rds\" )  # We can read the file back as an agent # with the `x_read_disk()` function and # we'll get all of the intel along with the # restored agent  # If you're consistently writing agent # reports when periodically checking data, # we could make use of the `affix_date()` # or `affix_datetime()` depending on the # granularity you need; here's an example # that writes the file with the format: # 'agent-small_table-YYYY-mm-dd_HH-MM-SS.rds' x_write_disk(   agent,   filename = affix_datetime(     \"agent-small_table.rds\"   ) )  # B: Writing an `informant` to disk  # Let's go through the process of (1) # creating an informant object that # minimally describes the `small_table` # dataset, (2) ensuring that data is # captured from the target table using # the `incorporate()` function, and (3) # writing the informant to a file  # Create a pointblank `informant` # object with `create_informant()` # and the `small_table` dataset; use # `incorporate()` so that info snippets # are integrated into the text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`x_write_disk()`\"   ) %>%   info_snippet(     snippet_name = \"high_a\",     fn = snip_highest(column = \"a\")   ) %>%   info_snippet(     snippet_name = \"low_a\",     fn = snip_lowest(column = \"a\")   ) %>%   info_columns(     columns = vars(a),     info = \"From {low_a} to {high_a}.\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values.\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`.\"   ) %>%   incorporate()  # The `informant` can be written to a # file with `x_write_disk()`; let's do # this with `affix_date()` so that the # filename has a datestamp x_write_disk(   informant,   filename = affix_date(     \"informant-small_table.rds\"   ) )  # We can read the file back into a # new informant object (in the same # state as when it was saved) by using # `x_read_disk()`  # C: Writing a multiagent to disk  # Let's create one more pointblank # agent object, provide it with some # validation steps, and `interrogate()` agent_b <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`x_write_disk()`\",     actions = al   ) %>%   col_vals_gt(     vars(b), vars(g), na_pass = TRUE,     label = \"b > g\"   ) %>%   col_is_character(     vars(b, f),     label = \"Verifying character-type columns\"    ) %>%   interrogate()  # Now we can combine the earlier `agent` # object with the newer `agent_b` to  # create a `multiagent` multiagent <-   create_multiagent(agent, agent_b)    # The `multiagent` can be written to # a file with the `x_write_disk()` function x_write_disk(   multiagent,   filename = \"multiagent-small_table.rds\" )  # We can read the file back as a multiagent # with the `x_read_disk()` function and # we'll get all of the constituent agents # and their associated intel back as well  # D: Writing a table scan to disk  # We can get an report that describes all # of the data in the `storms` dataset tbl_scan <- scan_data(tbl = dplyr::storms)  # The table scan object can be written # to a file with `x_write_disk()` x_write_disk(   tbl_scan,   filename = \"tbl_scan-storms.rds\" )  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_interrogate.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtenga un agent de pointblank YAML e interrogate() ‚Äî yaml_agent_interrogate","title":"Obtenga un agent de pointblank YAML e interrogate() ‚Äî yaml_agent_interrogate","text":"yaml_agent_interrogate() function operates much like yaml_read_agent() function (reading pointblank YAML file generating agent validation plan place). key difference function takes things step interrogates target table (defined table-prep formula required YAML file). additional auto-invocation interrogate() uses default options function. yaml_read_agent() agent returned except, time, intel interrogation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_interrogate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtenga un agent de pointblank YAML e interrogate() ‚Äî yaml_agent_interrogate","text":"","code":"yaml_agent_interrogate(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_interrogate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtenga un agent de pointblank YAML e interrogate() ‚Äî yaml_agent_interrogate","text":"filename name YAML file contains fields related agent. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_interrogate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtenga un agent de pointblank YAML e interrogate() ‚Äî yaml_agent_interrogate","text":"Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_interrogate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtenga un agent de pointblank YAML e interrogate() ‚Äî yaml_agent_interrogate","text":"11-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_interrogate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtenga un agent de pointblank YAML e interrogate() ‚Äî yaml_agent_interrogate","text":"","code":"if (interactive()) {  # Let's go through the process of # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # and then offloading that validation # plan to a pointblank YAML file; this # will later be read in as a new agent and # the target data will be interrogated # (one step) with `yaml_agent_interrogate()`  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` # (a requirement for writing to YAML) agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" )  # The 'agent-small_table.yml' file is # available in the package through `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # We can view the YAML file in the console # with the `yaml_agent_string()` function yaml_agent_string(filename = yml_file)  # The YAML can also be printed in the console # by supplying the agent as the input yaml_agent_string(agent = agent)  # We can interrogate the data (which # is accessible through the `read_fn`) # through direct use of the YAML file # with `yaml_agent_interrogate()` agent <-    yaml_agent_interrogate(filename = yml_file)  class(agent)  # If it's desired to only create a new # agent with the validation plan in place # (stopping short of interrogating the data), # then the `yaml_read_agent()` function # will be useful agent <-    yaml_read_agent(filename = yml_file) class(agent)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_show_exprs.html","id":null,"dir":"Reference","previous_headings":"","what":"Mostrar expresiones de validaci√≥n usando pointblank YAML ‚Äî yaml_agent_show_exprs","title":"Mostrar expresiones de validaci√≥n usando pointblank YAML ‚Äî yaml_agent_show_exprs","text":"yaml_agent_show_exprs() function follows specifications pointblank YAML file generate show pointblank expressions generating described validation plan. expressions shown console, providing opportunity copy statements extend needed. pointblank YAML file can generated using yaml_write() function pre-existing agent, , can carefully written hand.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_show_exprs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mostrar expresiones de validaci√≥n usando pointblank YAML ‚Äî yaml_agent_show_exprs","text":"","code":"yaml_agent_show_exprs(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_show_exprs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mostrar expresiones de validaci√≥n usando pointblank YAML ‚Äî yaml_agent_show_exprs","text":"filename name YAML file contains fields related agent. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_show_exprs.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Mostrar expresiones de validaci√≥n usando pointblank YAML ‚Äî yaml_agent_show_exprs","text":"11-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_show_exprs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mostrar expresiones de validaci√≥n usando pointblank YAML ‚Äî yaml_agent_show_exprs","text":"","code":"if (interactive()) {  # Let's create a validation plan for the # data quality analysis of the `small_table` # dataset; we need an agent and its # table-prep formula enables retrieval # of the target table agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = action_levels(       warn_at = 0.10,       stop_at = 0.25,       notify_at = 0.35     )   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" )  # The 'agent-small_table.yml' file is # available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # At a later time, the YAML file can # be read into a new agent with the # `yaml_read_agent()` function agent <-    yaml_read_agent(filename = yml_file)  class(agent)  # To get a sense of which expressions are # being used to generate the new agent, we # can use `yaml_agent_show_exprs()` yaml_agent_show_exprs(filename = yml_file)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_string.html","id":null,"dir":"Reference","previous_headings":"","what":"Mostrar pointblank YAML usando un agente o un archivo YAML ‚Äî yaml_agent_string","title":"Mostrar pointblank YAML usando un agente o un archivo YAML ‚Äî yaml_agent_string","text":"pointblank YAML, can serialize agent's validation plan (yaml_write()), read back later new agent (yaml_read_agent()), perform interrogation target data table directly YAML file (yaml_agent_interrogate()). yaml_agent_string() function allows us inspect YAML generated yaml_write() console, giving us look YAML without needing open file directly. Alternatively, can provide agent yaml_agent_string() view YAML representation validation plan without needing write YAML disk beforehand.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_string.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mostrar pointblank YAML usando un agente o un archivo YAML ‚Äî yaml_agent_string","text":"","code":"yaml_agent_string(agent = NULL, filename = NULL, path = NULL, expanded = FALSE)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_string.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mostrar pointblank YAML usando un agente o un archivo YAML ‚Äî yaml_agent_string","text":"agent agent object class ptblank_agent. object provided , filename must provided. filename name YAML file contains fields related agent. file name provided , agent object must provided agent. path optional path YAML file (combined filename). expanded written validation expressions agent expanded tidyselect vars() expressions columns evaluated, yielding validation function per column? default, FALSE expressions written retained YAML representation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_string.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Mostrar pointblank YAML usando un agente o un archivo YAML ‚Äî yaml_agent_string","text":"11-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_agent_string.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mostrar pointblank YAML usando un agente o un archivo YAML ‚Äî yaml_agent_string","text":"","code":"if (interactive()) {  # Let's create a validation plan for the # data quality analysis of the `small_table` # dataset; we need an agent and its # table-prep formula enables retrieval # of the target table agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = action_levels(       warn_at = 0.10,       stop_at = 0.25,       notify_at = 0.35     )   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # We can view the YAML file in the console # with the `yaml_agent_string()` function, # providing the `agent` object as the input yaml_agent_string(agent = agent)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" )  # There's a similar file in the package # ('agent-small_table.yml') and it's # accessible with `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # The `yaml_agent_string()` function can # be used with the YAML file as well, # use the `filename` argument instead yaml_agent_string(filename = yml_file)  # At some later time, the YAML file can # be read as a new agent with the # `yaml_read_agent()` function agent <- yaml_read_agent(filename = yml_file) class(agent)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_exec.html","id":null,"dir":"Reference","previous_headings":"","what":"Ejecutar todas las tareas YAML de agentes e informantes ‚Äî yaml_exec","title":"Ejecutar todas las tareas YAML de agentes e informantes ‚Äî yaml_exec","text":"yaml_exec() function takes relevant pointblank YAML files directory executes . Execution involves interrogation agents YAML agents incorporation informants YAML informants. hood, uses yaml_agent_interrogate() yaml_informant_incorporate() x_write_disk() save processed objects output directory. written artifacts can read later time x_read_disk() function read_disk_multiagent() function. useful data target tables changing periodic testing tables part data quality monitoring plan. output RDS files named according object type processed, target table, date-time processing. convenience modularity, setup ideal table store YAML file (typically named \"tbl_store.yml\" produced via tbl_store() yaml_write() workflow) available directory, table-prep formulas accessed name tbl_source(). typical directory files set execution way might following contents: \"tbl_store.yml\" file holding table-prep formulas (created tbl_store() written YAML yaml_write()) one YAML agent files validate tables (ideally using tbl_source()) one YAML informant files provide refreshed metadata tables (, using tbl_source() reference table preparations ideal) output folder (default \"output\") save serialized versions processed agents informants Minimal example files aforementioned types can found pointblank package following system.file() calls: system.file(\"yaml\", \"agent-small_table.yml\", package = \"pointblank\") system.file(\"yaml\", \"informant-small_table.yml\", package = \"pointblank\") system.file(\"yaml\", \"tbl_store.yml\", package = \"pointblank\") directory can accessed using system.file(\"yaml\", package = \"pointblank\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_exec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ejecutar todas las tareas YAML de agentes e informantes ‚Äî yaml_exec","text":"","code":"yaml_exec(   path = NULL,   files = NULL,   write_to_disk = TRUE,   output_path = file.path(path, \"output\"),   keep_tbl = FALSE,   keep_extracts = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_exec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ejecutar todas las tareas YAML de agentes e informantes ‚Äî yaml_exec","text":"path path contains YAML files agents informants. files vector YAML files use execution workflow. default, yaml_exec() attempt process every valid YAML file path supplying vector limits scope specified files. write_to_disk execution workflow include step writes output files disk? internally calls x_write_disk() write RDS files uses base filename agent/informant YAML file part output filename, appending date-time basename. output_path output path generated output files. default, subdirectory provided path called \"output\". keep_tbl, keep_extracts agents, table may kept data frame object (databases tables never pulled storage) extracts, collections table rows failed validation step, may also stored. default, options set FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_exec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ejecutar todas las tareas YAML de agentes e informantes ‚Äî yaml_exec","text":"Invisibly returns named vector file paths input files processed; file output paths (wherever writing occurred) given names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_exec.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Ejecutar todas las tareas YAML de agentes e informantes ‚Äî yaml_exec","text":"11-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_exec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ejecutar todas las tareas YAML de agentes e informantes ‚Äî yaml_exec","text":"","code":"if (interactive()) {  # The 'yaml' directory that is # accessible in the package through # `system.file()` contains the files # 1. `agent-small_table.yml` # 2. `informant-small_table.yml` # 3. `tbl_store.yml`  # There are references in YAML files # 1 & 2 to the table store YAML file, # so, they all work together cohesively  # Let's process the agent and the # informant YAML files with `yaml_exec()`; # and we'll specify the working directory # as the place where the output RDS files # are written  output_dir <- getwd()  yaml_exec(   path = system.file(     \"yaml\", package = \"pointblank\"   ),   output = output_dir )  # This generates two RDS files in the # working directory: one for the agent # and the other for the informant; each # of them are automatically time-stamped # so that periodic execution can be # safely carried out without risk of # overwriting   }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_informant_incorporate.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtener un informant de pointblank YAML e incorporate() ‚Äî yaml_informant_incorporate","title":"Obtener un informant de pointblank YAML e incorporate() ‚Äî yaml_informant_incorporate","text":"yaml_informant_incorporate() function operates much like yaml_read_informant() function (reading pointblank YAML file generating informant information place). key difference function takes things step incorporates aspects target table (defined table-prep formula required YAML file). additional auto-invocation incorporate() uses default options function. yaml_read_informant() informant returned except, time, updated latest information target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_informant_incorporate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtener un informant de pointblank YAML e incorporate() ‚Äî yaml_informant_incorporate","text":"","code":"yaml_informant_incorporate(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_informant_incorporate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtener un informant de pointblank YAML e incorporate() ‚Äî yaml_informant_incorporate","text":"filename name YAML file contains fields related informant. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_informant_incorporate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtener un informant de pointblank YAML e incorporate() ‚Äî yaml_informant_incorporate","text":"Un objeto ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_informant_incorporate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtener un informant de pointblank YAML e incorporate() ‚Äî yaml_informant_incorporate","text":"11-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_informant_incorporate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtener un informant de pointblank YAML e incorporate() ‚Äî yaml_informant_incorporate","text":"","code":"if (interactive()) {  # Let's go through the process of # developing an informant with information # about the `small_table` dataset and then # move all that to a pointblank YAML # file; this will later be read in as a # new informant and the target data will # be incorporated into the info text # (in one step) with # `yaml_informant_incorporate()`  # Now create a pointblank `informant` # object; the data will be referenced # in a `read_fn` (a requirement for # writing to YAML) informant <-    create_informant(     read_fn = ~small_table,     label = \"A simple example with the `small_table`.\"   )  # Then, as with any `informant` object, we # can add information by using as many # `info_*()` functions as we want informant <-   informant %>%   info_columns(    columns = vars(a),    info = \"In the range of 1 to 10. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`. (CALC)\"   ) %>%   info_section(     section_name = \"rows\",     row_count = \"There are {row_count} rows available.\"   ) %>%   info_snippet(     snippet_name = \"row_count\",     fn = ~ . %>% nrow()   ) %>%   incorporate()  # The informant can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   informant = informant,   filename = \"informant-small_table.yml\" )  # The 'informant-small_table.yml' file # is available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"informant-small_table.yml\",     package = \"pointblank\"   )  # We can incorporate the data (which # is accessible through the `read_fn`) # into the info text through direct # use of the YAML file with # `yaml_informant_incorporate()` informant <-    yaml_informant_incorporate(filename = yml_file)  class(informant)  # If it's desired to only create a new # informant with the information in place # (stopping short of processing), then the # `yaml_read_informant()` function will # be useful informant <-    yaml_read_informant(filename = yml_file)  class(informant)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Leer un archivo YAML pointblank para crear un objeto agent ‚Äî yaml_read_agent","title":"Leer un archivo YAML pointblank para crear un objeto agent ‚Äî yaml_read_agent","text":"yaml_read_agent() can read pointblank YAML file describes validation plan carried agent (typically generated yaml_write() function. returned new agent validation plan, ready interrogate target table (using table-prep formula set read_fn argument). agent can given validation steps needed using interrogate() taking part agent ops (e.g., writing disk outputs intact via x_write_disk() pointblank YAML yaml_write()). get picture yaml_read_agent() interpreting validation plan specified pointblank YAML, can use yaml_agent_show_exprs() function. function shows us (console) pointblank expressions generating described validation plan.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leer un archivo YAML pointblank para crear un objeto agent ‚Äî yaml_read_agent","text":"","code":"yaml_read_agent(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leer un archivo YAML pointblank para crear un objeto agent ‚Äî yaml_read_agent","text":"filename name YAML file contains fields related agent. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_agent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leer un archivo YAML pointblank para crear un objeto agent ‚Äî yaml_read_agent","text":"Un objeto ptblank_agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_agent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Leer un archivo YAML pointblank para crear un objeto agent ‚Äî yaml_read_agent","text":"11-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_agent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Leer un archivo YAML pointblank para crear un objeto agent ‚Äî yaml_read_agent","text":"","code":"if (interactive()) {  # Let's go through the process of # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # and then offloading that validation # plan to a pointblank YAML file; this # will be read in with `yaml_read_agent()`  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` # (a requirement for writing to YAML) agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" )  # The 'agent-small_table.yml' file is # available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # We can view the YAML file in the console # with the `yaml_agent_string()` function yaml_agent_string(filename = yml_file)  # The YAML can also be printed in the console # by supplying the agent as the input yaml_agent_string(agent = agent)  # At some later time, the YAML file can # be read as a new agent with the # `yaml_read_agent()` function agent <- yaml_read_agent(filename = yml_file)  class(agent)  # We can interrogate the data (which # is accessible through the `read_fn`) # with `interrogate()` and get an # agent with intel, or, we can # interrogate directly from the YAML # file with `yaml_agent_interrogate()` agent <-    yaml_agent_interrogate(     filename = yml_file   )  class(agent)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_informant.html","id":null,"dir":"Reference","previous_headings":"","what":"Leer un archivo YAML pointblank para crear un objeto informant ‚Äî yaml_read_informant","title":"Leer un archivo YAML pointblank para crear un objeto informant ‚Äî yaml_read_informant","text":"yaml_read_informant() can read pointblank YAML file describes table information (typically generated yaml_write() function. returned new informant object information intact. informant object can given information use info_*() functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_informant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leer un archivo YAML pointblank para crear un objeto informant ‚Äî yaml_read_informant","text":"","code":"yaml_read_informant(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_informant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leer un archivo YAML pointblank para crear un objeto informant ‚Äî yaml_read_informant","text":"filename name YAML file contains fields related informant. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_informant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leer un archivo YAML pointblank para crear un objeto informant ‚Äî yaml_read_informant","text":"ptblank_informant object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_informant.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Leer un archivo YAML pointblank para crear un objeto informant ‚Äî yaml_read_informant","text":"11-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_read_informant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Leer un archivo YAML pointblank para crear un objeto informant ‚Äî yaml_read_informant","text":"","code":"if (interactive()) {  # Create a pointblank `informant` # object with `create_informant()` # and the `small_table` dataset informant <- create_informant(small_table)  # An `informant` object can be written # to a YAML file with the `yaml_write()` # function # yaml_write( #   informant = informant, #   filename = \"informant-small_table.yml\" # )  # The `informant-small_table.yml` file # looks like this when written  #> info_label: '[2020-09-06|13:37:38]' #> table: #>   name: small_table #> _columns: 8 #> _rows: 13 #> _type: tbl_df #> columns: #>   date_time: #>     _type: POSIXct, POSIXt #>   date: #>     _type: Date #>   a: #>     _type: integer #>   b: #>     _type: character #>   c: #>     _type: numeric #>   d: #>     _type: numeric #>   e: #>     _type: logical #>   f: #>     _type: character  # We can add keys and values to # add more pertinent information; with # some direct editing of the file we get:  #> info_label: '[2020-09-06|13:37:38]' #> table: #>   name: small_table #>   _columns: 8 #>   _rows: 13 #>   _type: tbl_df #> columns: #>   date_time: #>     _type: POSIXct, POSIXt #>     info: Date-time values. #>   date: #>     _type: Date #>     info: Date values (the date part of `date_time`). #>   a: #>     _type: integer #>     info: Small integer values (no missing values). #>   b: #>     _type: character #>     info: Strings with a common pattern. #>   c: #>     _type: numeric #>     info: Small numeric values (contains missing values). #>   d: #>     _type: numeric #>     info: Large numeric values (much greater than `c`). #>   e: #>     _type: logical #>     info: TRUE and FALSE values. #>   f: #>     _type: character #>     info: Strings of the set `\"low\"`, `\"mid\"`, and `\"high\"`.  # We could also have done the same # with the `informant` object by use of # the `info_columns()` function  # The 'informant-small_table.yml' file # is available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"informant-small_table.yml\",     package = \"pointblank\"   )  # We can read this YAML file back # as an `informant` object by using # `yaml_read_informant()` informant <-    yaml_read_informant(filename = yml_file)  class(informant)  }"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_write.html","id":null,"dir":"Reference","previous_headings":"","what":"Escribir objetos pointblank en archivos YAML ‚Äî yaml_write","title":"Escribir objetos pointblank en archivos YAML ‚Äî yaml_write","text":"yaml_write() can take different pointblank objects (ptblank_agent, ptblank_informant, tbl_store) write YAML. agent, example, yaml_write() write everything needed specify agent validation plan YAML file. YAML, can modify YAML markup desired, , use create new agent yaml_read_agent() function. agent validation plan ready interrogate() data. can go step perform interrogation directly YAML file yaml_agent_interrogate() function. returns agent intel (already interrogated target data table). informant object can also written YAML yaml_write(). One requirement writing agent informant YAML need table-prep formula (read_fn) specified (R formula used read target table interrogate() incorporate() called). option can set using create_agent()/create_informant() set_read_fn() (useful existing agent informant object).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_write.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Escribir objetos pointblank en archivos YAML ‚Äî yaml_write","text":"","code":"yaml_write(   ...,   .list = list2(...),   filename = NULL,   path = NULL,   expanded = FALSE,   quiet = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_write.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Escribir objetos pointblank en archivos YAML ‚Äî yaml_write","text":"... mix pointblank objects agent (ptblank_agent), informant (ptblank_informant), table store (tbl_store). agent informant can combined single YAML file (objects value read_fn). table store combined either agent informant must undergo conversion alone. .list Allows use list input alternative .... filename name YAML file create disk. recommended either .yaml .yml extension used file. provided default names used (\"tbl_store.yml\") table store objects get default naming effect \"<object>-<tbl_name>.yml\". path optional path YAML file saved (combined filename). expanded written validation expressions agent expanded tidyselect vars() expressions columns evaluated, yielding validation function per column? default, FALSE expressions written retained YAML representation. quiet function inform file written? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_write.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Escribir objetos pointblank en archivos YAML ‚Äî yaml_write","text":"Invisibly returns TRUE YAML file written.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_write.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Escribir objetos pointblank en archivos YAML ‚Äî yaml_write","text":"11-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/reference/yaml_write.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Escribir objetos pointblank en archivos YAML ‚Äî yaml_write","text":"","code":"if (interactive()) {  # Let's go through the process of # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # and then offloading that validation # plan to a pointblank YAML file  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` # (a requirement for writing to YAML) agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent,   filename = \"agent-small_table.yml\" )  # The 'agent-small_table.yml' file is # available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # We can view the YAML file in the console # with the `yaml_agent_string()` function yaml_agent_string(filename = yml_file)  # The YAML can also be printed in the console # by supplying the agent as the input yaml_agent_string(agent = agent)  # At some later time, the YAML file can # be read as a new agent with the # `yaml_read_agent()` function agent <-    yaml_read_agent(filename = yml_file)  class(agent)  # We can interrogate the data (which # is accessible through the `read_fn`) # with `interrogate()` and get an # agent with intel, or, we can # interrogate directly from the YAML # file with `yaml_agent_interrogate()` agent <-    yaml_agent_interrogate(filename = yml_file)  class(agent)  }"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-090","dir":"Changelog","previous_headings":"","what":"pointblank 0.9.0","title":"pointblank 0.9.0","text":"CRAN release: 2021-10-28","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-9-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.9.0","text":"new rows_complete() validation function (along expect_rows_complete() test_rows_complete() expectation test variants) check whether rows contain NA/NULL values (optionally constrained selection specified columns). new function serially() (along expect_serially() test_serially()) allows series tests run sequence either culminating final validation step simply exiting series. construction allows pre-testing may make sense validation step. example, may situations ‚Äôs vital check column type performing validation column. specially()/expect_specially()/test_specially() functions enable custom validations/tests/expectations user-defined function. still preconditions common args available convenience. great thing require UDF return logical vector passing/failing test units (table rightmost column logical), can incorporate results quite easily standard pointblank reporting. info_columns_from_tbl() function super-convenient wrapper info_columns() function. Say ‚Äôre making data dictionary informant already table metadata somewhere table: can use call info_columns() many, many times. Added game_revenue_info dataset contains metadata extant game_revenue dataset. datasets pair nicely together examples create data dictionary create_informant() info_columns_from_tbl(). Added table transformer function tt_tbl_colnames() get table‚Äôs column names validation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"minor-improvements-and-bug-fixes-0-9-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.9.0","text":"Input data tables label attribute values columns displayed ‚ÄòVariables‚Äô section scan_data() report. useful scanning imported SAS tables (often labeled variables). all_passed() function improved failed validation steps (return evaluation error, perhaps missing column) result FALSE; argument added all_passed() optionally get subset validation steps evaluation. expect_*() functions can handle multiple columns, pointblank now correctly stops first failure provides correct reporting . Passing multiple columns really mean processing multiple steps serial, previously handled incorrectly.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-080","dir":"Changelog","previous_headings":"","what":"pointblank 0.8.0","title":"pointblank 0.8.0","text":"CRAN release: 2021-07-25","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-8-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.8.0","text":"new draft_validation() function create starter validation .R .Rmd file just table input. Uses new ‚Äòcolumn roles‚Äô feature develop starter set validation steps based kind data columns contain (e.g., latitude/longitude values, URLs, email addresses, etc.). validation function col_vals_within_spec() (variants expect_col_vals_within_spec() test_col_vals_within_spec()) test column values specification like phone numbers (\"phone\"), VIN numbers (\"VIN\"), URLs (\"url\"), email addresses (\"email\"), much (\"isbn\", \"postal_code[<country_code>]\", \"credit_card\", \"iban[<country_code>]\", \"swift\", \"ipv4\", \"ipv6\", \"mac\"). large cross section row-based validation functions can now operate segments target table, can run particular validation slices (segments) target table. segmentation made possible use new segments argument, takes expression serves segment target table column values. can given one two ways: (1) single multiple column names containing keys segment , (2) two-sided formula LHS holds column name RHS contains column values segment (allowing subset keys segmentation). default printing multiagent object now stacked display agent reports. wide report (useful comparisons validations targeting table time) available improved get_multiagent_report() function (display_mode = \"wide\"). Exporting reporting now much easier new export_report() function. export objects agent (validations), informant (table metadata), multiagent (series validations), , also objects containing customized reports (scan_data(), get_agent_report(), get_informant_report(), get_multiagent_report()). ‚Äôll always get self-contained HTML file report use export_report(). new family functions added pointblank: Table Transformers! functions can radically transform data table either provide wholly different table (like summary table table properties table) useful filtering single step. can useful preparing target table validation creating temporary tables (preconditions) validation steps (e.g., validating table properties string lengths). nice bonus transformer functions work equally well data frames, database tables, Spark tables. included functions : tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_time_shift(), tt_time_slice(). Two new datasets added: specifications game_revenue. former dataset can used test col_vals_within_spec() validation function. latter dataset (2,000 rows) can used experiment tt_time_shift() tt_time_slice() table transformer functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"minor-improvements-and-bug-fixes-0-8-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.8.0","text":"Added Polish (\"pl\"), Danish (\"da\"), Turkish (\"tr\"), Swedish (\"sv\"), Dutch (\"nl\") translations. scan_data() function now bit performant, testable, better communicating progress generating report. preconditions argument, used modify target table validation step, now improved (1) checking table object returned evaluation, (2) correcting YAML writing preconditions expression ‚Äôs provided function. x_write_disk() x_read_disk() extended allow writing reading ptblank_tbl_scan objects (returned scan_data()). Print methods received love release. Now, scan_data() table scan reports look much better R Markdown. Reporting objects get_agent_report(), get_informant_report(), get_multiagent_report() now print methods work beautifully R Markdown result. incorporate() function, called informant object, now emits styled messages console. using yaml_exec() process arbitrary amount YAML-based agents informants, ‚Äôll given information progress console.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"documentation-0-8-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.8.0","text":"Many help files overhauled (1) things clearer, (2) details provided (things complex), (3) many ready--run examples present. functions improved help release : all_passed(), get_data_extracts(), get_multiagent_report(), get_sundered_data(), has_columns(), write_testthat_file(), x_write_disk(), yaml_exec().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-070","dir":"Changelog","previous_headings":"","what":"pointblank 0.7.0","title":"pointblank 0.7.0","text":"CRAN release: 2021-03-09","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-7-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.7.0","text":"New functions set-based interrogations: col_vals_make_set() (+ expect_col_vals_make_set() test_col_vals_make_set()) col_vals_make_subset() (+ expect_col_vals_make_subset() test_col_vals_make_subset()); answer following two questions: (1) set values entirely accounted column values?, (2) set values subset column values? New functions order-based interrogations: col_vals_increasing() (+ expect_col_vals_increasing() test_col_vals_increasing()) col_vals_decreasing() (+ expect_col_vals_decreasing() test_col_vals_decreasing()); check column values either increasing decreasing options allow non-moving values backtracking (threshold). Several functions added facilitate multi-agent workflows: create_multiagent(), read_disk_multiagent(), get_multiagent_report(); workflows help track interrogation results across multiple agents reporting scales well several dozens agents. new function write_testthat_file() generates testthat test file puts tests/testthat certain conditions met; converts agent‚Äôs validation plan separate expect_*() statements. New functions tbl_store(), tbl_source(), tbl_get() functions added centrally managing table-prep formulas. Added yaml_exec() function processes relevant pointblank YAML files directory; execution involves interrogation agents (given YAML agents) incorporation informants (given YAML informants), saving processed objects output directory. new functions file_tbl() helper from_github() make easy generate table compatible data file; file form CSV, TSV, RDA, RDS. Several functions added modifying agent‚Äôs validation plan: activate_steps(), deactivate_steps(), remove_steps(). Added snip_stats() function generating -line statistical summary information report. Add sorting options snip_list() can choose sort column items frequency sequentially (alphabetically/numerically). improvements made snip_list() : (1) better default appearance, (2) enable customization, (3) include localization options supported spoken languages. Added several options customizing main reporting heading three reporting objects: agent report, information report, multiagent report. active argument every validation function can now take expression evaluates logical; has_columns() added make easy express active whether one columns present target table (e.g., perform validation step target column available). Added support using Arrow tables target tables informant objects.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"documentation-0-7-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.7.0","text":"Added information YAML representations validation functions several functions make appearance YAML. General improvements function documentation made wide cross section exported functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"minor-improvements-and-bug-fixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.7.0","text":"Included method writing informant object disk (x_write_disk()). Many fixes made tests added ensure agents survive YAML roundtrip (agent %>% yaml_write() yaml_read_agent() creates agent object). Updated several internal dplyr::arrange() statements used scan_data() warnings aren‚Äôt issued dbplyr (table scans operating tbl_dbi objects). tidyselect expressions used agents now preserved agent written YAML.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-060","dir":"Changelog","previous_headings":"","what":"pointblank 0.6.0","title":"pointblank 0.6.0","text":"CRAN release: 2020-11-20","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-information-0-6-0","dir":"Changelog","previous_headings":"","what":"Pointblank Information","title":"pointblank 0.6.0","text":"new information management workflow full features help describe tables keep top changes . make work well, new character enters: informant! Added create_informant() function create ptblank_informant object (function similar create_agent()). meant hold information (much want, really) target table, reporting features geared toward communication. Functions facilitating entry info text added need (info_tabular(), info_columns(), info_section()). focused describing columns, table proper, misc. fields. wasn‚Äôt enough, release adds info_snippet() round collection info_*() functions workflow. Oh, hang , ‚Äôs also -important incorporate() function. ? explain, idea methodology acquiring important bits data target table (‚Äôs info_snippet()‚Äôs job) use incorporate() grab morsels data stitch info text (via { }). Added get_informant_report() function printing information report (gt table object!). can also just print informant object show information report thanks print method purpose. informant object can written pointblank YAML using revised yaml_write() (previously agent_yaml_write()) function. can actually write agent informant YAML file useful since objects share target table. Reading done yaml_read_agent() yaml_read_informant() functions. informant can emailed using email_create() function; emailing can done one eight languages stock message text.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"translations-and-locales-0-6-0","dir":"Changelog","previous_headings":"","what":"Translations and Locales","title":"pointblank 0.6.0","text":"text agent report translated now. Improved Spanish (Spain) translation. Added Portuguese (\"pt\", Brazil), Chinese (\"zh\", China mainland), Russian (\"ru\") translations. Added locale option reporting; locale match language (using base locale) unless different locale specified. locale used format numeric values according locale‚Äôs rules. also applies reporting offered scan_data() function. stock email message parts (used emailing agent report information report) translated eight supported languages. language setting respective objects used determine language stock message parts.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"breaking-changes-0-6-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"pointblank 0.6.0","text":"yaml_write() function replaces agent_yaml_write() function. new function works write agent, informant object, , YAML. names YAML functions changed, final roster now consists : yaml_write(), yaml_read_agent(), yaml_read_informant(), yaml_agent_interrogate(), yaml_agent_string(), yaml_agent_show_exprs(). x_write_disk() function replaces agent_write() function. new function works write agent informant object disk. x_read_disk() function replaces agent_read() function. new function works read agent informant objects written disk. email_preview() function renamed email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-6-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.6.0","text":"new db_tbl() function makes ridiculously easy access database table selection databases pointblank supports validation; accessible supplied keywords \"postgres\" (PostgreSQL), \"mysql\" (MySQL), \"maria\" (MariaDB), \"duckdb\" (DuckDB), \"sqlite\" (SQLite), , driver function ‚Äôd like supply. Added log4r_step() function can used action action_levels() function call (.e., list component fns list). can place call function every condition produce log entry (.e., warn, stop, notify).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"documentation-0-6-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.6.0","text":"Added several articles explain different validation workflows (six ‚Äôem) articles go Information Management workflow. Improved documentation almost functions package; added useful examples. Added table project README keeps everyone apprised project milestones issues closed upcoming release.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"minor-improvements-and-bug-fixes-0-6-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.6.0","text":"Improved appearance agent report: (1) tooltips, (2) tooltips much improved (animate, larger text, snappier previous ones), (3) SVGs now used symbols validation steps instead blurry PNGs, (4) less confusing glyphs now used TBL column, (5) agent label can expressed Markdown looks nicer report, (6) table type (name, supplied tbl_name) shown header, (7) validation threshold levels also shown table header, (8) interrogation starting/ending timestamps shown (along duration) table footer, (9) table font changed less default-y, (10) adjustments table borders cell shading made better readability. get_agent_report() function now lang locale arguments override values set prior (e.g., create_agent()). allows reporting language changed without need re-run everything scratch. set_tbl(), remove_tbl(), set_read_fn(), remove_read_fn() functions can now also used informant object. get_sundered_data() function clear regard validation steps considered splitting data. Using validation steps preconditions must fulfill rule target table single form across steps. is_exact argument new col_schema_match(), expect_col_schema_match(), test_col_schema_match() functions, allowing types validations less stringent. argument loosens requirement include class names column may multiple. Also, can specify NULL entirely skip checking class/type. can now use combinations validation functions conjointly(). validation functions intrinsically operate single test unit (e.g., col_is_*() functions) now work combination validation functions operate n test units (e.g., col_vals_*() functions). lets us test condition columns certain type individual test units fulfill col_vals_*() requirements. Simplified sections argument scan_data() length-1 character vector containing key characters standing section names. Refactored large portion code produces agent report increase rendering speed. Improved printing errors/warnings (tooltips EVAL column agent report) thanks implementation HTML escaping. small version agent report (perfect emailing) now much improved formatting.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-052","dir":"Changelog","previous_headings":"","what":"pointblank 0.5.2","title":"pointblank 0.5.2","text":"CRAN release: 2020-08-28 Fixes performance issue validations larger tables. Improved formatting value ranges agent report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-051","dir":"Changelog","previous_headings":"","what":"pointblank 0.5.1","title":"pointblank 0.5.1","text":"CRAN release: 2020-08-27 Improved compatibility validations performed SQL Server 2019. Integrated label argument validation functions; label available agent x_list , importantly, displayed agent report (STEP column). Added \"combined\" option get_sundered_data() function (type argument). applies categorical (pass/fail) label (settable new pass_fail argument function) new .pb_combined flag column output table. Made several visual improvements agent report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-050","dir":"Changelog","previous_headings":"","what":"pointblank 0.5.0","title":"pointblank 0.5.0","text":"CRAN release: 2020-08-12","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-5-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.5.0","text":"agent can now given table-reading function, used reading data interrogation. tbl provided, function invoked. However, tbl read_fn specified, supplied tbl take priority (useful one-shot interrogations table interactive context). two ways specify read_fn: (1) using function (e.g., function() { <table reading code> }) , (2) R formula expression (e.g., ~ { <table reading code> }). Added set functions setting removing agent‚Äôs association data table (set_tbl() remove_tbl()) table-reading function (set_read_fn() remove_read_fn()). validation functions now step_id parameter. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. Supplying step_id optional; pointblank automatically generate step ID value (based step index) ‚Äôs provided. Added new functions reading writing YAML (, called pointblank YAML). pointblank YAML file can generated agent using agent_yaml_write() function. ‚Äôre always free create pointblank YAML hand, , can edit/extend existing pointblank YAML file. agent can created pointblank YAML agent_yaml_read() function. ‚Äôs also possible interrogate target data table right pointblank YAML using agent_yaml_interrogate(). agent_write() agent_read() functions added; allow saving agent disk reading agent back disk. Saved--disk agents still retain validation plans, intel interrogations, reference target table (read_fn value) even entire target table (requested). Reading agent disk agent_read() allows us use post-interrogation functions (e.g., get_agent_x_list(), get_data_extracts(), get_agent_report(), etc.) though interrogation just occurred. pointblank now compatible Spark DataFrames sparklyr package. Simply use tbl_spark object specifying target table create_agent(), set_tbl(), scan_data().","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"minor-improvements-and-bug-fixes-0-5-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.5.0","text":"issue showing agent report table email message body via email_blast() function resolved. Resolved issue using literal character values comparison-based validation functions (e.g., col_vals_between(), col_vals_gt(), etc.). Completely rewrote underlying processes storage retrieval translation text. Much improved translations reporting text Spanish German languages. Thanks @pachamaltese @DavZim valuable contributions! New testthat tests added test pointblank validations mock PostgreSQL MySQL database tables via dittodb package. Thank @pachamaltese implementing tests.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-040","dir":"Changelog","previous_headings":"","what":"pointblank 0.4.0","title":"pointblank 0.4.0","text":"CRAN release: 2020-06-22","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-r-markdown-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New R Markdown features","title":"pointblank 0.4.0","text":"New R Markdown validation feature allows validation testing within specialized validation code chunks validate = TRUE option set. Using pointblank validation functions data marked code chunks flag overall failure stop threshold exceeded anywhere. errors reported validation code chunk rendering document HTML, green red status buttons indicate whether validations succeeded failures occurred. Clicking button reveals otherwise hidden validation statements error messages (). Using pointblank R Markdown workflow enabled default pointblank library loaded. framework testing set default, new validate_rmd() function offers opportunity set UI logging options. Added R Markdown template new R Markdown validation feature (Pointblank Validation). new stop_if_not() function works well standalone, replacement stopifnot() also customized use validation checks R Markdown documents pointblank loaded. Using stop_if_not() code chunk validate = TRUE option set yield correct reporting successes failures whereas stopifnot() . knit.print() method added facilitate printing agent report table within R Markdown code chunk.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"breaking-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"pointblank 0.4.0","text":"default behavior using validation step functions (e.g., col_vals_lt()) directly data tables changed. , single test unit failure trigger warning. Now, single test unit failing results error. Going back earlier behavior now requires use actions = warn_on_fail() (new helper function, default warn_at threshold value 1) invocation validation step function. stop_on_fail() helper function also new release, stop_at threshold parameter, also default 1.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.4.0","text":"Added 24 expectation functions (e.g., expect_col_exists(), expect_rows_distinct(), expect_col_schema_match(), etc.) complements 24 validation functions. can used testthat tests tabular data simplified interface exposes easy--use failure threshold (defaulting 1). Added 24 test functions (e.g., test_col_exists(), test_rows_distinct(), test_col_schema_match(), etc.) complement 24 validation functions. functions return logical value: TRUE threshold (default 1) exceeded, FALSE otherwise. test_*() functions use simplified interface expect_*() functions. Added col_vals_expr(), expect_col_vals_expr(), test_col_vals_expr() validation, expectation, test functions, making easier DIY validations. dplyr expr(), case_when(), () functions re-exported easier accessibility since work exceedingly well new functions. col_schema_match() (expect test analogues) gained new arguments: complete in_order. allow relaxation constraints related completeness ordering columns defined col_schema object (created col_schema()). preconditions argument available validation, expectation, test functions now accepts formula function values (previously, formula values accepted). get_agent_report() function now size argument option get agent report table \"standard\" (width: 875px) size \"small\" size (width: 575px); previously option accessible .... appearance agent report improved ‚Äôs gained new features: (1) data extracts failing rows (row-based validation steps) can downloaded CSVs via new buttons appear EXT column, (2) useful tooltips fields table (e.g., hovering items STEP show brief, TBL icons describe whether preconditions applied table prior interrogation, etc.), (3) printing improvements COLUMNS VALUES columns (e.g., table columns distinguished literal values). Improved appearance email message generated email_blast() email_preview(). email message, using stock_msg_body() stock_msg_footer() defaults msg_body msg_footer, embeds \"small\" version agent report provides introductory text nicer formatting .","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"documentation-improvements-0-4-0","dir":"Changelog","previous_headings":"","what":"Documentation improvements","title":"pointblank 0.4.0","text":"functions now revised documentation complete, examples, consistent across many validation, expectation, test functions. package README now contains better graphics, reworked examples, new section package‚Äôs design goals (listing R packages also focus table validation).","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"minor-improvements-and-bug-fixes-0-4-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.4.0","text":"Rewrote internal stock_stoppage() stock_warning() functions generated error warning messages match whether validation functions used directly data expectation functions used. Console status messages performing interrogation now appear interactive session. longer appear R Markdown rendering execution unattended scripts. col_vals_regex() validation function (plus associated expectation test functions) can now used database tables (DB types support regular expressions). tested MySQL PostgreSQL, differing underlying SQL implementations. col_schema() function now allows either uppercase lowercase SQL column types (using .db_col_types = \"sql\"). Previously, supplying SQL columns types uppercase (e.g., ‚ÄúINT‚Äù, ‚ÄúTINYINT‚Äù, etc.) always fail validation SQL column types target table captured lowercase values create_agent() call. Many new tests added cover new functions existing functions. ‚Äôs important validation package testing comprehensive rigorous, , continue focus forthcoming releases. Fixed duration label bug console status messages appear interrogation (now consistently values reported seconds) Added column validity checks inside internal interrogate_*() functions","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-031","dir":"Changelog","previous_headings":"","what":"pointblank 0.3.1","title":"pointblank 0.3.1","text":"Fixed implementation col_vals_between() col_vals_not_between() step functions work tbl_dbi objects. Added scan_data() function, thoroughly scans table data can understand better (giving HTML report). Added get_agent_x_list() function provide easy access agent intel Added get_agent_report() function give fine control agent‚Äôs gt-based reportage; also, agent‚Äôs default print method now report (default appearance options) Added get_sundered_data() function split table data ‚Äòpass‚Äô ‚Äòfail‚Äô pieces interrogation Added col_schema_match() validation step function; works conjunction col_schema object (generated col_schema() function) help determine whether expected schema matches target table. Added multilingual support reports generated agent validations produced new scan_data() function fully integrates gt (tables reports) blastula (email production delivery) packages Numerous fixes ensure compatibility tibble 3.0.0","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-030","dir":"Changelog","previous_headings":"","what":"pointblank 0.3.0","title":"pointblank 0.3.0","text":"CRAN release: 2020-01-10 pointblank package changed significantly previous version favor consistency simplicity, better reporting, increased power. internals extensively refactored API accordingly gone revisions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"breaking-changes-0-3-0","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"pointblank 0.3.0","text":"focus_on() function removed favor directly using data object. means single use create_agent() can now work single table time (create_agent() now tbl argument). Also, input tbl can data.frame, tbl_df, tbl_dbi object. preconditions argument changed can now used temporarily transform table (.e., transforming particular validation step). Previously, option filter input table now ‚Äôs possible useful things like joining table, adding columns, filtering rows, etc. preconditions args now accepts list expressions manipulate table data. action_levels() helper function introduced work actions argument (every validation step function). replaces warn_count, stop_count, notify_count, warn_fraction, stop_fraction, notify_fraction arguments. function allows evaluation functions (given fns argument) reaction exceeding thresholds specified warn_at, stop_at, notify_at. using validation step functions directly data (.e., use create_agent()), data now passed straight validation step. purpose now mode create warnings throw errors warn stop thresholds exceeded. Across pointblank validation step functions, argument stands table columns normalized columns. incl_na argument, implemented validation step functions, renamed na_pass better indicate purpose (consider encountered NA values passing test units), , use expanded relevant functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"new-features-0-3-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"pointblank 0.3.0","text":"‚Äôs now possible use vars() certain tidyselect select helpers (e.g., starts_with()) defining columns pointblank validation step functions. conjointly() function new validation step function allows multiple rowwise validation steps performed joint validity testing.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-021","dir":"Changelog","previous_headings":"","what":"pointblank 0.2.1","title":"pointblank 0.2.1","text":"CRAN release: 2019-09-12 Revisions account API changes tidyr 1.0.0. Incorporates corrections related API changes rlang 0.2.0.","code":""},{"path":"https://rich-iannone.github.io/pointblank/es/news/index.html","id":"pointblank-01","dir":"Changelog","previous_headings":"","what":"pointblank 0.1","title":"pointblank 0.1","text":"CRAN release: 2017-08-22 First release.","code":""}]
