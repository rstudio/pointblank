[{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://rich-iannone.github.io/pointblank/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others‚Äô private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://rich-iannone.github.io/pointblank/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://rich-iannone.github.io/pointblank/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://rich-iannone.github.io/pointblank/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement riannone@.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://rich-iannone.github.io/pointblank/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://rich-iannone.github.io/pointblank/CODE_OF_CONDUCT.html","id":"1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://rich-iannone.github.io/pointblank/CODE_OF_CONDUCT.html","id":"2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://rich-iannone.github.io/pointblank/CODE_OF_CONDUCT.html","id":"3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://rich-iannone.github.io/pointblank/CODE_OF_CONDUCT.html","id":"4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://rich-iannone.github.io/pointblank/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.0, available https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines inspired Mozilla‚Äôs code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://rich-iannone.github.io/pointblank/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Information and Guidelines for Contributing to pointblank","title":"Information and Guidelines for Contributing to pointblank","text":"many ways contribute ongoing development pointblank package. contributions can rather easy (e.g., fixing typos, improving documentation, filing issues feature requests problems, etc.) whereas contributions can require time patience (like answering questions submitting pull requests code changes). Just know help provided capacity much appreciated. :)","code":""},{"path":"https://rich-iannone.github.io/pointblank/CONTRIBUTING.html","id":"filing-issues","dir":"","previous_headings":"","what":"Filing Issues","title":"Information and Guidelines for Contributing to pointblank","text":"believe found bug, create minimal reprex posting pointblank issue tracker. Try include anything unnecessary, just minimal amount code constitutes reproducible bug. try verify bug running code reprex provided. quality reprex reduce amount back--forth communication trying understand execute code systems.","code":""},{"path":"https://rich-iannone.github.io/pointblank/CONTRIBUTING.html","id":"answering-questions","dir":"","previous_headings":"","what":"Answering questions","title":"Information and Guidelines for Contributing to pointblank","text":"great way help simply answering questions. ‚Äôs amazing little conversation lead better insights problem. Don‚Äôt quite know answer? ‚Äôs okay . ‚Äôre together. might answer user questions? forums Q&pointblank include RStudio community, Twitter (good search term pointblank #rstats), Stack Overflow. Good etiquette key interactions: good person ask questions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/CONTRIBUTING.html","id":"making-pull-requests","dir":"","previous_headings":"Answering questions","what":"Making Pull Requests","title":"Information and Guidelines for Contributing to pointblank","text":"consider making pull request (PR), please file issue first explain problem detail. PR enhancement, detail change make things better package users. Bugfix PRs also requre explanation bug proposed fix remove bug. great way illustrate bug include reprex. upfront work prior preparing PR can time-consuming opens line communication package authors community, perhaps leading better enhancement effective fixes! consensus PR based issue helpful, adhering following process make things proceed quickly: Create separate Git branch PR. Look GitHub Actions build status badges making changes; badges available package README. pointblank package follows tidyverse style guide please adopt style guidelines submitted code best possible. internal documentation uses roxygen2; contribution requires new revised documentation ensure roxygen comments added/modified (modify .Rd files man folder). use testthat code coverage; contributions test cases included helpful easier accept. Add bullet top NEWS.md current development version header describing user-facing changes made; include GitHub username, links relevant issue(s)/PR(s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2017-2021 Richard Iannone Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/PULL_REQUEST_TEMPLATE.html","id":null,"dir":"","previous_headings":"","what":"Summary","title":"Summary","text":"Thank contributing pointblank! make process easier everyone, please explain context purpose contribution. Also, list changes made existing code documentation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/PULL_REQUEST_TEMPLATE.html","id":"related-github-issues-and-prs","dir":"","previous_headings":"","what":"Related GitHub Issues and PRs","title":"Summary","text":"Ref: #","code":""},{"path":"https://rich-iannone.github.io/pointblank/PULL_REQUEST_TEMPLATE.html","id":"checklist","dir":"","previous_headings":"","what":"Checklist","title":"Summary","text":"understand agree Code Conduct. listed major changes NEWS. added testthat unit tests tests/testthat new functionality.","code":""},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-1.html","id":"starting-with-a-simple-example","dir":"Articles","previous_headings":"","what":"Starting with a Simple Example","title":"Intro to Information Management","text":"workflow somewhat similar concept usage Data Quality Reporting Workflow (VALID-). Instead agent, use informant get informant create_informant() function. point informant target table can data frame, tibble, database table (tbl_dbi object), Spark DataFrame (tbl_spark object). small_table dataset included pointblank package. ‚Äôs small, uninteresting dataset ‚Äôs useful simple examples. looks like: Let‚Äôs use small_table object see results introducing informant. Printing informant show us automatically-generated information small_table dataset, adding Columns section.  Alternatively can get report get_informant_report() access additional output options, like producing narrower version output.  Either way, get initial reporting basic. done next add information following set info_*() functions: info_tabular(): Add information focuses aspects data table whole info_columns(): Add information focuses aspects data table‚Äôs columns info_section(): Add information focuses key aspect data table Let‚Äôs try adding information functions look resulting report.  can seen, report bit filled information. TABLE COLUMNS sections prescribed order new section named INFORMATION follows (one subsection called EXAMPLES DOCUMENTATION). Let‚Äôs explore three different info_*() functions work.","code":"small_table ## # A tibble: 13 √ó 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Example No. 1\"   ) informant get_informant_report(informant, size = \"small\") informant <-   create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Example No. 2\"   ) %>%   info_tabular(     description = \"This table is included in the **pointblank** pkg.\"   ) %>%   info_columns(     columns = \"date_time\",     info = \"This column is full of timestamps.\"   ) %>%   info_section(     section_name = \"further information\",      `examples and documentation` = \"Examples for how to use the `info_*()` functions     (and many more) are available at the      [**pointblank** site](https://rich-iannone.github.io/pointblank/).\"   )  informant"},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-1.html","id":"the-table-section-and-info_tabular","dir":"Articles","previous_headings":"","what":"The TABLE Section and info_tabular()","title":"Intro to Information Management","text":"info_tabular() function adds information TABLE section. use named arguments define subsection names content. previous example info_tabular(description = \"table included **pointblank** pkg.\") used make DESCRIPTION subsection (section titles automatically capitalized), info text Markdown text \"table included **pointblank** pkg.\". can define many subsections TABLE section need, either info_tabular() call across multiple calls. want use complicated subsection names single word, can enclose text back ticks. example, put emoji subsection name? excerpt complete report, showing just report header TABLE section.  TABLE section great place put information table needs front center. Examples useful topics section might include: high-level summary table, stating purpose importance row table represents main users table within organization description table generated information frequency updates","code":"informant %>%    info_tabular(`üîÑ updates` = \"This table is not regularly updated.\")"},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-1.html","id":"the-columns-section-and-info_columns","dir":"Articles","previous_headings":"","what":"The COLUMNS Section and info_columns()","title":"Intro to Information Management","text":"section follows TABLE section COLUMNS. section provides opportunity describe table column much detail necessary. , individual columns serve subsections (automatically generated upon using create_informant()) can subsections within column well. interesting thing information provided via info_columns() information additive. can make multiple calls info_columns() disperse common pieces info text multiple columns append text existing. Let‚Äôs take look practice far interesting palmerpenguins::penguins dataset. , fill information column adapting documentation palmerpenguins package.  able provide subsections name ‚ÑπÔ∏è , furthermore, use tidyselect functions like ends_with() append info text common subsection exists across multiple columns. useful stating units common across three columns: bill_length_mm, bill_depth_mm, flipper_length_mm. following tidyselect functions available pointblank make process easier: starts_with(): Match columns start prefix. ends_with(): Match columns end suffix. contains(): Match columns contain literal string. matches(): Perform matching regular expression. everything(): Select columns.","code":"informant_pp <-    create_informant(     read_fn = ~ palmerpenguins::penguins,     tbl_name = \"penguins\",     label = \"The `penguins` dataset from the **palmerpenguins** üì¶.\"   ) %>%    info_columns(     columns = \"species\",     `‚ÑπÔ∏è` = \"A factor denoting penguin species (*Ad√©lie*, *Chinstrap*, and *Gentoo*).\"   ) %>%   info_columns(     columns = \"island\",     `‚ÑπÔ∏è` = \"A factor denoting island in Palmer Archipelago, Antarctica     (*Biscoe*, *Dream*, or *Torgersen*).\"   ) %>%   info_columns(     columns = \"bill_length_mm\",     `‚ÑπÔ∏è` = \"A number denoting bill length\"   ) %>%   info_columns(     columns = \"bill_depth_mm\",     `‚ÑπÔ∏è` = \"A number denoting bill depth\"   ) %>%   info_columns(     columns = \"flipper_length_mm\",     `‚ÑπÔ∏è` = \"An integer denoting flipper length\"   ) %>%   info_columns(     columns = ends_with(\"mm\"),     `‚ÑπÔ∏è` = \"(in units of millimeters).\"   ) %>%   info_columns(     columns = \"body_mass_g\",     `‚ÑπÔ∏è` = \"An integer denoting body mass (grams).\"   ) %>%   info_columns(     columns = \"sex\",     `‚ÑπÔ∏è` = \"A factor denoting penguin sex (`\\\"female\\\"`, `\\\"male\\\"`).\"   ) %>%   info_columns(     columns = \"year\",     `‚ÑπÔ∏è` = \"The study year (e.g., `2007`, `2008`, `2009`).\"   )  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-1.html","id":"extra-sections-and-info_section","dir":"Articles","previous_headings":"","what":"Extra Sections and info_section()","title":"Intro to Information Management","text":"information can‚Äôt don‚Äôt want put TABLE COLUMNS sections, can place extra sections (subsections) info_section() function. sections go aforementioned sections order creation. Let‚Äôs put together extra sections describe palmerpenguins::penguins dataset. excerpt complete report, showing just SOURCE section footer.  types information go well separate sections? ideas : info related source data table (e.g., references, background, etc.) definitions/explanations terms used persons responsible data table, perhaps contact information details table produced important issues table notes upcoming changes links information artifacts pertain table information report (meta!); might include things like update history, persons responsible, instructions contribute, etc. Really, sky limit ! can incorporate great deal useful information use process generate reports important tables within organization. ‚Äôs can done. go next phase (Advanced Information Management article). go way now, total transformation. think ‚Äôre ready?","code":"informant_pp <-    informant_pp %>%   info_section(     section_name = \"source\",     \"References\" = c( \"- Ad√©lie penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural  size measurements and isotopic signatures of foraging among adult male and female  Ad√©lie penguins (Pygoscelis adeliae) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental Data Initiative <https://doi.org/10.6073/pasta/98b16d7d563f265cb52372c8ca99e60f>\",  \"- Gentoo penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural size measurements and isotopic signatures of foraging among adult male and female Gentoo penguin (Pygoscelis papua) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental Data Initiative <https://doi.org/10.6073/pasta/7fca67fb28d56ee2ffa3d9370ebda689>\",  \"- Chinstrap penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural size measurements and isotopic signatures of foraging among adult male and female Chinstrap penguin (Pygoscelis antarcticus) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 6. Environmental Data Initiative <https://doi.org/10.6073/pasta/c14dfcfada8ea13a17536e73eb6fbe9e> \"     ),     \"Note\" = \" Originally published in: Gorman KB, Williams TD, Fraser WR (2014) Ecological Sexual Dimorphism and Environmental Variability within a Community of Antarctic Penguins (Genus Pygoscelis). PLoS ONE 9(3): e90081. doi:10.1371/journal.pone.0090081 \" )  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-2.html","id":"getting-snippets-of-useful-text-with-the-info_snippet-function","dir":"Articles","previous_headings":"","what":"Getting Snippets of Useful Text With the info_snippet() Function","title":"Advanced Information Management","text":"great source information table can table . Suppose want show categorical values particular column. Maybe ‚Äôd like display range values important numeric column. Perhaps show KPI values can calculated using data table? can done info_snippet() function. give snippet name give function call. Let‚Äôs small_table dataset available pointblank. table looks like: wanted mean value data column d rounded one decimal place, one way expression: Inside info_snippet() call, used creating informant object, expression look like : small_table dataset associated informant target table, , ‚Äôs represented leading . functional sequence given fn. ‚Äôs important note ‚Äôs leading ~, making expression RHS formula (don‚Äôt want execute anything , time). Lastly, snippet given name \"mean_d\". know snippet produce value 2304.7 can ? put value info text use snippet_name key. works similarly glue package text interpolation, ‚Äôs continuation example: Within text, ‚Äôs use curly braces name snippet. ‚Äôs 2304.7 value inserted. methodology inserting computed values snippets can performed wherever info text provided (either info_tabular(), info_columns(), info_section() functions). Let‚Äôs take look report printing informant object  Hmm. \"... {mean_d} ...\" text report replaced mean value column d. gives? Well, ‚Äôs one finalizing step needs done always done wrap Information Management workflow use incorporate() function. Let‚Äôs write whole thing finish call incorporate().  time, sweet success. value appears overall formatting looks great! useful thing, long remember use incorporate() function make happen (next section).","code":"small_table ## # A tibble: 13 √ó 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high small_table %>% .$d %>% mean() %>% round(1) ## [1] 2304.7 informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Example No. 2\"   ) %>%   info_snippet(     snippet_name = \"mean_d\",     fn = ~ . %>% .$d %>% mean() %>% round(1)   ) informant <-    informant %>%   info_columns(     columns = vars(d),     info = \"This column contains fairly large numbers (much larger than     those numbers in column `a`. The mean value is {mean_d}, which is     far greater than any number in that other column.\"   ) informant informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"Example No. 2\"   ) %>%   info_snippet(     snippet_name = \"mean_d\",     fn = ~ . %>% .$d %>% mean() %>% round(1)   ) %>%     info_columns(     columns = vars(d),     info = \"This column contains fairly large numbers (much larger than     those numbers in column `a`. The mean value is {mean_d}, which is     far greater than any number in that other column.\"   ) %>%   incorporate()  informant"},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-2.html","id":"ensuring-that-snippets-and-other-table-metadata-element-are-up-to-date","dir":"Articles","previous_headings":"","what":"Ensuring That Snippets (and Other Table Metadata Element) Are Up-to-Date","title":"Advanced Information Management","text":"Tables can change time. Whether data source public dataset, organization‚Äôs data table, continually-updated Excel file (üò±), ready change. previous example, used incorporate() function finalize report. Without , snippet didn‚Äôt work. two major things incorporate() Information Management workflow. Evaluation text snippets info_snippet() calls, , insertion snippets info text within \"{<snippet_name>}\". Updating table row column counts header report. really incorporating aspects table report incorporate() might might also think regenerating, refreshing, renewing table. gives pointblank license access table way interrogate() VALID-validation workflow. first use incorporate(), text snippets put places; subsequent uses incorporate() replace appropriate text necessary. Every use incorporate() update row column counts header. ‚Äôs short demo header changing, ‚Äôs pretty instructive. Let‚Äôs use small_table object target_table. dim() can totally sure table dimensions. Let‚Äôs allow informant access target_table read_fn argument. case, expression ~ target_table (simply gets table global workspace). using incorporate() printing informant_tt object, let‚Äôs just examine header. excerpt complete report, showing just header.  number rows columns reported header checks : 13 rows 8 columns. Now, let‚Äôs manually enlarge target_table print new row column counts. ‚Äôve got informant object, let‚Äôs see incorporate() keeps pace change. excerpt complete report, showing just header.  Great! Using incorporate() accurately updated reporting row column counts header. ‚Äôs also much worth noting use read_fn important . target_table given tbl argument create_informant(), table bound informant initial state (13 rows 8 columns) updates table wouldn‚Äôt reflected reporting upon using incorporate(). table-reading function meant obtaining table every time table needed. short, unless uses info_snippet() table isn‚Äôt expected change, ‚Äôs recommended use incorporate() final call workflow.","code":"target_table <- small_table  dim(target_table) ## [1] 13  8 informant_tt <-    create_informant(     read_fn = ~ target_table,     tbl_name = \"target_table\",     label = \"Example No. 3\"   ) %>%   incorporate()  informant_tt target_table <-    dplyr::bind_rows(small_table, small_table) %>%   dplyr::mutate(g = a + c)  dim(target_table) ## [1] 26  9 informant_tt %>% incorporate()"},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-2.html","id":"helpful-pointblank-functions-that-work-exceedingly-well-with-info_snippet","dir":"Articles","previous_headings":"","what":"Helpful pointblank Functions that Work Exceedingly Well with info_snippet()","title":"Advanced Information Management","text":"functions available pointblank make much easier get commonly-used text snippets. begin snip_ prefix : snip_list(): Gets list column categories snip_lowest(): Gets lowest value column snip_highest(): Gets highest value column functions can used directly fn value don‚Äôt specify table since assumed target table ‚Äôll snipping data . Let‚Äôs look action.","code":""},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-2.html","id":"the-snip_list-function","dir":"Articles","previous_headings":"","what":"The snip_list() Function","title":"Advanced Information Management","text":"describing aspect target table, may want extract values column include piece info text. ‚Äôd want values nicely formatted list (commas) ‚Äôd probably prefer constrained certain size (potentially generate massive amounts text). can efficiently done snip_list(). Let‚Äôs experiment combination snip_list() info_snippet(), extending palmerpenguins example Intro Information Management article. excerpt complete report, showing just header part COLUMNS section.  seemed work quite well. need determining strings hardcoding info text, snip_list() work . also works numeric values. Let‚Äôs use snip_list() provide text snippet based values year column (integer column): excerpt complete report, showing just bottom COLUMNS section footer.  , issues formatting display values. got info text \"study year (\"2007\", \"2008\", \"2009\" ).\" efforts saved us determine , plus, data updated new year values, reflected info text upon using incorporate(). Refreshed info text really provides huge benefits, especially data changes lot (e.g., database tables).","code":"informant_pp <-    create_informant(     read_fn = ~ palmerpenguins::penguins,     tbl_name = \"penguins\",     label = \"The `penguins` dataset from the **palmerpenguins** üì¶.\"   ) %>%    info_columns(     columns = \"species\",     `‚ÑπÔ∏è` = \"A factor denoting penguin species ({species_snippet}).\"   ) %>%   info_columns(     columns = \"island\",     `‚ÑπÔ∏è` = \"A factor denoting island in Palmer Archipelago, Antarctica     ({island_snippet}).\"   ) %>%   info_snippet(     snippet_name = \"species_snippet\",     fn = snip_list(column = \"species\")   ) %>%   info_snippet(     snippet_name = \"island_snippet\",     fn = snip_list(column = \"island\")   ) %>%   incorporate()  informant_pp informant_pp <-   informant_pp %>%   info_columns(     columns = \"year\",     `‚ÑπÔ∏è` = \"The study year ({year_snippet}).\"   ) %>%   info_snippet(     snippet_name = \"year_snippet\",     fn = snip_list(column = \"year\")   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-2.html","id":"the-snip_lowest-and-snip_highest-functions","dir":"Articles","previous_headings":"","what":"The snip_lowest() and snip_highest() Functions","title":"Advanced Information Management","text":"can get lowest highest values column inject formatted values info_text. Let‚Äôs measured values penguins dataset snip_lowest() snip_highest().  can see report output can creatively use lowest highest values obtained snip_lowest() snip_highest() specify range simply show maximum value. ordering info_columns() calls example affects overall layout text (text appending behavior), placement info_snippet() calls matter. , , must use incorporate() update text snippets render appropriate locations (inside {<snippet_name>}).","code":"informant_pp <-   informant_pp %>%   info_columns(     columns = \"bill_length_mm\",     `‚ÑπÔ∏è` = \"A number denoting bill length\"   ) %>%   info_columns(     columns = \"bill_depth_mm\",     `‚ÑπÔ∏è` = \"A number denoting bill depth (in the range of     {min_depth} to {max_depth} millimeters).\"   ) %>%   info_columns(     columns = \"flipper_length_mm\",     `‚ÑπÔ∏è` = \"An integer denoting flipper length\"   ) %>%   info_columns(     columns = matches(\"length\"),     `‚ÑπÔ∏è` = \"(in units of millimeters).\"   ) %>%   info_columns(     columns = \"flipper_length_mm\",     `‚ÑπÔ∏è` = \"Largest observed is {largest_flipper_length} mm.\"   ) %>%   info_snippet(     snippet_name = \"min_depth\",     fn = snip_lowest(column = \"bill_depth_mm\")   ) %>%   info_snippet(     snippet_name = \"max_depth\",     fn = snip_highest(column = \"bill_depth_mm\")   ) %>%   info_snippet(     snippet_name = \"largest_flipper_length\",     fn = snip_highest(column = \"flipper_length_mm\")   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-2.html","id":"text-tricks","dir":"Articles","previous_headings":"","what":"Text Tricks","title":"Advanced Information Management","text":"info text can jazzed Markdown, extra tricks make authoring text bit pleasurable. know text tricks ‚Äôll able express information many interesting ways.","code":""},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-2.html","id":"links-and-dates","dir":"Articles","previous_headings":"","what":"Links and Dates","title":"Advanced Information Management","text":"links text, pointblank try identify style nicely. amounts using pleasing, light-blue color underlines appear hover. doesn‚Äôt take much style links require something. , Markdown links written < link url > [ link text ]( link url ) get transformation treatment. Sometimes want dates stand text. Try enclosing date expressed ISO-8601 standard parentheses, like : (2004-12-01). happen date set monospaced variation reporting font, , underlined striking shade purple. ‚Äôs might use features otherwise adding information palmerpenguins reporting: excerpt complete report, showing just TABLE section header.","code":"informant_pp <-   informant_pp %>%   info_tabular(     `R dataset` = \"The goal of `palmerpenguins` is to provide a great dataset     for data exploration & visualization, as an alternative to `iris`. The     latest CRAN release was published on (2020-07-25).\",     `data collection` = \"Data were collected and made available by Dr. Kristen     Gorman and the [Palmer Station, Antarctica LTER](https://pal.lternet.edu),     a member of the [Long Term Ecological Research Network](https://lternet.edu).\",     citation = \"Horst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer      Archipelago (Antarctica) penguin data. R package version 0.1.0.     <https://allisonhorst.github.io/palmerpenguins/>.      doi: 10.5281/zenodo.3960218.\"   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-2.html","id":"labels","dir":"Articles","previous_headings":"","what":"Labels","title":"Advanced Information Management","text":"can take portions text present labels. help call important attributes short form may eliminate need oft-repeated statements. might apply labels signify priority, category, information find useful. two options, Use double parentheses around text capture rectangular label: ((label text)) Use triple parentheses capture text rounded-rectangular label: (((label text))) excerpt complete report, showing just COLUMNS ADDITIONAL NOTES sections.","code":"informant_pp <-   informant_pp %>%   info_columns(     columns = vars(body_mass_g),      `‚ÑπÔ∏è` = \"An integer denoting body mass.\"   ) %>%   info_columns(     columns = c(ends_with(\"mm\"), ends_with(\"g\")),     `‚ÑπÔ∏è` = \"((measured))\"       ) %>%   info_section(     section_name = \"additional notes\",     `data types` = \"(((factor))) (((numeric))) (((integer)))\"   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/articles/INFO-2.html","id":"get-stylin","dir":"Articles","previous_headings":"","what":"Get Stylin‚Äô","title":"Advanced Information Management","text":"want use CSS styles spans info text, ‚Äôs possible following construction: [[ info text ]]<< CSS style rules >> ‚Äôs important ensure CSS rule concluded ; character syntax. Styling word factor inside piece info text might look like : [[factor]]<<color: red; font-weight: 300;>> value. result looks something like :  many CSS style rules can used. ‚Äôs sample useful ones: color: <color value>; (text color) background-color: <color value>; (text‚Äôs background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); Continuing palmerpenguins reporting, ‚Äôll add info text take opportunity add CSS style rules using [[ ]]<< >> syntax. excerpt complete report, showing just bottom COLUMNS section, ADDITIONAL NOTES section, footer.  info_columns() info_section() function calls, able style single word (underline) even style labels (changing border background colors). syntax somewhat forgiving, allowing put line breaks ]] << style rules lines markup don‚Äôt overly long. , think text tricks? got admit can spice proceedings. inevitably added development pointblank proceeds. ‚Äôs now. Don‚Äôt think ‚Äôve enough?","code":"informant_pp <-   informant_pp %>%   info_columns(     columns = vars(sex),      `‚ÑπÔ∏è` = \"A [[factor]]<<text-decoration: underline;>>      denoting penguin sex (female or male).\"   ) %>%   info_section(     section_name = \"additional notes\",     keywords = \"     [[((penguins))]]<<border-color: platinum; background-color: #F0F8FF;>>      [[((Antarctica))]]<<border-color: #800080; background-color: #F2F2F2;>>      [[((measurements))]]<<border-color: #FFB3B3; background-color: #FFFEF4;>>     \"   ) %>%   incorporate()  informant_pp"},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-I.html","id":"the-elements-of-this-workflow-an-agent-validation-functions-and-interrogate","dir":"Articles","previous_headings":"","what":"The Elements of this Workflow: an agent, validation functions, and interrogate()","title":"Introduction to the **Data Quality Reporting** Workflow (**VALID-I**)","text":"agent need workflow created create_agent() function. agent can handle one target table given time two different arguments can used specify table. first tbl, input table directly supplied agent. Alternatively, function can used read input data table read_fn argument one two ways: (1) using function (e.g., function() { <table reading code> }) , (2) R formula expression (e.g., ~ <table reading code>). agent needs directives table, , provide validation functions. check existence type column (col_exists() group col_is_*() functions). Others check cell column satisfying specific condition (col_vals_*() functions). can use many necessary satisfactory validation testing table question. certainly quite , ‚Äôs list validation functions questioning phrase function‚Äôs purpose: col_vals_lt(): column data less specified value? col_vals_lte(): column data less equal specified value? col_vals_equal(): column data equal specified value? col_vals_not_equal(): column data equal specified value? col_vals_gte(): column data greater equal specified value? col_vals_gt(): column data greater specified value? col_vals_between(): column data two specified values? col_vals_not_between(): column data two specified values? col_vals_in_set(): column data part specified set values? col_vals_not_in_set(): data part specified set values? col_vals_null(): column data NULL/NA? col_vals_not_null(): column data NULL/NA? col_vals_regex(): strings column data match regex pattern? col_vals_expr(): column data agree predicate expression? conjointly(): multiple rowwise validations result joint validity? rows_distinct(): row data distinct? col_is_character(): columns contain character/string data? col_is_numeric(): columns contain numeric values? col_is_integer(): columns contain integer values? col_is_logical(): columns contain logical values? col_is_date(): columns contain R Date objects? col_is_posix(): columns contain POSIXct dates? col_is_factor(): columns contain R factor objects? col_exists(): one columns actually exist? col_schema_match(): columns table (types) match predefined schema? final function needs called interrogate() function. validation functions, called agent object, don‚Äôt act target table interrogate() used. interrogation, usage validation functions serves instructions. interrogation phase instructions turn actions, agent carrying steps interrogation plan.","code":""},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-I.html","id":"a-simple-example-with-the-basics","dir":"Articles","previous_headings":"","what":"A Simple Example with the Basics","title":"Introduction to the **Data Quality Reporting** Workflow (**VALID-I**)","text":"examples going forward, ‚Äôll use small_table dataset. ‚Äôs included pointblank package. isn‚Äôt large, makes great simple examples. entirety: follows simple validation plan. test : date_time column indeed date-time column column f values \"low\", \"mid\", \"high\" values column less 10 strings column b fit particular regex pattern (\"^[0-9]-[-z]{3}-[0-9]{3}$\") column d values range 0 5000 (entirely true!) validation plan written interrogated. carried interactively, ‚Äôll get status messages describe interrogation going. five OK messages means individual validations five validation steps passed within failure threshold levels. Since failure thresholds actually weren‚Äôt set, steps always display OK unless evaluation error occurred. Printing agent object gives step--step breakdown interrogation process.  Let‚Äôs look interpret report. bright green color strips left validation step indicates test units passed validation. lighter green color final step means least one failing unit. STEP column provides name validation function used basis validation step. COLUMNS shows us target column validation step. VALUES column lists values required validation step. TBL? indicates whether table mutated just interrogation validation step (via preconditions argument, available every validation function). right-facing arrows indicate table didn‚Äôt undergo transformation, working identity table every step. EVAL lets us know whether issues evaluating table (catching R errors warnings); checkmarks column show us issues interrogation. total number test units provided next ... column, absolute number fraction passing test units (PASS) failing test units (FAIL). W, S, N indicators tell us whether entered either WARN, STOP, NOTIFY states validation steps. didn‚Äôt set threshold levels states (can done actions argument, later), irrelevant report. Finally, EXT column provides opportunity download data extract rows CSV. rows represent rows failed test units. step 5, col_vals_between() validation step, data extract available (1 row). can either download CSV report examine extract R get_data_extracts() function: Recall validation step 5 asserted values column d 0 5000, however, extract small_table shows column d value 10000 lies outside specified range.","code":"small_table ## # A tibble: 13 √ó 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high agent <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"VALID-I Example No. 1\"   ) %>%   col_is_posix(vars(date_time)) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\", \"high\")) %>%   col_vals_lt(vars(a), value = 10) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\") %>%   col_vals_between(vars(d), left = 0, right = 5000) %>%   interrogate() ‚îÄ‚îÄ Interrogation Started - there are 5 steps ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚úì Step 1: OK. ‚úì Step 2: OK. ‚úì Step 3: OK. ‚úì Step 4: OK. ‚úì Step 5: OK.  ‚îÄ‚îÄ Interrogation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ agent get_data_extracts(agent, i = 5) ## # A tibble: 1 √ó 8 ##   date_time           date           a b             c      d e     f     ##   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ## 1 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low"},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-I.html","id":"using-threshold-levels-and-actions","dir":"Articles","previous_headings":"","what":"Using Threshold Levels and Actions","title":"Introduction to the **Data Quality Reporting** Workflow (**VALID-I**)","text":"can useful gauge data quality setting failure thresholds validation steps. example, may acceptable point time tolerate 5% failing test units given validation. , several levels data quality might useful instructive, failing test units across validations grouped 0-5%, 5-10%, 10%- bands. can specify failure threshold levels action_levels() function. Using function generates action_levels object can passed actions argument create_agent() (thereby creating default every validation step). following, use relative values (real numbers 0 1) define thresholds WARN STOP conditions. Printing al object gives us summary settings. Let‚Äôs use action_levels object new validation. ‚Äôs similar last one parameters validation functions result failing test units. ‚Äôll see interrogation messages show mention STOP WARNING conditions met. Printing agent provide different agent report seen previously, one ‚Äôs rife yellow red color strips left matching colors far right columns.  ‚Äôs possible invoke function particular failure condition met can set action_levels() function made part action_levels object. One example function can used included log4r_step() function logging failure conditions across validation steps. Let‚Äôs make new action_levels object include logging function WARN STOP failure conditions. Note function calls must written one-sided R formulas. Printing new al object show us failure threshold settings associated actions failure conditions. Using new al object validation workflow result failures certain validation steps logged. default, file named \"pb_log_file\" working directory log4r_step() function flexible allowing log4r appender used. Running following data validation code show us messages R console file \"pb_log_file\" can looked readLines(), showing us four entries (one validation step least WARN condition). log4r_step() function bit special provides severe condition given validation step, long function call present multiple conditions list() given action_levels()‚Äôs fns argument. ‚Äôs possible provide custom-made function generates side effect way log4r_step() used. Just like log4r_step(), custom function can take advantage x variable, x-list validation step. Let‚Äôs take look step 2 (col_vals_in_set validation step) using get_agent_x_list() function: message console shows us ‚Äôs available x, indication output types. wanted know number test units, fraction failed, whether STOP condition entered, can access even put character string (along info x-list). great way test function use validation step ‚Äòaction‚Äô invoked undergo evaluation environment contains x (structure).","code":"al <- action_levels(warn_at = 0.1, stop_at = 0.2) al ‚îÄ‚îÄ The `action_levels` settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ WARN failure threshold of 0.1 of all test units. STOP failure threshold of 0.2 of all test units. ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ agent <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"VALID-I Example No. 2\",     actions = al   ) %>%   col_is_posix(vars(date_time)) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\")) %>%   col_vals_lt(vars(a), value = 7) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-w]{3}-[2-9]{3}$\") %>%   col_vals_between(vars(d), left = 0, right = 4000) %>%   interrogate() ‚îÄ‚îÄ Interrogation Started - there are 5 steps ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚úì Step 1: OK. x Step 2: STOP condition met. ! Step 3: WARNING condition met. x Step 4: STOP condition met. ! Step 5: WARNING condition met.  ‚îÄ‚îÄ Interrogation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ agent al <-    action_levels(     warn_at = 0.1,     stop_at = 0.2,     fns = list(       warn = ~ log4r_step(x),       stop = ~ log4r_step(x)     )   ) al ‚îÄ‚îÄ The `action_levels` settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ WARN failure threshold of 0.1 of all test units. \\fns\\ ~ log4r_step(x) STOP failure threshold of 0.2 of all test units. \\fns\\ ~ log4r_step(x) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ agent <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"VALID-I Example No. 3\",     actions = al   ) %>%   col_is_posix(vars(date_time)) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\")) %>%   col_vals_lt(vars(a), value = 7) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-w]{3}-[2-9]{3}$\") %>%   col_vals_between(vars(d), left = 0, right = 4000) %>%   interrogate() ‚îÄ‚îÄ Interrogation Started - there are 5 steps ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚úì Step 1: OK. x Step 2: STOP condition met. ! Step 3: WARNING condition met. x Step 4: STOP condition met. ! Step 5: WARNING condition met.  ‚îÄ‚îÄ Interrogation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ readLines(\"pb_log_file\") [1] \"ERROR [2020-11-06 01:26:07] Step 2 exceeded the STOP failure threshold (f_failed = 0.46154) ['col_vals_in_set']\"  [2] \"WARN  [2020-11-06 01:26:07] Step 3 exceeded the WARN failure threshold (f_failed = 0.15385) ['col_vals_lt']\"      [3] \"ERROR [2020-11-06 01:26:07] Step 4 exceeded the STOP failure threshold (f_failed = 0.53846) ['col_vals_regex']\"   [4] \"WARN  [2020-11-06 01:26:07] Step 5 exceeded the WARN failure threshold (f_failed = 0.07692) ['col_vals_between']\" x <- get_agent_x_list(agent, i = 2) x ‚îÄ‚îÄ The x-list for STEP 2 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ $time_start $time_end (POSIXct [1]) $label $tbl_name $tbl_src $tbl_src_details (chr [1]) $tbl (spec_tbl_df, tbl_df, tbl, and data.frame) $col_names $col_types (chr [8]) $i $type $columns $values $label $briefs (mixed [1]) $eval_error $eval_warning (lgl [1]) $capture_stack (list [1]) $n $n_passed $n_failed $f_passed $f_failed (num [1]) $warn $stop $notify (lgl [1]) $lang (chr [1]) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ glue::glue(   \"In Step {x$i}, there were {x$n} test units and {x$f_failed * 100}% \\\\   failed. STOP condition met: {tolower(x$stop)}.\"   ) In Step 2, there were 13 test units and 46.154% failed. STOP condition met: true."},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-II.html","id":"an-example-of-this-workflow","dir":"Articles","previous_headings":"","what":"An Example of This Workflow","title":"Introduction to the **Pipeline Data Validation** Workflow (**VALID-II**)","text":"Let‚Äôs adapt example used VALID-: Data Quality Reporting Workflow article pipeline data validation workflow: terms expressions used pipeline, might notice create_agent() interrogate() functions absent. due secondary role validation functions, can operate directly immediately data, acting sort filter. validations pipeline pass (.e., failing test units validation steps), small_table data returned. Otherwise, ‚Äôs currently written, stoppage occur failure. turns , validation pipeline result error. stringent default threshold setting stops evaluation pipeline point failure (one test units failing). , turn, stops running script (key consideration script deployed automatically running sort schedule). type workflow don‚Äôt need define functions, pointblank automatically sensible thing stopping evaluation providing stock message. , first instance stoppage due validation failing, R scripts stop point R Markdown documents correspondingly cease render.","code":"small_table %>%   col_is_posix(vars(date_time)) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\", \"high\")) %>%   col_vals_lt(vars(a), value = 10) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\") %>%   col_vals_between(vars(d), left = 0, right = 5000) ## Error: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. ## The `col_vals_between()` validation failed beyond the absolute threshold level (1). ## * failure level (1) >= failure threshold (1)"},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-II.html","id":"modifying-the-behavior-of-validation-failures","dir":"Articles","previous_headings":"","what":"Modifying the Behavior of Validation Failures","title":"Introduction to the **Pipeline Data Validation** Workflow (**VALID-II**)","text":"ways counteract stopping behavior seen previous example. R Markdown document, set chunk option error = TRUE might expect error occur due validation failure (allowing execution continue matter happens). ‚Äôs done small_table example document, giving us error message printed input. Another way disable evaluation step level use active = FALSE option every validation function shouldn‚Äôt evaluated. works R scripts R Markdown documents quite different since can‚Äôt determine whether validation passed failed since doesn‚Äôt actually perform check (simply skips ). useful, however, want enable staged checks use data validations sort ‚Äòdebug mode‚Äô since global variables logical can passed active argument specific validation functions. Another strategy stop() instead warn().","code":""},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-II.html","id":"using-warn_on_fail-and-stop_on_fail-functions-to-generate-simple-action_levels","dir":"Articles","previous_headings":"","what":"Using warn_on_fail() and stop_on_fail() functions to generate simple action_levels","title":"Introduction to the **Pipeline Data Validation** Workflow (**VALID-II**)","text":"two helper functions convenient workflow: warn_on_fail() stop_on_fail(). functions return action_levels object either warns stops, informative warning error messages. default failure threshold set 1: one fail unit means threshold WARN FAIL condition met. stop_on_fail() helper (behind scenes) applied default using validation functions VALID-II workflow. , previous example exactly expanded form: want instead issue warnings, perhaps less stringent failure thresholds certain steps, warn_on_fail() function provides simple way express . warn_on_fail() stop_on_fail() handy ways generate action_levels objects actions argument every validation function, doesn‚Äôt provide way specify actions. , ‚Äôll need use action_levels() function directly.","code":"small_table %>%   col_is_posix(     vars(date_time),     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_in_set(     vars(f), set = c(\"low\", \"mid\", \"high\"),     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_lt(     vars(a), value = 10,     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_regex(     vars(b), regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\",     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_between(     vars(d), left = 0, right = 5000,     actions = stop_on_fail(stop_at = 1)   ) ## Error: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. ## The `col_vals_between()` validation failed beyond the absolute threshold level (1). ## * failure level (1) >= failure threshold (1) small_table %>%   col_is_posix(     vars(date_time),     actions = warn_on_fail()   ) %>%   col_vals_in_set(     vars(f), set = c(\"low\", \"mid\", \"high\"),     actions = warn_on_fail(warn_at = 0.2)   ) %>%   col_vals_lt(     vars(a), value = 10,     actions = warn_on_fail(warn_at = 3)   ) %>%   col_vals_regex(     vars(b), regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\",     actions = warn_on_fail(warn_at = 0.2)   ) %>%   col_vals_between(     vars(d), left = 0, right = 5000,     actions = warn_on_fail(warn_at = 1)   ) ## Warning: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. ## The `col_vals_between()` validation failed beyond the absolute threshold level (1). ## * failure level (1) >= failure threshold (1) ## # A tibble: 13 √ó 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-II.html","id":"using-action_levels-for-more-control","dir":"Articles","previous_headings":"","what":"Using action_levels() for More Control","title":"Introduction to the **Pipeline Data Validation** Workflow (**VALID-II**)","text":"action_levels() function can useful VALID-workflow agent. function creates action_levels object can two roles: (1) specification threshold failure levels entering certain conditions (WARN, STOP, NOTIFY), (2) setting actions (.e., function calls invoke) entering specific condition. fns argument action_levels() allows us define custom functions evaluated upon entering three states (acts ‚Äòstep‚Äô level, per validation function). Compared VALID-workflow, deals reporting, actions triggered failures VALID-II workflow probably useful important. can imagine situation R script deployed data validation interspersed throughout. Depending deployment, may desire hard stop (affecting downstream components), , may want softer approach warning logging. Let‚Äôs try hybrid approach three available conditions failure threshold levels set associated function invoke. functions invoke condition can whatever makes sense workflow (.e., don‚Äôt issue warnings WARN condition want something else). , use warning() WARN, stop() STOP, logging function (log4r_step()) NOTIFY. ‚Äôs might create action_levels object action_levels(): assigned action_levels object (case, al) can print get summary settings. Finally, apply object every validation function call expression (changed slightly result test units failing). addition error warning, log4r_step() function used NOTIFY condition generates, case, new \"pb_log_file\" text file logs. can examine readLines(); single entry relates Step 1 (col_vals_in_set() step): log4r_step() function offered pointblank shown examples explained detail VALID-: Data Quality Reporting Workflow article.","code":"al <-    action_levels(     warn_at = 0.1,     stop_at = 0.2,     notify_at = 0.3,     fns = list(       warn = ~ warning(\"WARN threshold exceeded.\"),       stop = ~ stop(\"STOP threshold exceeded.\"),       notify = ~ log4r_step(x)     )   ) al ‚îÄ‚îÄ The `action_levels` settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ WARN failure threshold of 0.1 of all test units. \\fns\\ ~ warning(\"WARN threshold exceeded.\") STOP failure threshold of 0.2 of all test units. \\fns\\ ~ stop(\"STOP threshold exceeded.\") NOTIFY failure threshold of 0.3 of all test units. \\fns\\ ~ log4r_step(x) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ small_table %>%   col_is_posix(vars(date_time), actions = al) %>%   col_vals_in_set(vars(f), set = c(\"low\", \"mid\"), actions = al) %>%   col_vals_lt(vars(a), value = 7, actions = al) %>%   col_vals_regex(vars(b), regex = \"^[0-9]-[a-w]{3}-[2-9]{3}$\", actions = al) %>%   col_vals_between(vars(d), left = 0, right = 4000, actions = al) ## Warning in rlang::eval_tidy(.): WARN threshold exceeded. ## Error in rlang::eval_tidy(.): STOP threshold exceeded. readLines(\"pb_log_file\") FATAL [2020-11-09 00:23:48] Step 1 exceeded the NOTIFY failure threshold (f_failed = 0.46154) ['col_vals_in_set']"},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-III.html","id":"using-expect_-functions-in-the-testthat-way","dir":"Articles","previous_headings":"","what":"Using expect_*() Functions in the testthat Way","title":"Introduction to the **Expectations in Unit Tests** Workflow (**VALID-III**)","text":"testthat package collection functions begin expect_. ‚Äôs coincidence pointblank VALID-III workflow adopts naming convention. idea use functions interchangeably testthat standard testthat workflow (test-<name>.R file, inside tests/testthat folder). big difference instead testing function outputs, testing data tables. However, tables may returned function calls expect_*() functions offered pointblank might offer flexibility testing data. instance expect_col_vals_between() allows us write expectation fine control boundary values (whether inclusive bounds), whether NA values ignored, can even set failure threshold makes sense expectation. ‚Äôs example generate tests data testthat also pointblank. small_table dataset, let‚Äôs write expectations show non-NA values column c 2 9. testthat function tests values two values. original strategy use testthat::expect_gte() testthat::lte() small_table$c object , however, doesn‚Äôt work results logical vector greater length 1. Also, allowance NA values skipped. best . pointblank version task makes succinct understandable expectation expression: arguments expect_col_vals_between() give us everything need check tabular data without subsetting perform transformations. added benefits. data come data source locals data frame, SQL expressions handled internally tested extensively across supported database types Spark DataFrames well.","code":"testthat::expect_true(all(na.omit(small_table$c) >= 2)) testthat::expect_true(all(na.omit(small_table$c) <= 9)) expect_col_vals_between(small_table, vars(c), 2, 9, na_pass = TRUE)"},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-III.html","id":"these-expect_-functions-are-simpler-than-their-counterparts","dir":"Articles","previous_headings":"","what":"These expect_*() Functions Are Simpler Than Their Counterparts","title":"Introduction to the **Expectations in Unit Tests** Workflow (**VALID-III**)","text":"expect_*() functions leading arguments validation function counterparts omit following arguments end signatures: actions step_id label brief active lose actions argument, get place threshold argument. simple failure threshold value use expectation (expect_*) test (test_*) functions. default, threshold set 1 means single test unit failing result overall failure (.e., expectation fail). thresholds set action_levels() functions (shortcut functions warn_on_fail() stop_on_fail()), whole numbers beyond 1 indicate failing units absolute threshold value result succeeding expectation. Likewise, fractional values (0 1) act proportional failure threshold, 0.25 means 25% failing test units results failed expectation. preconditions argument can used transform input data evaluation expectation. useful cases might need summarize input data table, mutate columns, perform filtering, even perform table joins beforehand.","code":""},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-IV.html","id":"exactly-like-the-expect_-functions-except-you-get-a-true-or-false","dir":"Articles","previous_headings":"","what":"Exactly Like the expect_*() Functions Except You Get a TRUE or FALSE","title":"Introduction to the **Data Tests for Conditionals** Workflow (**VALID-IV**)","text":"interface test_*() function exact match expect_*() counterpart. haven‚Äôt used either used standard validation functions, ‚Äôs quick rundown. following arguments validation functions (e.g., col_vals_in_set() many ) removed corresponding test_*() functions: actions step_id label brief active Instead actions get threshold argument simplified replacement. ‚Äôs supplied single failure threshold value. default set 1 meaning single test fails result overall failure return FALSE (otherwise, TRUE). rules threshold setting (action_levels(), warn_on_fail(), stop_on_fail()) explained detail . Whole numbers beyond 1 indicate failing units absolute threshold value result TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.25 means 25% failing test units results FALSE. can use preconditions argument cases ‚Äôd like transform input data evaluation test. like things input table like summarize , perform filtering, mutate one columns, perform table joins, etc., good way go .","code":""},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-IV.html","id":"heres-several-examples-quick-snap","dir":"Articles","previous_headings":"","what":"Here‚Äôs Several Examples Quick Snap","title":"Introduction to the **Data Tests for Conditionals** Workflow (**VALID-IV**)","text":"Let‚Äôs examples leaving article. use small_table: ‚Äôd like test pointblank validation skill, guess whether TRUE FALSE hovering line code. . nice set examples revealing truthy/falsy nature ::closer inspection.","code":"small_table ## # A tibble: 13 √ó 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-V.html","id":"an-example-with-the-palmer-penguins-dataset","dir":"Articles","previous_headings":"","what":"An Example with the Palmer Penguins Dataset","title":"Introduction to the **Table Scan** Workflow (**VALID-V**)","text":"output HTML report appear RStudio Viewer can also integrated R Markdown HTML output. ‚Äôs example uses penguins_raw dataset palmerpenguins package. scan_data() call, option deactivate display navigation bar taken navbar = FALSE, makes sense integrating type output larger document. seen, first two sections lot additional information tucked behind detail views (Toggle details buttons) within tab sets. amount information little overwhelming, option disable one sections. scan_data()‚Äôs sections argument, can specify just sections needed specific scan. default value sections string \"OVICMS\" letter stands following sections default order: \"O\": \"overview\" \"V\": \"variables\" \"\": \"interactions\" \"C\": \"correlations\" \"M\": \"missing\" \"S\": \"sample\". string can contain less key characters order can changed suit desired layout report. example, just need Overview, Sample, description Variables target table, string use sections \"OSV\". Just workflows, tbl supplied data frame, tibble, tbl_dbi object, tbl_spark object. However, one limitation scan_data(): tbl_dbi tbl_spark objects, Interactions Correlations sections currently excluded.","code":"scan_data(palmerpenguins::penguins_raw, navbar = FALSE)"},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-V.html","id":"languages-and-locales","dir":"Articles","previous_headings":"","what":"Languages and Locales","title":"Introduction to the **Table Scan** Workflow (**VALID-V**)","text":"reporting generated scan_data() can presented one eight spoken languages: English (\"en\", default), French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese, (\"pt\"), Chinese (\"zh\"), Russian (\"ru\"). two-letter language codes can used argument lang argument. applied, label text non-data elements set language choice. checked translations native speakers respective languages find error corrected, please file issue. Along translations, numerical values generated part reporting (e.g., table dimensions, summary statistics, etc.) automatically formatted locale language (given lang). can overridden locale argument accepts locale ID. Examples include \"en_US\" English (United States) \"fr_FR\" French (France). simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). 700 locales currently accepted.","code":""},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-VI.html","id":"how-it-works","dir":"Articles","previous_headings":"","what":"How It Works","title":"Introduction to the **R Markdown Document Validation** Workflow (**VALID-VI**)","text":"Using pointblank VALID-VI workflow enabled default pointblank library loaded (best done setup chunk). framework allows validation testing within specialized validation code chunks validate = TRUE option set. Using pointblank validation functions data (VALID-II workflow) marked code chunks flag overall failure stop threshold exceeded anywhere. errors shown rendering document HTML. Green status buttons indicate validations succeeded, red buttons indicate one validation failures occurred. Clicking button reveals otherwise hidden validation statements associated messaging. ‚Äôs much better demonstrate workflow works series examples, resulting output interactive varies quite bit depending input. following examples, code chunk shown rendered result subsequently placed. result typically button can pressed reveal validation result code chunk hidden upon rendering (‚Äôs need use include = FALSE chunk option). start things , ‚Äôs example uses expression takes small_table dataset pipes two validation functions: col_is_date() col_vals_in_set(). col_is_date() validation passes whereas col_vals_in_set() validation fails (set values column f also \"high\" value.  Clicking 1 validation failed. button reveal expression failed validation validation function failing within . break , really one validation step chain passed (first one) one failed (second). additional validation steps otherwise pass, ‚Äôd still get result output failing step ends execution. workflow meant stop expression executing first validation function fails, ‚Äôs advisable break validations single steps. way, expression single validation either passes fails reported accordingly. Let‚Äôs rewrite example two expressions, one per validation.  still says 1 validation failed. (workflow focuses negatives) pressing button reveals first one passed second failed. much clearer don‚Äôt run risk evaluating validations validation failed earlier pipeline. ‚Äôs example validations individual expressions pass, showing us green status button.  ‚Äôs worth reminding point failed validations stop execution R Markdown rendering. Otherwise wouldn‚Äôt see document failing validations, , wouldn‚Äôt know failed validations occurred. expectation workflow add relevant validation expressions key junctures failures occur, one can fix underlying issues (enough) validations pass.","code":""},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-VI.html","id":"the-pointblank-stop_if_not-function","dir":"Articles","previous_headings":"","what":"The pointblank stop_if_not() Function","title":"Introduction to the **R Markdown Document Validation** Workflow (**VALID-VI**)","text":"may want use set validation functions everything. Perhaps using stopifnot() sufficient validations. case, consider using pointblank variation : stop_if_not(). works well enough standalone, replacement stopifnot() advantage stop_if_not() customized use VALID-VI workflow (situation ‚Äôre using R Markdown render HTML, pointblank loaded via library()). Ultimately, using stop_if_not() code chunk validate = TRUE option set yield correct reporting successes failures whereas stopifnot() . ‚Äôs code chunk uses stop_if_not() twice check two different assertions small_table object. first one passes whereas second one fails.  Keep mind stop_if_not() (like stopifnot()) can used type assertion. ‚Äôs limited checking tables like functions pointblank focused .","code":""},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-VI.html","id":"including-data-quality-reporting-from-the-valid-i-workflow","dir":"Articles","previous_headings":"","what":"Including Data Quality Reporting from the VALID-I Workflow","title":"Introduction to the **R Markdown Document Validation** Workflow (**VALID-VI**)","text":"Code chunks can include data quality reporting expressions (.e., agent-based VALID-workflow) ‚Äôs important ensure two things. ‚Äôs interesting thing : can opt use validate = TRUE chunk option omit entirely, choice different effect. ‚Äôd like hide validation output (Agent Report) behind button (case, light blue one) validate = TRUE used. ‚Äôs example data quality validation workflow executed single code chunk.  code chunk exclude validate = TRUE option, output appear output normally (input appears output report table). just want output reporting table shown without input expressions, use include = FALSE chunk option . final note , ‚Äôs important use expressions result output, just stick typical create_agent() ‚Üí <validation functions> ‚Üí interrogate() pattern. words, dedicate code chunk just agent put validation expressions elsewhere document.","code":""},{"path":"https://rich-iannone.github.io/pointblank/articles/VALID-VI.html","id":"setting-up-options-with-the-validate_rmd-function","dir":"Articles","previous_headings":"","what":"Setting Up Options with the validate_rmd() Function","title":"Introduction to the **R Markdown Document Validation** Workflow (**VALID-VI**)","text":"can modify pointblank validation testing options within R Markdown documents validate_rmd() function. framework testing set default, using validate_rmd() offers opportunity set UI logging options. summary argument, TRUE (default), leading summary validations rendered R Markdown document. FALSE, element shown. document, validate_rmd(summary = FALSE) placed setup chunk (right library(pointblank) statement) resulted suppressing display overall summary validation results. log_to_file argument, ‚Äôs option log errors text file. default, logging done setting log_to_file == TRUE write log entries \"validation_errors.log\" file working directory (generated non-existent, appended available). enable logging specify name file, include path log file (desired name) log_to_file.","code":""},{"path":"https://rich-iannone.github.io/pointblank/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Richard Iannone. Author, maintainer. Mauricio Vargas. Author.","code":""},{"path":"https://rich-iannone.github.io/pointblank/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Iannone R, Vargas M (2021). pointblank: Data Validation Organization Metadata Local Remote Tables. https://rich-iannone.github.io/pointblank/, https://github.com/rich-iannone/pointblank.","code":"@Manual{,   title = {pointblank: Data Validation and Organization of Metadata for Local and Remote Tables},   author = {Richard Iannone and Mauricio Vargas},   year = {2021},   note = {https://rich-iannone.github.io/pointblank/, https://github.com/rich-iannone/pointblank}, }"},{"path":"https://rich-iannone.github.io/pointblank/index.html","id":null,"dir":"","previous_headings":"","what":"Data Validation and Organization of Metadata for Local and Remote Tables","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"pointblank package ‚Äôs really easy methodically validate data whether form data frames database tables. top validation toolset, package gives means provide keep --date information defines tables. table validation, agent object works large collection simple (yet powerful!) validation functions. can enable much sophisticated validation checks using custom expressions also stepwise mutation target table (something call preconditions). Sometimes want maintain table information update table goes changes. , can use informant object + associated functions help define metadata entries present way suits .","code":""},{"path":"https://rich-iannone.github.io/pointblank/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Want try ? pointblank package available CRAN: can also install development version pointblank GitHub: encounter bug, usage questions, want share ideas make package better, feel free file issue.","code":"install.packages(\"pointblank\") devtools::install_github(\"rich-iannone/pointblank\")"},{"path":"https://rich-iannone.github.io/pointblank/index.html","id":"lets-discuss","dir":"","previous_headings":"","what":"Let‚Äôs Discuss!","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Let‚Äôs talk data validation data documentation pointblank Discussions! ‚Äôs great place ask questions use package, discuss ideas, engage others, much !","code":""},{"path":"https://rich-iannone.github.io/pointblank/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Please note pointblank project released contributor code conduct. participating project agree abide terms.","code":""},{"path":"https://rich-iannone.github.io/pointblank/index.html","id":"-license","dir":"","previous_headings":"","what":"üìÑ License","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"pointblank licensed MIT license. See LICENSE.md file details.","code":""},{"path":"https://rich-iannone.github.io/pointblank/index.html","id":"Ô∏è-governance","dir":"","previous_headings":"","what":"üèõÔ∏è Governance","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"project primarily maintained Rich Iannone. authors may occasionally assist duties.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/action_levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Set action levels: failure thresholds and functions to invoke ‚Äî action_levels","title":"Set action levels: failure thresholds and functions to invoke ‚Äî action_levels","text":"action_levels() function works actions argument present create_agent() function every validation step function (also actions argument). , can provide threshold fail levels combination warn, stop, notify states. can react entrance state supplying corresponding functions fns argument. undergo evaluation time matching state entered. provided create_agent() policies applied every validation step, acting default validation whole. Calls action_levels() also applied directly validation step act override set also create_agent(). Usage action_levels() required useful side effects (.e., warnings, throwing errors) case validation functions operating directly data (e.g., mtcars %>% col_vals_lt(\"mpg\", 35)). two helper functions convenient using validation functions directly data (agent-less workflow): warn_on_fail() stop_on_fail(). helpers either warn stop (default failure threshold set 1), , informative warning error messages. stop_on_fail() helper applied default using validation functions directly data (information provided Details).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/action_levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set action levels: failure thresholds and functions to invoke ‚Äî action_levels","text":"","code":"action_levels(warn_at = NULL, stop_at = NULL, notify_at = NULL, fns = NULL)  warn_on_fail(warn_at = 1)  stop_on_fail(stop_at = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/action_levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set action levels: failure thresholds and functions to invoke ‚Äî action_levels","text":"warn_at, stop_at, notify_at threshold number fraction test units can provide fail result entering warn, stop, notify failure states. decimal value 0 1 proportional failure threshold (e.g., 0.15 indicates 15% percent test units found fail, designated failure state entered). Absolute values starting 1 can used instead, constitutes absolute failure threshold (e.g., 10 means 10 test units found fail, failure state entered). fns named list functions paired appropriate failure states. syntax list involves using failure state names set warn, stop, notify. functions corresponding failure states provided formulas (e.g., list(warn = ~ warning(\"many failures.\")). series expressions named state can used enclosing set statements { }.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/action_levels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set action levels: failure thresholds and functions to invoke ‚Äî action_levels","text":"output action_levels() call actions interpreted slightly differently using agent using validation functions directly data table. convenience, working directly data, values supplied warn_at stop_at automatically given stock warning() stop() function. example using small_table %>% col_is_integer(\"date\") provide detailed stop message default, indicating reason failure. supply fns stop warn manually stock functions overridden. Furthermore, actions NULL workflow (default), pointblank use stop_at value 1 (providing detailed, context-specific error message fail units). can absolutely suppress automatic stopping behavior validation step setting active = FALSE. interactive data case, stock function given notify_at. notify failure state less commonly used workflow agent-based one. using agent, often opt use functions fns warn, stop, notify failure states reported using create_agent_report() (, usually sufficient). Instead, using end_fns argument better choice since scheme provides useful data entire interrogation, allowing finer control side effects reducing potential duplicating side effects.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/action_levels.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Set action levels: failure thresholds and functions to invoke ‚Äî action_levels","text":"1-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/action_levels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set action levels: failure thresholds and functions to invoke ‚Äî action_levels","text":"","code":"# For these examples, we will use the # included `small_table` dataset small_table #> # A tibble: 13 √ó 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # Create an `action_levels` object # with fractional values for the # `warn`, `stop`, and `notify` states al <-    action_levels(     warn_at = 0.2,     stop_at = 0.8,     notify_at = 0.5   )    # A summary of settings for the `al` # object is shown by printing it al #> ‚îÄ‚îÄ The `action_levels` settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> WARN failure threshold of 0.2 of all test units. #> STOP failure threshold of 0.8 of all test units. #> NOTIFY failure threshold of 0.5 of all test units. #> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # Create a pointblank agent and # apply the `al` object to `actions`; # add two validation steps and # interrogate the `small_table` agent_1 <-   create_agent(     tbl = small_table,     actions = al   ) %>%   col_vals_gt(     vars(a), value = 2   ) %>%   col_vals_lt(     vars(d), value = 20000   ) %>%   interrogate()  # The report from the agent will show # that the `warn` state has been entered # for the first validation step but not # the second one; we can confirm this # in the console by inspecting the # `warn` component in the agent's x-list x_list <- get_agent_x_list(agent_1) x_list$warn #> [1]  TRUE FALSE  # Applying the `action_levels` object # to the agent means that all validation # steps will inherit these settings but # we can override this by applying # another such object to the validation # step instead (this time using the # `warn_on_fail()` shorthand) agent_2 <-   create_agent(     tbl = small_table,     actions = al   ) %>%   col_vals_gt(     vars(a), value = 2,     actions = warn_on_fail(warn_at = 0.5)   ) %>%   col_vals_lt(     vars(d), value = 20000   ) %>%   interrogate()  # In this case, the first validation # step has a less stringent failure # threshold for the `warn` state and it's # high enough that the condition is not # entered; this can be confirmed in the # console through inspection of the # x-list `warn` component x_list <- get_agent_x_list(agent_2) x_list$warn #> [1] FALSE FALSE  if (interactive()) {  # In the context of using validation # functions directly on data (i.e., no # involvement of an agent) we want to # trigger warnings and raise errors; the # following will yield a warning if # it is executed (returning the # `small_table` data) small_table %>%   col_vals_gt(     vars(a), value = 2,     actions = warn_on_fail(warn_at = 2)   )  # With the same pipeline, not supplying # anything for `actions` (it's `NULL` by # default) will have the same effect as # using `stop_on_fail(stop_at = 1)`  small_table %>%   col_vals_gt(vars(a), value = 2)  small_table %>%   col_vals_gt(     vars(a), value = 2,     actions = stop_on_fail(stop_at = 1)   )  # This is because the `stop_on_fail()` # call is auto-injected in the default # case (when operating on data) for your # convenience; behind the scenes a # 'secret agent' uses 'covert actions': # all so you can type less  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/activate_steps.html","id":null,"dir":"Reference","previous_headings":"","what":"Activate one or more of an agent's validation steps ‚Äî activate_steps","title":"Activate one or more of an agent's validation steps ‚Äî activate_steps","text":"certain validation steps need activated creation validation plan agent, use activate_steps() function. equivalent using active = TRUE selected validation steps (active argument validation functions). replace function may defined active argument creation targeted validation steps.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/activate_steps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Activate one or more of an agent's validation steps ‚Äî activate_steps","text":"","code":"activate_steps(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/activate_steps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Activate one or more of an agent's validation steps ‚Äî activate_steps","text":"agent agent object class ptblank_agent. validation step number, assigned validation step order definition.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/activate_steps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Activate one or more of an agent's validation steps ‚Äî activate_steps","text":"ptblank_agent object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/activate_steps.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Activate one or more of an agent's validation steps ‚Äî activate_steps","text":"9-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/activate_steps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Activate one or more of an agent's validation steps ‚Äî activate_steps","text":"","code":"# Create an agent that has the # `small_table` object as the # target table, add a few inactive # validation steps, and then use # `interrogate()` agent_1 <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%   col_exists(     vars(date),     active = FALSE   ) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     active = FALSE   ) %>%   interrogate() #> ‚Ñπ Step 1 is not set as active. Skipping. #> ‚Ñπ Step 2 is not set as active. Skipping.  # In the above, the data is # not actually interrogated # because the `active` setting # was `FALSE` in all steps; we # can selectively change this # with `activate_steps()` agent_2 <-   agent_1 %>%   activate_steps(i = 1) %>%   interrogate() #> ‚Ñπ Step 2 is not set as active. Skipping."},{"path":"https://rich-iannone.github.io/pointblank/reference/affix_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Put the current date into a file name ‚Äî affix_date","title":"Put the current date into a file name ‚Äî affix_date","text":"function helps affix current date filename. useful writing agent /informant objects disk part continuous process. date can terms UTC time local system time. date can affixed either end filename (file extension) beginning customizable delimiter. x_write_disk(), yaml_write() functions allow writing pointblank objects disk. Furthermore log4r_step() function append_to argument accepts filenames, , reasonable series log files differentiated date component naming scheme. modification filename string takes effect immediately time writing file disk. cases, especially using affix_date() aforementioned file-writing functions, file timestamps approximate time components affixed filenames.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/affix_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Put the current date into a file name ‚Äî affix_date","text":"","code":"affix_date(   filename,   position = c(\"end\", \"start\"),   format = \"%Y-%m-%d\",   delimiter = \"_\",   utc_time = TRUE )"},{"path":"https://rich-iannone.github.io/pointblank/reference/affix_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Put the current date into a file name ‚Äî affix_date","text":"filename filename modify. position place formatted date. either \"end\" filename (default) \"start\". format base::strptime() format string formatting date. default, \"%Y-%m-%d\" expresses date according ISO 8601 standard (YYYY-MM-DD). Refer documentation base::strptime() conversion specifications planning use different format string. delimiter delimiter characters use separating date string original file name. utc_time option whether use current UTC time establish date (default, TRUE), , use system's local time (FALSE).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/affix_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Put the current date into a file name ‚Äî affix_date","text":"character vector.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/affix_date.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Put the current date into a file name ‚Äî affix_date","text":"13-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/affix_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Put the current date into a file name ‚Äî affix_date","text":"","code":"# Taking the generic `pb_file` name for # a file, we add the current date to it # as a suffix affix_date(filename = \"pb_file\") #> [1] \"pb_file_2021-12-09\"  # File extensions won't get in the way: affix_date(filename = \"pb_file.rds\") #> [1] \"pb_file_2021-12-09.rds\"  # The date can be used as a prefix affix_date(   filename = \"pb_file\",   position = \"start\" ) #> [1] \"2021-12-09_pb_file\"  # The date pattern can be changed and so # can the delimiter affix_date(   filename = \"pb_file.yml\",   format = \"%Y%m%d\",   delimiter = \"-\" ) #> [1] \"pb_file-20211209.yml\"  if (interactive()) {  # We can use a file-naming convention # involving dates when writing output # files immediately after interrogating; # useful when interrogating directly # from YAML in a scheduled process yaml_agent_interrogate(   filename = system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) ) %>%    x_write_disk(     filename = affix_date(       filename = \"small_table_agent.rds\",       delimiter = \"-\"     ),     keep_tbl = TRUE,     keep_extracts = TRUE   )  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/affix_datetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Put the current date-time into a file name ‚Äî affix_datetime","title":"Put the current date-time into a file name ‚Äî affix_datetime","text":"function helps affix current date-time filename. useful writing agent /informant objects disk part continuous process. date-time string can based current UTC time local system time. date-time can affixed either end filename (file extension) beginning customizable delimiter. Optionally, time zone information can included. date-time based local system time, user system time zone shown format <time>(+/-)hhmm. using UTC time, <time>Z format adopted. x_write_disk(), yaml_write() functions allow writing pointblank objects disk. modification filename string takes effect immediately time writing file disk. cases, especially using affix_datetime() aforementioned file-writing functions, file timestamps approximate time components affixed filenames.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/affix_datetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Put the current date-time into a file name ‚Äî affix_datetime","text":"","code":"affix_datetime(   filename,   position = c(\"end\", \"start\"),   format = \"%Y-%m-%d_%H-%M-%S\",   delimiter = \"_\",   utc_time = TRUE,   add_tz = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/reference/affix_datetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Put the current date-time into a file name ‚Äî affix_datetime","text":"filename filename modify. position place formatted date-time. either \"end\" filename (default) \"start\". format base::strptime() format string formatting date-time. default, \"%Y-%m-%dT%H:%M:%S\" expresses date according ISO 8601 standard. example, current date-time 2020-12-04 13:11:23, formatted string become \"2020-12-04T13:11:23\". Refer documentation base::strptime() conversion specifications planning use different format string. delimiter delimiter characters use separating date-time string original file name. utc_time option whether use current UTC time establish date-time (default, TRUE), , use system's local time (FALSE). add_tz time zone (offset UTC) provided? TRUE UTC offset either provided <time>Z (utc_time = TRUE) <time>(+/-)hhmm. default, FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/affix_datetime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Put the current date-time into a file name ‚Äî affix_datetime","text":"character vector.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/affix_datetime.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Put the current date-time into a file name ‚Äî affix_datetime","text":"13-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/affix_datetime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Put the current date-time into a file name ‚Äî affix_datetime","text":"","code":"# Taking the generic `pb_file` name for # a file, we add the current date-time to it # as a suffix affix_datetime(filename = \"pb_file\") #> [1] \"pb_file_2021-12-09_16-17-51\"  # File extensions won't get in the way: affix_datetime(filename = \"pb_file.rds\") #> [1] \"pb_file_2021-12-09_16-17-51.rds\"  # The date-time can be used as a prefix affix_datetime(   filename = \"pb_file\",   position = \"start\" ) #> [1] \"2021-12-09_16-17-51_pb_file\"  # The date-time pattern can be changed and so # can the delimiter affix_datetime(   filename = \"pb_file.yml\",   format = \"%Y%m%d_%H%M%S\",   delimiter = \"-\" ) #> [1] \"pb_file-20211209_161751.yml\"  # Time zone information can be included affix_datetime(   filename = \"pb_file.yml\",   add_tz = TRUE ) #> [1] \"pb_file_2021-12-09_16-17-51Z.yml\"  if (interactive()) {  # We can use a file-naming convention # involving date-times when writing output # files immediately after interrogating; # useful when interrogating directly # from YAML in a scheduled process yaml_agent_interrogate(   filename = system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) ) %>%    x_write_disk(     filename = affix_datetime(       filename = \"small_table_agent.rds\",       delimiter = \"-\"     ),     keep_tbl = TRUE,     keep_extracts = TRUE   )  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/all_passed.html","id":null,"dir":"Reference","previous_headings":"","what":"Did all of the validations fully pass? ‚Äî all_passed","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"Given agent's validation plan undergone interrogation via interrogate(), every single validation step result zero failing test units? Using all_passed() function let us know whether TRUE .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/all_passed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"","code":"all_passed(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/all_passed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"agent agent object class ptblank_agent. vector validation step numbers. values assigned validation step pointblank order definition. NULL (default), validation steps used evaluation complete passing.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/all_passed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/all_passed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"all_passed() function provides single logical value based interrogation performed agent-based workflow. large-scale validation (data quality known issue, perhaps something tamed time) function likely less useful since quite stringent (test units must pass across validation steps). requirement logical values produced validation, flexible alternative using test (test_*()) variants validation functions. produce single logical value threshold option failure levels. Another option utilize post-interrogation objects within agent's x-list (obtained using get_agent_x_list() function). allows many possibilities producing single logical value interrogation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/all_passed.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"8-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/all_passed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Did all of the validations fully pass? ‚Äî all_passed","text":"","code":"# Create a simple table with # a column of numerical values tbl <-    dplyr::tibble(a = c(4, 5, 7, 8))  # Validate that values in column # `a` are always greater than 4 agent <-   create_agent(tbl = tbl) %>%   col_vals_gt(vars(a), value = 3) %>%   col_vals_lte(vars(a), value = 10) %>%   col_vals_increasing(vars(a)) %>%   interrogate()  # Determine if these column # validations have all passed by # using `all_passed()` (they do) all_passed(agent = agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_exists.html","id":null,"dir":"Reference","previous_headings":"","what":"Do one or more columns actually exist? ‚Äî col_exists","title":"Do one or more columns actually exist? ‚Äî col_exists","text":"col_exists() validation function, expect_col_exists() expectation function, test_col_exists() test function check whether one columns exist target table. requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate single test unit, whether column exists .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_exists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do one or more columns actually exist? ‚Äî col_exists","text":"","code":"col_exists(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_exists(object, columns, threshold = 1)  test_col_exists(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_exists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do one or more columns actually exist? ‚Äî col_exists","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns One columns table focus. can provided vector column names using c() bare column names enclosed vars(). actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_exists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do one or more columns actually exist? ‚Äî col_exists","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_exists.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do one or more columns actually exist? ‚Äî col_exists","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_exists.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do one or more columns actually exist? ‚Äî col_exists","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. Using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_exists.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do one or more columns actually exist? ‚Äî col_exists","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_exists.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do one or more columns actually exist? ‚Äî col_exists","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_exists() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_exists() validation step expressed R code corresponding YAML representation. practice, often shorter columns, argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_exists(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_exists()` step.\",     active = FALSE   )  # YAML representation steps: - col_exists:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_exists()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_exists.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do one or more columns actually exist? ‚Äî col_exists","text":"2-29","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_exists.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do one or more columns actually exist? ‚Äî col_exists","text":"","code":"# For all examples here, we'll use # a simple table with two columns: # `a` and `b` tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 0, 3)   )  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that columns `a` and `b` # exist in the `tbl` table; this # makes two distinct validation # steps since two columns were # provided to `vars()` agent <-   create_agent(tbl) %>%   col_exists(vars(a, b)) %>%   interrogate()  # Determine if this validation # had no failing test units (1) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>% col_exists(vars(a, b)) #> # A tibble: 6 √ó 2 #>       a     b #>   <dbl> <dbl> #> 1     5     7 #> 2     7     1 #> 3     6     0 #> 4     5     0 #> 5     8     0 #> 6     7     3  # C: Using the expectation function  # With the `expect_*()` form, we need # to be more exacting and provide one # column at a time; this is primarily # used in testthat tests expect_col_exists(tbl, vars(a)) expect_col_exists(tbl, vars(b))  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us (even if there are multiple # columns tested, as is the case below) tbl %>% test_col_exists(vars(a, b)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_character.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain character/string data? ‚Äî col_is_character","title":"Do the columns contain character/string data? ‚Äî col_is_character","text":"col_is_character() validation function, expect_col_is_character() expectation function, test_col_is_character() test function check whether one columns table character type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate single test unit, whether column character-type column .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain character/string data? ‚Äî col_is_character","text":"","code":"col_is_character(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_character(object, columns, threshold = 1)  test_col_is_character(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_character.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain character/string data? ‚Äî col_is_character","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_character.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain character/string data? ‚Äî col_is_character","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_character.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain character/string data? ‚Äî col_is_character","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_character.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain character/string data? ‚Äî col_is_character","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_character.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain character/string data? ‚Äî col_is_character","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_character.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain character/string data? ‚Äî col_is_character","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_character() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_character() validation step expressed R code corresponding YAML representation. practice, often shorter columns, argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_is_character(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_character()` step.\",     active = FALSE   )  # YAML representation steps: - col_is_character:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_character()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_character.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain character/string data? ‚Äî col_is_character","text":"2-22","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_character.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain character/string data? ‚Äî col_is_character","text":"","code":"# For all examples here, we'll use # a simple table with a numeric column # (`a`) and a character column (`b`) tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = LETTERS[1:6]   )    # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that column `b` has the # `character` class agent <-   create_agent(tbl) %>%   col_is_character(vars(b)) %>%   interrogate()  # Determine if this validation # had no failing test units (1) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>% col_is_character(vars(b)) #> # A tibble: 6 √ó 2 #>       a b     #>   <dbl> <chr> #> 1     5 A     #> 2     7 B     #> 3     6 C     #> 4     5 D     #> 5     8 E     #> 6     7 F      # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_is_character(tbl, vars(b))  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us tbl %>% test_col_is_character(vars(b)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain R Date objects? ‚Äî col_is_date","title":"Do the columns contain R Date objects? ‚Äî col_is_date","text":"col_is_date() validation function, expect_col_is_date() expectation function, test_col_is_date() test function check whether one columns table R Date type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate single test unit, whether column Date-type column .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain R Date objects? ‚Äî col_is_date","text":"","code":"col_is_date(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_date(object, columns, threshold = 1)  test_col_is_date(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain R Date objects? ‚Äî col_is_date","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain R Date objects? ‚Äî col_is_date","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_date.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain R Date objects? ‚Äî col_is_date","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_date.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain R Date objects? ‚Äî col_is_date","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_date.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain R Date objects? ‚Äî col_is_date","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_date.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain R Date objects? ‚Äî col_is_date","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_date() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_date() validation step expressed R code corresponding YAML representation. practice, often shorter columns, argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_is_date(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_date()` step.\",     active = FALSE   )  # YAML representation steps: - col_is_date:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_date()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_date.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain R Date objects? ‚Äî col_is_date","text":"2-26","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain R Date objects? ‚Äî col_is_date","text":"","code":"# The `small_table` dataset in the # package has a `date` column; the # following examples will validate # that that column is of the `Date` # class  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that the column `date` has # the `Date` class agent <-   create_agent(small_table) %>%   col_is_date(vars(date)) %>%   interrogate()    # Determine if this validation # had no failing test units (1) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option small_table %>%   col_is_date(vars(date)) %>%   dplyr::slice(1:5) #> # A tibble: 5 √ó 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_is_date(   small_table, vars(date) )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us small_table %>%   test_col_is_date(vars(date)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_factor.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain R factor objects? ‚Äî col_is_factor","title":"Do the columns contain R factor objects? ‚Äî col_is_factor","text":"col_is_factor() validation function, expect_col_is_factor() expectation function, test_col_is_factor() test function check whether one columns table factor type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate single test unit, whether column factor-type column .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_factor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain R factor objects? ‚Äî col_is_factor","text":"","code":"col_is_factor(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_factor(object, columns, threshold = 1)  test_col_is_factor(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_factor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain R factor objects? ‚Äî col_is_factor","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_factor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain R factor objects? ‚Äî col_is_factor","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_factor.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain R factor objects? ‚Äî col_is_factor","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_factor.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain R factor objects? ‚Äî col_is_factor","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_factor.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain R factor objects? ‚Äî col_is_factor","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_factor.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain R factor objects? ‚Äî col_is_factor","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_factor() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_factor() validation step expressed R code corresponding YAML representation. practice, often shorter columns, argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_is_factor(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_factor()` step.\",     active = FALSE   )  # YAML representation steps: - col_is_factor:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_factor()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_factor.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain R factor objects? ‚Äî col_is_factor","text":"2-28","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_factor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain R factor objects? ‚Äî col_is_factor","text":"","code":"# Let's modify the `f` column in the # `small_table` dataset so that the # values are factors instead of having # the `character` class; the following # examples will validate that the `f` # column was successfully mutated and # now consists of factors tbl <-    small_table %>%   dplyr::mutate(f = factor(f))  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that the column `f` in the # `tbl` object is of the `factor` class agent <-   create_agent(tbl) %>%   col_is_factor(vars(f)) %>%   interrogate()    # Determine if this validation # had no failing test units (1) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>%   col_is_factor(vars(f)) %>%   dplyr::slice(1:5) #> # A tibble: 5 √ó 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <fct> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_is_factor(tbl, vars(f))  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us tbl %>% test_col_is_factor(vars(f)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_integer.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain integer values? ‚Äî col_is_integer","title":"Do the columns contain integer values? ‚Äî col_is_integer","text":"col_is_integer() validation function, expect_col_is_integer() expectation function, test_col_is_integer() test function check whether one columns table integer type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate single test unit, whether column integer-type column .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_integer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain integer values? ‚Äî col_is_integer","text":"","code":"col_is_integer(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_integer(object, columns, threshold = 1)  test_col_is_integer(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_integer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain integer values? ‚Äî col_is_integer","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_integer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain integer values? ‚Äî col_is_integer","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_integer.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain integer values? ‚Äî col_is_integer","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_integer.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain integer values? ‚Äî col_is_integer","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_integer.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain integer values? ‚Äî col_is_integer","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_integer.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain integer values? ‚Äî col_is_integer","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_integer() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_integer() validation step expressed R code corresponding YAML representation. practice, often shorter columns, argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_is_integer(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_integer()` step.\",     active = FALSE   )  # YAML representation steps: - col_is_integer:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_integer()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_integer.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain integer values? ‚Äî col_is_integer","text":"2-24","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_integer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain integer values? ‚Äî col_is_integer","text":"","code":"# For all examples here, we'll use # a simple table with a character # column (`a`) and a integer column # (`b`) tbl <-   dplyr::tibble(     a = letters[1:6],     b = 2:7   )    # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that column `b` has the # `integer` class agent <-   create_agent(tbl) %>%   col_is_integer(vars(b)) %>%   interrogate()  # Determine if this validation # had no failing test units (1) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>% col_is_integer(vars(b)) #> # A tibble: 6 √ó 2 #>   a         b #>   <chr> <int> #> 1 a         2 #> 2 b         3 #> 3 c         4 #> 4 d         5 #> 5 e         6 #> 6 f         7  # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_is_integer(tbl, vars(b))  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us tbl %>% test_col_is_integer(vars(b)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_logical.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain logical values? ‚Äî col_is_logical","title":"Do the columns contain logical values? ‚Äî col_is_logical","text":"col_is_logical() validation function, expect_col_is_logical() expectation function, test_col_is_logical() test function check whether one columns table logical (TRUE/FALSE) type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate single test unit, whether column logical-type column .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_logical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain logical values? ‚Äî col_is_logical","text":"","code":"col_is_logical(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_logical(object, columns, threshold = 1)  test_col_is_logical(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_logical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain logical values? ‚Äî col_is_logical","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_logical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain logical values? ‚Äî col_is_logical","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_logical.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain logical values? ‚Äî col_is_logical","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_logical.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain logical values? ‚Äî col_is_logical","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_logical.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain logical values? ‚Äî col_is_logical","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_logical.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain logical values? ‚Äî col_is_logical","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_logical() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_logical() validation step expressed R code corresponding YAML representation. practice, often shorter columns, argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_is_logical(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_logical()` step.\",     active = FALSE   )  # YAML representation steps: - col_is_logical:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_logical()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_logical.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain logical values? ‚Äî col_is_logical","text":"2-25","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_logical.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain logical values? ‚Äî col_is_logical","text":"","code":"# The `small_table` dataset in the # package has an `e` column which has # logical values; the following examples # will validate that that column is of # the `logical` class  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that the column `e` has the # `logical` class agent <-   create_agent(small_table) %>%   col_is_logical(vars(e)) %>%   interrogate()    # Determine if this validation # had no failing test units (1) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option small_table %>%   col_is_logical(vars(e)) %>%   dplyr::slice(1:5) #> # A tibble: 5 √ó 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_is_logical(   small_table, vars(e) )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us small_table %>%   test_col_is_logical(vars(e)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_numeric.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain numeric values? ‚Äî col_is_numeric","title":"Do the columns contain numeric values? ‚Äî col_is_numeric","text":"col_is_numeric() validation function, expect_col_is_numeric() expectation function, test_col_is_numeric() test function check whether one columns table numeric type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate single test unit, whether column numeric-type column .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_numeric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain numeric values? ‚Äî col_is_numeric","text":"","code":"col_is_numeric(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_numeric(object, columns, threshold = 1)  test_col_is_numeric(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_numeric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain numeric values? ‚Äî col_is_numeric","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_numeric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain numeric values? ‚Äî col_is_numeric","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_numeric.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain numeric values? ‚Äî col_is_numeric","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_numeric.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain numeric values? ‚Äî col_is_numeric","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_numeric.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain numeric values? ‚Äî col_is_numeric","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_numeric.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain numeric values? ‚Äî col_is_numeric","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_numeric() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_numeric() validation step expressed R code corresponding YAML representation. practice, often shorter columns, argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_is_numeric(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_numeric()` step.\",     active = FALSE   )  # YAML representation steps: - col_is_numeric:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_numeric()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_numeric.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain numeric values? ‚Äî col_is_numeric","text":"2-23","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_numeric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain numeric values? ‚Äî col_is_numeric","text":"","code":"# The `small_table` dataset in the # package has a `d` column that is # known to be numeric; the following # examples will validate that that # column is indeed of the `numeric` # class  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that the column `d` has # the `numeric` class agent <-   create_agent(small_table) %>%   col_is_numeric(vars(d)) %>%   interrogate()    # Determine if this validation # had no failing test units (1) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option small_table %>%   col_is_numeric(vars(d)) %>%   dplyr::slice(1:5) #> # A tibble: 5 √ó 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_is_numeric(   small_table, vars(d) )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us small_table %>%   test_col_is_numeric(vars(d)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_posix.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain POSIXct dates? ‚Äî col_is_posix","title":"Do the columns contain POSIXct dates? ‚Äî col_is_posix","text":"col_is_posix() validation function, expect_col_is_posix() expectation function, test_col_is_posix() test function check whether one columns table R POSIXct date-time type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate single test unit, whether column POSIXct-type column .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_posix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain POSIXct dates? ‚Äî col_is_posix","text":"","code":"col_is_posix(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_posix(object, columns, threshold = 1)  test_col_is_posix(object, columns, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_posix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain POSIXct dates? ‚Äî col_is_posix","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_posix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain POSIXct dates? ‚Äî col_is_posix","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_posix.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain POSIXct dates? ‚Äî col_is_posix","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_posix.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain POSIXct dates? ‚Äî col_is_posix","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_posix.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain POSIXct dates? ‚Äî col_is_posix","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_posix.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain POSIXct dates? ‚Äî col_is_posix","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_posix() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_posix() validation step expressed R code corresponding YAML representation. practice, often shorter columns, argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_is_posix(     vars(a),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_posix()` step.\",     active = FALSE   )  # YAML representation steps: - col_is_posix:     columns: vars(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_posix()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_posix.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain POSIXct dates? ‚Äî col_is_posix","text":"2-27","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_is_posix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain POSIXct dates? ‚Äî col_is_posix","text":"","code":"# The `small_table` dataset in the # package has a `date_time` column; # the following examples will validate # that that column is of the `POSIXct` # and `POSIXt` classes  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that the column `date_time` # is indeed a date-time column agent <-   create_agent(small_table) %>%   col_is_posix(vars(date_time)) %>%   interrogate()    # Determine if this validation # had no failing test units (1) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option small_table %>%   col_is_posix(vars(date_time)) %>%   dplyr::slice(1:5) #> # A tibble: 5 √ó 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_is_posix(   small_table, vars(date_time) )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us small_table %>%   test_col_is_posix(vars(date_time)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a table column schema manually or with a reference table ‚Äî col_schema","title":"Generate a table column schema manually or with a reference table ‚Äî col_schema","text":"table column schema object, can created col_schema(), necessary using col_schema_match() validation function (checks whether table object study matches known column schema). col_schema object can made carefully supplying column names types set named arguments, , provide table object, data.frame, tbl_df, tbl_dbi, tbl_spark varieties. additional option, just validating schema tbl_dbi tbl_spark object: can validate schema based R column types (e.g., \"numeric\", \"character\", etc.), SQL column types (e.g., \"double\", \"varchar\", etc.), Spark SQL column types (\"DoubleType\", \"StringType\", etc.). great want validate table column schemas server side tabular data collected loaded R.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a table column schema manually or with a reference table ‚Äî col_schema","text":"","code":"col_schema(..., .tbl = NULL, .db_col_types = c(\"r\", \"sql\"))"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a table column schema manually or with a reference table ‚Äî col_schema","text":"... set named arguments names refer column names values one column types. .tbl option use table object define schema. provided values provided ... ignored. can either table object, table-prep formula.can table object data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, table-prep formula (~ <table reading code>) function (function() <table reading code>) can used lazily read table interrogation time. .db_col_types Determines whether column types refer R column types (\"r\") SQL column types (\"sql\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Generate a table column schema manually or with a reference table ‚Äî col_schema","text":"13-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a table column schema manually or with a reference table ‚Äî col_schema","text":"","code":"# Create a simple table with two # columns: one `integer` and the # other `character` tbl <-    dplyr::tibble(     a = 1:5,     b = letters[1:5]   )  # Create a column schema object # that describes the columns and # their types (in the expected # order) schema_obj <-    col_schema(     a = \"integer\",     b = \"character\"   )  # Validate that the schema object # `schema_obj` exactly defines # the column names and column types # of the `tbl` table agent <-   create_agent(tbl = tbl) %>%   col_schema_match(schema_obj) %>%   interrogate()  # Determine if these three validation # steps passed by using `all_passed()` all_passed(agent) #> [1] TRUE  # We can alternatively create # a column schema object from a # `tbl_df` object schema_obj <-   col_schema(     .tbl = dplyr::tibble(       a = integer(0),       b = character(0)     )   )  # This should provide the same # interrogation results as in the # previous example create_agent(tbl = tbl) %>%   col_schema_match(schema_obj) %>%   interrogate() %>%   all_passed() #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Do columns in the table (and their types) match a predefined schema? ‚Äî col_schema_match","title":"Do columns in the table (and their types) match a predefined schema? ‚Äî col_schema_match","text":"col_schema_match() validation function, expect_col_schema_match() expectation function, test_col_schema_match() test function work conjunction col_schema object (generated col_schema() function) determine whether expected schema matches target table. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operates single test unit, whether schema matches table (within constraints enforced complete, in_order, is_exact options). target table tbl_dbi tbl_spark object, can choose validate column schema based R column types (e.g., \"numeric\", \"character\", etc.), SQL column types (e.g., \"double\", \"varchar\", etc.), Spark SQL types (e.g,. \"DoubleType\", \"StringType\", etc.). option defined col_schema() function (.db_col_types argument). options make schema checking less stringent (default, validation operates highest level strictness). complete option set FALSE, can supply col_schema object partial inclusion columns. Using in_order set FALSE means requirement columns defined schema object order target table. Finally, is_exact option set FALSE means column classes/types provided particular column. can even NULL, skipping check column type.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do columns in the table (and their types) match a predefined schema? ‚Äî col_schema_match","text":"","code":"col_schema_match(   x,   schema,   complete = TRUE,   in_order = TRUE,   is_exact = TRUE,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_schema_match(   object,   schema,   complete = TRUE,   in_order = TRUE,   is_exact = TRUE,   threshold = 1 )  test_col_schema_match(   object,   schema,   complete = TRUE,   in_order = TRUE,   is_exact = TRUE,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do columns in the table (and their types) match a predefined schema? ‚Äî col_schema_match","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). schema table schema type col_schema can generated using col_schema() function. complete requirement account table columns provided schema. default, TRUE column names target table must present schema object. restriction can relaxed using FALSE, can provide subset table columns schema. in_order stringent requirement enforcing order columns provided schema. default, TRUE order columns schema target table must match. setting FALSE, strict order requirement removed. is_exact Determines whether check column types exact even performed . example, columns R data frames may multiple classes (e.g., date-time column can \"POSIXct\" \"POSIXt\" classes). using is_exact == FALSE, column type user-defined schema date-time value can set either \"POSIXct\" \"POSIXt\" pass validation (column, least). can taken step using NULL column type user-defined schema skip validation check column type. default, is_exact set TRUE. actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do columns in the table (and their types) match a predefined schema? ‚Äî col_schema_match","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema_match.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do columns in the table (and their types) match a predefined schema? ‚Äî col_schema_match","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. Using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema_match.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do columns in the table (and their types) match a predefined schema? ‚Äî col_schema_match","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema_match.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do columns in the table (and their types) match a predefined schema? ‚Äî col_schema_match","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_schema_match() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_schema_match() validation step expressed R code corresponding YAML representation. practice, often shorter schema argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_schema_match(     schema = col_schema(       a = \"integer\",       b = \"character\"     ),      complete = FALSE,     in_order = FALSE,     is_exact = FALSE,     actions = action_levels(stop_at = 1),     label = \"The `col_schema_match()` step.\",     active = FALSE   )  # YAML representation steps: - col_schema_match:     schema:       a: integer       b: character     complete: false     in_order: false     is_exact: false     actions:       stop_count: 1.0     label: The `col_schema_match()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema_match.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do columns in the table (and their types) match a predefined schema? ‚Äî col_schema_match","text":"2-30","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_schema_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do columns in the table (and their types) match a predefined schema? ‚Äî col_schema_match","text":"","code":"# For all examples here, we'll use # a simple table with two columns: # one `integer` (`a`) and the other # `character` (`b`); the following # examples will validate that the # table columns abides match a schema # object as created by `col_schema()` tbl <-    dplyr::tibble(     a = 1:5,     b = letters[1:5]   )    tbl #> # A tibble: 5 √ó 2 #>       a b     #>   <int> <chr> #> 1     1 a     #> 2     2 b     #> 3     3 c     #> 4     4 d     #> 5     5 e      # Create a column schema object with # the helper function `col_schema()` # that describes the columns and # their types (in the expected order) schema_obj <-    col_schema(     a = \"integer\",     b = \"character\"   )    # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that the schema object # `schema_obj` exactly defines # the column names and column types agent <-   create_agent(tbl) %>%   col_schema_match(schema_obj) %>%   interrogate()  # Determine if this validation # had no failing test units (there is # a single test unit governed by # whether there is a match) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>% col_schema_match(schema_obj) #> # A tibble: 5 √ó 2 #>       a b     #>   <int> <chr> #> 1     1 a     #> 2     2 b     #> 3     3 c     #> 4     4 d     #> 5     5 e      # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_schema_match(tbl, schema_obj)  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us tbl %>% test_col_schema_match(schema_obj) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":null,"dir":"Reference","previous_headings":"","what":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"col_vals_between() validation function, expect_col_vals_between() expectation function, test_col_vals_between() test function check whether column values table fall within range. range specified three arguments: left, right, inclusive. left right values specify lower upper bounds. bounds can specified single, literal values column names given vars(). inclusive argument, vector two logical values relating left right, states whether bound inclusive . default c(TRUE, TRUE), endpoints inclusive (.e., [left, right]). partially-unbounded versions function, can use col_vals_lt(), col_vals_lte(), col_vals_gt(), col_vals_gte() validation functions. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate single test unit, whether column integer-type column . validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"","code":"col_vals_between(   x,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. left lower bound range. validation includes bound value (first element inclusive TRUE) addition values greater left. can single value compatible column given vars(). right upper bound range. validation includes bound value (second element inclusive TRUE) addition values lower right. can single value compatible column given vars(). inclusive two-element logical value indicates whether left right bounds inclusive. default, bounds inclusive. na_pass encountered NA values considered passing test units? default FALSE. Set TRUE give NAs pass. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"providing multiple column names columns, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_between() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_between() validation step expressed R code corresponding YAML representation. practice, often shorter columns, left, right arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_between(     columns = vars(a),     left = 1,     right = 2,     inclusive = c(TRUE, FALSE),     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_between()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_between:     columns: vars(a)     left: 1.0     right: 2.0     inclusive:     - true     - false     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_between()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"2-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_between.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do column data lie between two specified values or data in other columns? ‚Äî col_vals_between","text":"","code":"# The `small_table` dataset in the # package has a column of numeric # values in `c` (there are a few NAs # in that column); the following # examples will validate the values # in that numeric column  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that values in column `c` # are all between `1` and `9`; because # there are NA values, we'll choose to # let those pass validation by setting # `na_pass = TRUE` agent <-   create_agent(small_table) %>%   col_vals_between(     vars(c), 1, 9, na_pass = TRUE   ) %>%   interrogate()    # Determine if this validation # had no failing test units (there # are 13 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option small_table %>%   col_vals_between(     vars(c), 1, 9, na_pass = TRUE   ) %>%   dplyr::pull(c) #>  [1]  3  8  3 NA  7  4  3  2  9  9  7  8 NA  # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_between(   small_table, vars(c), 1, 9,   na_pass = TRUE )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us small_table %>%   test_col_vals_between(     vars(c), 1, 9,     na_pass = TRUE   ) #> [1] TRUE  # An additional note on the bounds for # this function: they are inclusive by # default (i.e., values of exactly 1 # and 9 will pass); we can modify the # inclusiveness of the upper and lower # bounds with the `inclusive` option, # which is a length-2 logical vector  # Testing with the upper bound being # non-inclusive, we get `FALSE` since # two values are `9` and they now fall # outside of the upper (or right) bound small_table %>%   test_col_vals_between(     vars(c), 1, 9,     inclusive = c(TRUE, FALSE),     na_pass = TRUE   ) #> [1] FALSE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_decreasing.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data decreasing by row? ‚Äî col_vals_decreasing","title":"Are column data decreasing by row? ‚Äî col_vals_decreasing","text":"col_vals_decreasing() validation function, expect_col_vals_decreasing() expectation function, test_col_vals_decreasing() test function check whether column values table decreasing moving table. options allowing NA values target column, allowing stationary phases (consecutive values change), even allowing increasing movements certain threshold. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_decreasing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data decreasing by row? ‚Äî col_vals_decreasing","text":"","code":"col_vals_decreasing(   x,   columns,   allow_stationary = FALSE,   increasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_decreasing(   object,   columns,   allow_stationary = FALSE,   increasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_decreasing(   object,   columns,   allow_stationary = FALSE,   increasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_decreasing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data decreasing by row? ‚Äî col_vals_decreasing","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. allow_stationary option allow pauses decreasing values. example values test units [85, 82, 82, 80, 77] third unit (82, appearing second time) marked fail allow_stationary FALSE (default). Using allow_stationary = TRUE result test units [85, 82, 82, 80, 77] marked pass. increasing_tol optional threshold value allows movement numerical values positive direction. default NULL using numerical value set absolute threshold positive travel allowed across numerical test units. Note setting value also effect setting allow_stationary TRUE. na_pass encountered NA values considered passing test units? default FALSE. Set TRUE give NAs pass. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_decreasing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data decreasing by row? ‚Äî col_vals_decreasing","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_decreasing.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data decreasing by row? ‚Äî col_vals_decreasing","text":"providing multiple column names columns, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_decreasing.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data decreasing by row? ‚Äî col_vals_decreasing","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_decreasing.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data decreasing by row? ‚Äî col_vals_decreasing","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_decreasing.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data decreasing by row? ‚Äî col_vals_decreasing","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_decreasing.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data decreasing by row? ‚Äî col_vals_decreasing","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_decreasing.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data decreasing by row? ‚Äî col_vals_decreasing","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_decreasing.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data decreasing by row? ‚Äî col_vals_decreasing","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_decreasing() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_decreasing() validation step expressed R code corresponding YAML representation. practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_decreasing(     columns = vars(a),     allow_stationary = TRUE,     increasing_tol = 0.5,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_decreasing()` step.\",     active = FALSE   ) %>% yaml_agent_string()  # YAML representation steps: - col_vals_decreasing:     columns: vars(a)     allow_stationary: true     increasing_tol: 0.5     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_decreasing()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_decreasing.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data decreasing by row? ‚Äî col_vals_decreasing","text":"2-14","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"col_vals_equal() validation function, expect_col_vals_equal() expectation function, test_col_vals_equal() test function check whether column values table equal specified value. value can specified single, literal value column name given vars(). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"","code":"col_vals_equal(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. value value used test equality. can single value compatible column given vars(). column values equal specified pass validation. na_pass encountered NA values considered passing test units? default FALSE. Set TRUE give NAs pass. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"providing multiple column names columns, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_equal() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_equal() validation step expressed R code corresponding YAML representation. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_equal(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_equal()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_equal:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_equal()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"2-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_equal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data equal to a fixed value or data in another column? ‚Äî col_vals_equal","text":"","code":"# For all of the examples here, we'll # use a simple table with three numeric # columns (`a`, `b`, and `c`) and three # character columns (`d`, `e`, and `f`) tbl <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 2, 2),     d = LETTERS[c(1:3, 5:7)],     e = LETTERS[c(1:6)],     f = LETTERS[c(1:6)]   )    tbl #> # A tibble: 6 √ó 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 A     A     A     #> 2     5     1     1 B     B     B     #> 3     5     1     1 C     C     C     #> 4     5     2     2 E     D     D     #> 5     5     2     2 F     E     E     #> 6     5     2     2 G     F     F      # A: Using an `agent` with validation #    functions and then `interrogate()`   # Validate that values in column `a` # are all equal to the value of `5` agent <-   create_agent(tbl) %>%   col_vals_equal(vars(a), 5) %>%   interrogate()  # Determine if this validation # had no failing test units (there # are 6 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>%    col_vals_equal(vars(a), 5) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_equal(tbl, vars(a), 5)  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us test_col_vals_equal(tbl, vars(a), 5) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"Do column data agree with a predicate expression? ‚Äî col_vals_expr","title":"Do column data agree with a predicate expression? ‚Äî col_vals_expr","text":"col_vals_expr() validation function, expect_col_vals_expr() expectation function, test_col_vals_expr() test function check whether column values table agree user-defined predicate expression. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do column data agree with a predicate expression? ‚Äî col_vals_expr","text":"","code":"col_vals_expr(   x,   expr,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_expr(object, expr, preconditions = NULL, threshold = 1)  test_col_vals_expr(object, expr, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_expr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do column data agree with a predicate expression? ‚Äî col_vals_expr","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). expr expression use test. can either form call made expr() function one-sided R formula (using leading ~). preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_expr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do column data agree with a predicate expression? ‚Äî col_vals_expr","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_expr.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Do column data agree with a predicate expression? ‚Äî col_vals_expr","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_expr.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Do column data agree with a predicate expression? ‚Äî col_vals_expr","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_expr.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do column data agree with a predicate expression? ‚Äî col_vals_expr","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_expr.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do column data agree with a predicate expression? ‚Äî col_vals_expr","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_expr.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do column data agree with a predicate expression? ‚Äî col_vals_expr","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_expr() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_expr() validation step expressed R code corresponding YAML representation. practice, often shorter expr argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_expr(     expr = ~ a %% 1 == 0,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_expr()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_expr:     expr: ~a%%1 == 0     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_expr()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_expr.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do column data agree with a predicate expression? ‚Äî col_vals_expr","text":"2-19","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_expr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do column data agree with a predicate expression? ‚Äî col_vals_expr","text":"","code":"# For all of the examples here, we'll # use a simple table with three numeric # columns (`a`, `b`, and `c`) and three # character columns (`d`, `e`, and `f`) tbl <-   dplyr::tibble(     a = c(1, 2, 1, 7, 8, 6),     b = c(0, 0, 0, 1, 1, 1),     c = c(0.5, 0.3, 0.8, 1.4, 1.9, 1.2),   )    tbl #> # A tibble: 6 √ó 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     1     0   0.5 #> 2     2     0   0.3 #> 3     1     0   0.8 #> 4     7     1   1.4 #> 5     8     1   1.9 #> 6     6     1   1.2  # A: Using an `agent` with validation #    functions and then `interrogate()`   # Validate that values in column `a` # are integer-like by using the R modulo # operator and expecting `0` agent <-   create_agent(tbl) %>%   col_vals_expr(expr(a %% 1 == 0)) %>%   interrogate()  # Determine if this validation # had no failing test units (there # are 6 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>%    col_vals_expr(expr(a %% 1 == 0)) %>%   dplyr::pull(a) #> [1] 1 2 1 7 8 6    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_expr(tbl, ~ a %% 1 == 0)  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us test_col_vals_expr(tbl, ~ a %% 1 == 0) #> [1] TRUE  # Variations  # We can do more complex things by # taking advantage of the `case_when()` # and `between()` functions (available # for use in the pointblank package)  tbl %>%   test_col_vals_expr(~ case_when(     b == 0 ~ a %>% between(0, 5) & c < 1,     b == 1 ~ a > 5 & c >= 1   )) #> [1] TRUE  # If you only want to test a subset of # rows, then the `case_when()` statement # doesn't need to be exhaustive; any # rows that don't fall into the cases # will be pruned (giving us less test # units overall)  tbl %>%   test_col_vals_expr(~ case_when(     b == 1 ~ a > 5 & c >= 1   )) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"col_vals_gt() validation function, expect_col_vals_gt() expectation function, test_col_vals_gt() test function check whether column values table greater specified value (exact comparison used function col_val > value). value can specified single, literal value column name given vars(). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"","code":"col_vals_gt(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_gt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_gt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. value value used comparison. can single value compatible column given vars(). column values greater specified pass validation. na_pass encountered NA values considered passing test units? default FALSE. Set TRUE give NAs pass. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"validation function, return value either ptblank_agent object table object (depending whether agentobject table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"providing multiple column names columns, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_gt() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_gt() validation step expressed R code corresponding YAML representation. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_gt(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_gt()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_gt:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_gt()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"2-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data greater than a fixed value or data in another column? ‚Äî col_vals_gt","text":"","code":"# For all of the examples here, we'll # use a simple table with three numeric # columns (`a`, `b`, and `c`) and three # character columns (`d`, `e`, and `f`) tbl <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 3, 4),     d = LETTERS[a],     e = LETTERS[b],     f = LETTERS[c]   )    tbl #> # A tibble: 6 √ó 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A     #> 2     5     1     1 E     A     A     #> 3     5     1     1 E     A     A     #> 4     5     2     2 E     B     B     #> 5     5     2     3 E     B     C     #> 6     5     2     4 E     B     D      # A: Using an `agent` with validation #    functions and then `interrogate()`   # Validate that values in column `a` # are all greater than the value of `4` agent <-   create_agent(tbl) %>%   col_vals_gt(vars(a), value = 4) %>%   interrogate()  # Determine if this validation # had no failing test units (there # are 6 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>%    col_vals_gt(vars(a), value = 4) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_gt(   tbl, vars(a),   value = 4 )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us test_col_vals_gt(   tbl, vars(a),    value = 4 ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"col_vals_gte() validation function, expect_col_vals_gte() expectation function, test_col_vals_gte() test function check whether column values table greater equal specified value (exact comparison used function col_val >= value). value can specified single, literal value column name given vars(). validation step function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"","code":"col_vals_gte(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_gte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_gte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. value value used comparison. can single value compatible column given vars(). column values greater equal specified pass validation. na_pass encountered NA values considered passing test units? default FALSE. Set TRUE give NAs pass. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"providing multiple column names columns, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_gte() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_gte() validation step expressed R code corresponding YAML representation. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_gte(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_gte()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_gte:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_gte()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"2-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_gte.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data greater than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_gte","text":"","code":"# For all of the examples here, we'll # use a simple table with three numeric # columns (`a`, `b`, and `c`) and three # character columns (`d`, `e`, and `f`) tbl <-   dplyr::tibble(       a = c(5, 5, 5, 5, 5, 5),       b = c(1, 1, 1, 2, 2, 2),       c = c(1, 1, 1, 2, 3, 4),       d = LETTERS[a],       e = LETTERS[b],       f = LETTERS[c]   )    tbl #> # A tibble: 6 √ó 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A     #> 2     5     1     1 E     A     A     #> 3     5     1     1 E     A     A     #> 4     5     2     2 E     B     B     #> 5     5     2     3 E     B     C     #> 6     5     2     4 E     B     D      # A: Using an `agent` with validation #    functions and then `interrogate()`   # Validate that values in column `a` # are all greater than or equal to the # value of `5` agent <-   create_agent(tbl) %>%   col_vals_gte(vars(a), 5) %>%   interrogate()  # Determine if this validation # had no failing test units (there # are 6 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>%    col_vals_gte(vars(a), 5) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_gte(tbl, vars(a), 5)  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us test_col_vals_gte(tbl, vars(a), 5) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_in_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","title":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","text":"col_vals_in_set() validation function, expect_col_vals_in_set() expectation function, test_col_vals_in_set() test function check whether column values table part specified set values. validation step function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_in_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","text":"","code":"col_vals_in_set(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_in_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_in_set(object, columns, set, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_in_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. set vector numeric string-based elements, column values found within set considered passing. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_in_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_in_set.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_in_set.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_in_set.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_in_set.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_in_set.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_in_set.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_in_set() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_in_set() validation step expressed R code corresponding YAML representation. practice, often shorter columns, set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_in_set(     columns = vars(a),     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_in_set()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_in_set:     columns: vars(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: The `col_vals_in_set()` step.    active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_in_set.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","text":"2-9","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_in_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data part of a specified set of values? ‚Äî col_vals_in_set","text":"","code":"# The `small_table` dataset in the # package will be used to validate that # column values are part of a given set  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that values in column `f` # are all part of the set of values # containing `low`, `mid`, and `high` agent <-   create_agent(small_table) %>%   col_vals_in_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) %>%   interrogate()    # Determine if this validation # had no failing test units (there # are 13 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option small_table %>%   col_vals_in_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\"   # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_in_set(   small_table,   vars(f), c(\"low\", \"mid\", \"high\") )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us small_table %>%   test_col_vals_in_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_increasing.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data increasing by row? ‚Äî col_vals_increasing","title":"Are column data increasing by row? ‚Äî col_vals_increasing","text":"col_vals_increasing() validation function, expect_col_vals_increasing() expectation function, test_col_vals_increasing() test function check whether column values table increasing moving table. options allowing NA values target column, allowing stationary phases (consecutive values change), even allowing decreasing movements certain threshold. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_increasing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data increasing by row? ‚Äî col_vals_increasing","text":"","code":"col_vals_increasing(   x,   columns,   allow_stationary = FALSE,   decreasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_increasing(   object,   columns,   allow_stationary = FALSE,   decreasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_increasing(   object,   columns,   allow_stationary = FALSE,   decreasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_increasing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data increasing by row? ‚Äî col_vals_increasing","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. allow_stationary option allow pauses decreasing values. example values test units [80, 82, 82, 85, 88] third unit (82, appearing second time) marked fail allow_stationary FALSE (default). Using allow_stationary = TRUE result test units [80, 82, 82, 85, 88] marked pass. decreasing_tol optional threshold value allows movement numerical values negative direction. default NULL using numerical value set absolute threshold negative travel allowed across numerical test units. Note setting value also effect setting allow_stationary TRUE. na_pass encountered NA values considered passing test units? default FALSE. Set TRUE give NAs pass. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_increasing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data increasing by row? ‚Äî col_vals_increasing","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_increasing.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data increasing by row? ‚Äî col_vals_increasing","text":"providing multiple column names columns, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_increasing.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data increasing by row? ‚Äî col_vals_increasing","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_increasing.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data increasing by row? ‚Äî col_vals_increasing","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_increasing.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data increasing by row? ‚Äî col_vals_increasing","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_increasing.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data increasing by row? ‚Äî col_vals_increasing","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_increasing.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data increasing by row? ‚Äî col_vals_increasing","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_increasing.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data increasing by row? ‚Äî col_vals_increasing","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_increasing() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_increasing() validation step expressed R code corresponding YAML representation. practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_increasing(     columns = vars(a),     allow_stationary = TRUE,     decreasing_tol = 0.5,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_increasing()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_increasing:     columns: vars(a)     allow_stationary: true     decreasing_tol: 0.5     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_increasing()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_increasing.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data increasing by row? ‚Äî col_vals_increasing","text":"2-13","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"col_vals_lt() validation function, expect_col_vals_lt() expectation function, test_col_vals_lt() test function check whether column values table less specified value (exact comparison used function col_val < value). value can specified single, literal value column name given vars(). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"","code":"col_vals_lt(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_lt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_lt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. value value used comparison. can single value compatible column given vars(). column values less specified pass validation. na_pass encountered NA values considered passing test units? default FALSE. Set TRUE give NAs pass. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"providing multiple column names columns, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_lt() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_lt() validation step expressed R code corresponding YAML representation. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_lt(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_lt()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_lt:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_lt()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"2-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data less than a fixed value or data in another column? ‚Äî col_vals_lt","text":"","code":"# For all of the examples here, we'll # use a simple table with three numeric # columns (`a`, `b`, and `c`) and three # character columns (`d`, `e`, and `f`) tbl <-   dplyr::tibble(       a = c(5, 5, 5, 5, 5, 5),       b = c(1, 1, 1, 2, 2, 2),       c = c(1, 1, 1, 2, 3, 4),       d = LETTERS[a],       e = LETTERS[b],       f = LETTERS[c]   )    tbl #> # A tibble: 6 √ó 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A     #> 2     5     1     1 E     A     A     #> 3     5     1     1 E     A     A     #> 4     5     2     2 E     B     B     #> 5     5     2     3 E     B     C     #> 6     5     2     4 E     B     D      # A: Using an `agent` with validation #    functions and then `interrogate()`   # Validate that values in column `c` # are all less than the value of `5` agent <-   create_agent(tbl) %>%   col_vals_lt(vars(c), 5) %>%   interrogate()  # Determine if this validation # had no failing test units (there # are 6 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>%    col_vals_lt(vars(c), 5) %>%   dplyr::pull(c) #> [1] 1 1 1 2 3 4    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_lt(tbl, vars(c), 5)  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us test_col_vals_lt(tbl, vars(c), 5) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"col_vals_lte() validation function, expect_col_vals_lte() expectation function, test_col_vals_lte() test function check whether column values table less equal specified value (exact comparison used function col_val <= value). value can specified single, literal value column name given vars(). validation step function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"","code":"col_vals_lte(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_lte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_lte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. value value used comparison. can single value compatible column given vars(). column values less equal specified pass validation. na_pass encountered NA values considered passing test units? default FALSE. Set TRUE give NAs pass. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"providing multiple column names columns, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_lte() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_lte() validation step expressed R code corresponding YAML representation. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_lte(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_lte()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_lte:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_lte()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"2-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_lte.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data less than or equal to a fixed value or data in another\ncolumn? ‚Äî col_vals_lte","text":"","code":"# For all of the examples here, we'll # use a simple table with three numeric # columns (`a`, `b`, and `c`) and three # character columns (`d`, `e`, and `f`) tbl <-   dplyr::tibble(       a = c(5, 5, 5, 5, 5, 5),       b = c(1, 1, 1, 2, 2, 2),       c = c(1, 1, 1, 2, 3, 4),       d = LETTERS[a],       e = LETTERS[b],       f = LETTERS[c]   )    tbl #> # A tibble: 6 √ó 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A     #> 2     5     1     1 E     A     A     #> 3     5     1     1 E     A     A     #> 4     5     2     2 E     B     B     #> 5     5     2     3 E     B     C     #> 6     5     2     4 E     B     D      # A: Using an `agent` with validation #    functions and then `interrogate()`   # Validate that values in column `c` # are all less than or equal to the # value of `4` agent <-   create_agent(tbl) %>%   col_vals_lte(vars(c), 4) %>%   interrogate()  # Determine if this validation # had no failing test units (there # are 6 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>%    col_vals_lte(vars(c), 4) %>%   dplyr::pull(c) #> [1] 1 1 1 2 3 4    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_lte(tbl, vars(c), 4)  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us test_col_vals_lte(tbl, vars(c), 4) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","title":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","text":"col_vals_make_set() validation function, expect_col_vals_make_set() expectation function, test_col_vals_make_set() test function check whether set values seen least table column. necessary criterion additional values (outside definied set) seen (requirement relaxed col_vals_make_subset() validation function expectation test variants). validation step function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number elements set plus test unit reserved detecting column values outside set (outside value seen make additional test unit fail).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","text":"","code":"col_vals_make_set(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_make_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_make_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. set vector elements expected equal set unique values target column. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_set.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_set.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_set.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_set.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_set.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_set.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_make_set() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_make_set() validation step expressed R code corresponding YAML representation. practice, often shorter columns, set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_make_set(     columns = vars(a),     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_make_set()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_make_set:     columns: vars(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: The `col_vals_make_set()` step.    active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_set.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","text":"2-11","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is a set of values entirely accounted for in a column of values? ‚Äî col_vals_make_set","text":"","code":"# The `small_table` dataset in the # package will be used to validate that # column values are part of a given set  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that values in column `f` # comprise the values of `low`, `mid`, # and `high`, and, no other values agent <-   create_agent(small_table) %>%   col_vals_make_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) %>%   interrogate()    # Determine if this validation # had no failing test units (there # are 4 test units) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option small_table %>%   col_vals_make_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\"   # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_make_set(   small_table,   vars(f), c(\"low\", \"mid\", \"high\") )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us small_table %>%   test_col_vals_make_set(     vars(f), c(\"low\", \"mid\", \"high\")   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","title":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","text":"col_vals_make_subset() validation function, expect_col_vals_make_subset() expectation function, test_col_vals_make_subset() test function check whether set values seen least table column. validation step function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number elements set.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","text":"","code":"col_vals_make_subset(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_make_subset(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_make_subset(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. set vector elements expected subset unique values target column. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_subset.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_subset.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_subset.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_subset.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_subset.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_subset.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_make_subset() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_make_subset() validation step expressed R code corresponding YAML representation. practice, often shorter columns, set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_make_subset(     columns = vars(a),     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_make_subset()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_make_subset:     columns: vars(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: The `col_vals_make_subset()` step.    active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_subset.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","text":"2-12","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_make_subset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is a set of values a subset of a column of values? ‚Äî col_vals_make_subset","text":"","code":"# The `small_table` dataset in the # package will be used to validate that # column values are part of a given set  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that the distinct set of values # in column `f` contains at least the # subset defined as `low` and `high` (the # column actually has both of those and # some `mid` values) agent <-   create_agent(small_table) %>%   col_vals_make_subset(     vars(f), c(\"low\", \"high\")   ) %>%   interrogate()    # Determine if this validation # had no failing test units (there # are 2 test units, one for element # in the `set`) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option small_table %>%   col_vals_make_subset(     vars(f), c(\"low\", \"high\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\"   # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_make_subset(   small_table,   vars(f), c(\"low\", \"high\") )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us small_table %>%   test_col_vals_make_subset(     vars(f), c(\"low\", \"high\")   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":null,"dir":"Reference","previous_headings":"","what":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"col_vals_not_between() validation function, expect_col_vals_not_between() expectation function, test_col_vals_not_between() test function check whether column values table fall within range. range specified three arguments: left, right, inclusive. left right values specify lower upper bounds. bounds can specified single, literal values column names given vars(). inclusive argument, vector two logical values relating left right, states whether bound inclusive . default c(TRUE, TRUE), endpoints inclusive (.e., [left, right]). partially-unbounded versions function, can use col_vals_lt(), col_vals_lte(), col_vals_gt(), col_vals_gte() validation functions. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"","code":"col_vals_not_between(   x,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_not_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. left, right lower (left) upper (right) boundary values range. can expressed single values, compatible columns given vars(), combination . default, column values greater equal left less equal right fail validation. inclusivity bounds can modified inclusive option. inclusive two-element logical value indicates whether left right bounds inclusive. default, bounds inclusive. na_pass encountered NA values considered passing test units? default FALSE. Set TRUE give NAs pass. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"providing multiple column names columns, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_not_between() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_not_between() validation step expressed R code corresponding YAML representation. practice, often shorter columns, left, right arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_not_between(     columns = vars(a),     left = 1,     right = 2,     inclusive = c(TRUE, FALSE),     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_not_between()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_not_between:     columns: vars(a)     left: 1.0     right: 2.0     inclusive:     - true     - false     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_not_between()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"2-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_between.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do column data lie outside of two specified values or data in other columns? ‚Äî col_vals_not_between","text":"","code":"# The `small_table` dataset in the # package has a column of numeric # values in `c` (there are a few NAs # in that column); the following # examples will validate the values # in that numeric column  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that values in column `c` # are all between `10` and `20`; because # there are NA values, we'll choose to # let those pass validation by setting # `na_pass = TRUE` agent <-   create_agent(small_table) %>%   col_vals_not_between(     vars(c), 10, 20, na_pass = TRUE   ) %>%   interrogate()    # Determine if this validation # had no failing test units (there # are 13 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option small_table %>%   col_vals_not_between(     vars(c), 10, 20, na_pass = TRUE   ) %>%   dplyr::pull(c) #>  [1]  3  8  3 NA  7  4  3  2  9  9  7  8 NA  # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_not_between(   small_table, vars(c), 10, 20,   na_pass = TRUE )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us small_table %>%   test_col_vals_not_between(     vars(c), 10, 20,     na_pass = TRUE   ) #> [1] TRUE  # An additional note on the bounds for # this function: they are inclusive by # default; we can modify the # inclusiveness of the upper and lower # bounds with the `inclusive` option, # which is a length-2 logical vector  # In changing the lower bound to be # `9` and making it non-inclusive, we # get `TRUE` since although two values # are `9` and they fall outside of the # lower (or left) bound (and any values # 'not between' count as passing test # units) small_table %>%   test_col_vals_not_between(     vars(c), 9, 20,     inclusive = c(FALSE, TRUE),     na_pass = TRUE   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"col_vals_not_equal() validation function, expect_col_vals_not_equal() expectation function, test_col_vals_not_equal() test function check whether column values table equal specified value. validation step function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"","code":"col_vals_not_equal(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_not_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. value value used test inequality. can single value compatible column given vars(). column values equal specified pass validation. na_pass encountered NA values considered passing test units? default FALSE. Set TRUE give NAs pass. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_not_equal() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_not_equal() validation step expressed R code corresponding YAML representation. practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_not_equal(     columns = vars(a),     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_not_equal()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_not_equal:     columns: vars(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_not_equal()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"2-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_equal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data not equal to a fixed value or data in another column? ‚Äî col_vals_not_equal","text":"","code":"# For all of the examples here, we'll # use a simple table with three numeric # columns (`a`, `b`, and `c`) and three # character columns (`d`, `e`, and `f`) tbl <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 2, 2),     d = LETTERS[c(1:3, 5:7)],     e = LETTERS[c(1:6)],     f = LETTERS[c(1:6)]   )    tbl #> # A tibble: 6 √ó 6 #>       a     b     c d     e     f     #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 A     A     A     #> 2     5     1     1 B     B     B     #> 3     5     1     1 C     C     C     #> 4     5     2     2 E     D     D     #> 5     5     2     2 F     E     E     #> 6     5     2     2 G     F     F      # A: Using an `agent` with validation #    functions and then `interrogate()`   # Validate that values in column `a` # are all *not* equal to the value # of `6` agent <-   create_agent(tbl) %>%   col_vals_not_equal(vars(a), 6) %>%   interrogate()  # Determine if this validation # had no failing test units (there # are 6 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>%    col_vals_not_equal(vars(a), 6) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_not_equal(tbl, vars(a), 6)  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us test_col_vals_not_equal(tbl, vars(a), 6) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_in_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","title":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","text":"col_vals_not_in_set() validation function, expect_col_vals_not_in_set() expectation function, test_col_vals_not_in_set() test function check whether column values table part specified set values. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_in_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","text":"","code":"col_vals_not_in_set(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_in_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_not_in_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_in_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. set vector numeric string-based elements, column values found within set considered failing. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_in_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_in_set.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_in_set.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_in_set.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_in_set.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_in_set.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_in_set.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_not_in_set() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_not_in_set() validation step expressed R code corresponding YAML representation. practice, often shorter columns, set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_not_in_set(     columns = vars(a),     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_not_in_set()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_not_in_set:     columns: vars(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: The `col_vals_not_in_set()` step.    active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_in_set.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","text":"2-10","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_in_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are data not part of a specified set of values? ‚Äî col_vals_not_in_set","text":"","code":"# The `small_table` dataset in the # package will be used to validate that # column values are part of a given set  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that values in column `f` # contain none of the values `lows`, # `mids`, and `highs` agent <-   create_agent(small_table) %>%   col_vals_not_in_set(     vars(f), c(\"lows\", \"mids\", \"highs\")   ) %>%   interrogate()    # Determine if this validation # had no failing test units (there # are 13 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option small_table %>%   col_vals_not_in_set(     vars(f), c(\"lows\", \"mids\", \"highs\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\"   # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_not_in_set(   small_table,   vars(f), c(\"lows\", \"mids\", \"highs\") )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us small_table %>%   test_col_vals_not_in_set(     vars(f), c(\"lows\", \"mids\", \"highs\")   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_null.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data not NULL/NA? ‚Äî col_vals_not_null","title":"Are column data not NULL/NA? ‚Äî col_vals_not_null","text":"col_vals_not_null() validation function, expect_col_vals_not_null() expectation function, test_col_vals_not_null() test function check whether column values table NA values , database context, NULL values. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_null.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data not NULL/NA? ‚Äî col_vals_not_null","text":"","code":"col_vals_not_null(   x,   columns,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_null(object, columns, preconditions = NULL, threshold = 1)  test_col_vals_not_null(object, columns, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_null.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data not NULL/NA? ‚Äî col_vals_not_null","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_null.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data not NULL/NA? ‚Äî col_vals_not_null","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_null.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data not NULL/NA? ‚Äî col_vals_not_null","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_null.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data not NULL/NA? ‚Äî col_vals_not_null","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_null.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data not NULL/NA? ‚Äî col_vals_not_null","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_null.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data not NULL/NA? ‚Äî col_vals_not_null","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_null.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data not NULL/NA? ‚Äî col_vals_not_null","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_null.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data not NULL/NA? ‚Äî col_vals_not_null","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_not_null() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_not_null() validation step expressed R code corresponding YAML representation. practice, often shorter columns, argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_not_null(     vars(a),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_not_null()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_not_null:     columns: vars(a)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_not_null()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_null.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data not NULL/NA? ‚Äî col_vals_not_null","text":"2-16","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_not_null.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data not NULL/NA? ‚Äî col_vals_not_null","text":"","code":"# For all examples here, we'll use # a simple table with four columns: # `a`, `b`, `c`, and `d` tbl <-   dplyr::tibble(     a = c( 5,  7,  6,  5,  8),     b = c( 7,  1,  0,  0,  0),     c = c(NA, NA, NA, NA, NA),     d = c(35, 23, NA, NA, NA)   )    tbl #> # A tibble: 5 √ó 4 #>       a     b c         d #>   <dbl> <dbl> <lgl> <dbl> #> 1     5     7 NA       35 #> 2     7     1 NA       23 #> 3     6     0 NA       NA #> 4     5     0 NA       NA #> 5     8     0 NA       NA    # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that all values in column # `b` are *not* NA (they would be # non-NULL in a database context, which # isn't the case here) agent <-   create_agent(tbl) %>%   col_vals_not_null(vars(b)) %>%   interrogate()  # Determine if this validation # had no failing test units (there # are 5 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>%   col_vals_not_null(vars(b)) %>%   dplyr::pull(b) #> [1] 7 1 0 0 0  # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_not_null(tbl, vars(b))  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us tbl %>% test_col_vals_not_null(vars(b)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_null.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data NULL/NA? ‚Äî col_vals_null","title":"Are column data NULL/NA? ‚Äî col_vals_null","text":"col_vals_null() validation function, expect_col_vals_null() expectation function, test_col_vals_null() test function check whether column values table NA values , database context, NULL values. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_null.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data NULL/NA? ‚Äî col_vals_null","text":"","code":"col_vals_null(   x,   columns,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_null(object, columns, preconditions = NULL, threshold = 1)  test_col_vals_null(object, columns, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_null.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data NULL/NA? ‚Äî col_vals_null","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_null.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data NULL/NA? ‚Äî col_vals_null","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_null.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data NULL/NA? ‚Äî col_vals_null","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_null.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data NULL/NA? ‚Äî col_vals_null","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_null.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data NULL/NA? ‚Äî col_vals_null","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_null.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data NULL/NA? ‚Äî col_vals_null","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_null.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data NULL/NA? ‚Äî col_vals_null","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_null.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data NULL/NA? ‚Äî col_vals_null","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_null() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_null() validation step expressed R code corresponding YAML representation. practice, often shorter columns, argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_null(     vars(a),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_null()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_null:     columns: vars(a)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_null()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_null.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data NULL/NA? ‚Äî col_vals_null","text":"2-15","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_null.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data NULL/NA? ‚Äî col_vals_null","text":"","code":"# For all examples here, we'll use # a simple table with four columns: # `a`, `b`, `c`, and `d` tbl <-   dplyr::tibble(     a = c( 5,  7,  6,  5,  8),     b = c( 7,  1,  0,  0,  0),     c = c(NA, NA, NA, NA, NA),     d = c(35, 23, NA, NA, NA)   )    tbl #> # A tibble: 5 √ó 4 #>       a     b c         d #>   <dbl> <dbl> <lgl> <dbl> #> 1     5     7 NA       35 #> 2     7     1 NA       23 #> 3     6     0 NA       NA #> 4     5     0 NA       NA #> 5     8     0 NA       NA    # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that all values in column # `c` are NA (they would be NULL in a # database context, which isn't the # case here) agent <-   create_agent(tbl) %>%   col_vals_null(vars(c)) %>%   interrogate()  # Determine if this validation # had no failing test units (there # are 5 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>%   col_vals_null(vars(c)) %>%   dplyr::pull(c) #> [1] NA NA NA NA NA  # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_null(tbl, vars(c))  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us tbl %>% test_col_vals_null(vars(c)) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":null,"dir":"Reference","previous_headings":"","what":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"col_vals_regex() validation function, expect_col_vals_regex() expectation function, test_col_vals_regex() test function check whether column values table correspond regex matching expression. validation step function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"","code":"col_vals_regex(   x,   columns,   regex,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_regex(   object,   columns,   regex,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_regex(   object,   columns,   regex,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. regex regular expression pattern test match target column. regex matches values target columns pass validation. na_pass encountered NA values considered passing test units? default FALSE. Set TRUE give NAs pass. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_regex() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_regex() validation step expressed R code corresponding YAML representation. practice, often shorter columns regex arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_regex(     columns = vars(a),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_regex()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_regex:     columns: vars(a)     regex: '[0-9]-[a-z]{3}-[0-9]{3}'     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_regex()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"2-17","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_regex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do strings in column data match a regex pattern? ‚Äî col_vals_regex","text":"","code":"# The `small_table` dataset in the # package has a character-based `b` # column with values that adhere to # a very particular pattern; the # following examples will validate # that that column abides by a regex # pattern small_table #> # A tibble: 13 √ó 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # This is the regex pattern that will # be used throughout pattern <- \"[0-9]-[a-z]{3}-[0-9]{3}\"  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that all values in column # `b` match the regex `pattern` agent <-   create_agent(small_table) %>%   col_vals_regex(vars(b), pattern) %>%   interrogate()    # Determine if this validation # had no failing test units (there # are 13 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option small_table %>%   col_vals_regex(vars(b), pattern) %>%   dplyr::slice(1:5) #> # A tibble: 5 √ó 8 #>   date_time           date           a b             c      d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low    # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_regex(   small_table,   vars(b), pattern )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us small_table %>%   test_col_vals_regex(     vars(b), pattern   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"col_vals_within_spec() validation function, expect_col_vals_within_spec() expectation function, test_col_vals_within_spec() test function check whether column values table correspond specification (spec) type (details available Specifications section). validation step function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"","code":"col_vals_within_spec(   x,   columns,   spec,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_within_spec(   object,   columns,   spec,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_within_spec(   object,   columns,   spec,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. spec specification string. Examples \"email\", \"url\", \"postal[USA]\". options explained Specifications section. na_pass encountered NA values considered passing test units? default FALSE. Set TRUE give NAs pass. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"specifications","dir":"Reference","previous_headings":"","what":"Specifications","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"specification type must used spec argument. character-based keyword corresponds type data specified columns. following keywords can used: \"isbn\": International Standard Book Number (ISBN) unique numerical identifier books, pamphletes, educational kits, microforms, digital/electronic publications. specification formalized ISO 2108. keyword can used validate 10- 13-digit ISBNs. \"VIN\": vehicle identification number (VIN) unique code (includes serial number) used automotive industry identify individual motor vehicles, motorcycles, scooters, mopeds stipulated ISO 3779 ISO 4030. \"postal_code[<country_code>]\": postal code (also known postcodes, PIN, ZIP codes, depending region) series letters, digits, (sometimes including spaces/punctuation) included postal address aid sorting mail. coding varies country, country code either 2- (ISO 3166-1 alpha-2) 3-letter (ISO 3166-1 alpha-3) formats needs supplied along keywords (e.g., postal codes Germany, \"postal_code[DE]\" \"postal_code[DEU]\" can used). keyword alias \"zip\" can used US ZIP codes. \"credit_card\": credit card number can validated check works across large variety credit type issuers (card numbers allocated accordance ISO/IEC 7812). Numbers can various lengths (typically, 14-19 digits) key validation performed usage Luhn algorithm. \"iban[<country_code>]\": International Bank Account Number (IBAN) system identifying bank accounts across different countries purpose improving cross-border transactions. IBAN values validated conversion integer values performing basic mod-97 operation (described ISO 7064) . length coding varies country, country code either 2- (ISO 3166-1 alpha-2) 3-letter (ISO 3166-1 alpha-3) formats needs supplied along keywords (e.g., IBANs Germany, \"iban[DE]\" \"iban[DEU]\" can used). \"swift\": Business Identifier Codes (also known SWIFT-BIC, BIC, SWIFT code) defined standard format described ISO 9362. codes unique identifiers financial non-financial institutions. SWIFT stands Society Worldwide Interbank Financial Telecommunication. numbers used transferring money banks, especially important international wire transfers. \"phone\", \"email\", \"url\", \"ipv4\", \"ipv6\", \"mac\": Phone numbers, email addresses, Internet URLs, IPv4 IPv6 addresses, MAC addresses can validated respective keywords. validations use regex-based matching determine validity. single spec value provided per function call.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"providing multiple column names, result expansion validation steps number column names (e.g., vars(col_a, col_b) result entry two validation steps). Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_within_spec() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_within_spec() validation step expressed R code corresponding YAML representation. practice, often shorter columns spec arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    col_vals_within_spec(     columns = vars(a),     spec = \"email\",     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(b < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_within_spec()` step.\",     active = FALSE   )  # YAML representation steps: - col_vals_within_spec:     columns: vars(a)     spec: email     na_pass: true     preconditions: ~. %>% dplyr::filter(b < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_within_spec()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"2-18","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/col_vals_within_spec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do values in column data fit within a specification? ‚Äî col_vals_within_spec","text":"","code":"# The `specifications` dataset in the # package has columns of character data # that correspond to each of the # specifications that can be tested; # the following examples will validate # that the `email_addresses` column # has 5 correct values (this is true if # we get a subset of the data: the first # five rows) spec_slice <- specifications[1:5, ]  # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate that all values in the column # `email_addresses` are correct agent <-   create_agent(spec_slice) %>%   col_vals_within_spec(     vars(email_addresses),     spec = \"email\"   ) %>%   interrogate()    # Determine if this validation # had no failing test units (there # are 5 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option spec_slice %>%   col_vals_within_spec(     vars(email_addresses),     spec = \"email\"   ) %>%   dplyr::select(email_addresses) #> # A tibble: 5 √ó 1 #>   email_addresses                                                           #>   <chr>                                                                     #> 1 test@test.com                                                             #> 2 mail+mail@example.com                                                     #> 3 mail.email@e.test.com                                                     #> 4 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@letters-in-local.org #> 5 01234567890@numbers-in-local.net                                           # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_col_vals_within_spec(   spec_slice,   vars(email_addresses),   spec = \"email\" )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us spec_slice %>%   test_col_vals_within_spec(     vars(email_addresses),     spec = \"email\"   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/conjointly.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","title":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","text":"conjointly() validation function, expect_conjointly() expectation function, test_conjointly() test function check whether test units index (typically row) pass multiple validations. can use validation functions validate row units (col_vals_*() series), check column existence (col_exists()), validate column type (col_is_*() series). imposed constraint allowed validation functions, ensemble test units either comprised rows table (common preconditions applied) single test units (functions validate columns). functions used conjointly() validation step (composed using multiple validation function calls) ultimately perform rowwise test whether sub-validations reported pass test units. practice, example joint validation testing whether values column greater specific value adjacent values column b lie within specified range. validation functions part conjoint validation supplied one-sided R formulas (using leading ~, . stand data object). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/conjointly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","text":"","code":"conjointly(   x,   ...,   .list = list2(...),   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_conjointly(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )  test_conjointly(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/conjointly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). ... collection one-sided formulas consist validation functions validate row units (col_vals_*() series), column existence (col_exists()), column type (col_is_*() series). example ~ col_vals_gte(., vars(), 5.5), ~ col_vals_not_null(., vars(b)). .list Allows use list input alternative .... preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/conjointly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/conjointly.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","text":"providing multiple column names supplied validation steps, result expansion sub-validation steps number column names. Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/conjointly.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/conjointly.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/conjointly.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/conjointly.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/conjointly.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). conjointly() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call conjointly() validation step expressed R code corresponding YAML representation. practice, often shorter expressions validation steps necessary. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    conjointly(     ~ col_vals_lt(., vars(a), 8),     ~ col_vals_gt(., vars(c), vars(a)),     ~ col_vals_not_null(., vars(b)),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),      label = \"The `conjointly()` step.\",     active = FALSE   )  # YAML representation steps: - conjointly:     fns:     - ~col_vals_lt(., vars(a), 8)     - ~col_vals_gt(., vars(c), vars(a))     - ~col_vals_not_null(., vars(b))     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `conjointly()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/conjointly.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","text":"2-32","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/conjointly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform multiple rowwise validations for joint validity ‚Äî conjointly","text":"","code":"# For all examples here, we'll use # a simple table with three numeric # columns (`a`, `b`, and `c`); this is # a very basic table but it'll be more # useful when explaining things later tbl <-   dplyr::tibble(     a = c(5, 2, 6),     b = c(3, 4, 6),     c = c(9, 8, 7)   )    tbl #> # A tibble: 3 √ó 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     3     9 #> 2     2     4     8 #> 3     6     6     7    # A: Using an `agent` with validation #    functions and then `interrogate()`  # Validate a number of things on a # row-by-row basis using validation # functions of the `col_vals*` type # (all have the same number of test # units): (1) values in `a` are less # than `8`, (2) values in `c` are # greater than the adjacent values in # `a`, and (3) there aren't any NA # values in `b` agent <-   create_agent(tbl = tbl) %>%   conjointly(     ~ col_vals_lt(., vars(a), value = 8),     ~ col_vals_gt(., vars(c), value = vars(a)),     ~ col_vals_not_null(., vars(b))     ) %>%   interrogate()    # Determine if this validation # had no failing test units (there # are 3 test units, one for each row) all_passed(agent) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)`  # What's going on? Think of there being # three parallel validations, each # producing a column of `TRUE` or `FALSE` # values (`pass` or `fail`) and line them # up side-by-side, any rows with any # `FALSE` values results in a conjoint # `fail` test unit  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>%   conjointly(     ~ col_vals_lt(., vars(a), value = 8),     ~ col_vals_gt(., vars(c), value = vars(a)),     ~ col_vals_not_null(., vars(b))   ) #> # A tibble: 3 √ó 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     3     9 #> 2     2     4     8 #> 3     6     6     7  # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_conjointly(   tbl,   ~ col_vals_lt(., vars(a), value = 8),   ~ col_vals_gt(., vars(c), value = vars(a)),   ~ col_vals_not_null(., vars(b)) )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us tbl %>%   test_conjointly(     ~ col_vals_lt(., vars(a), value = 8),     ~ col_vals_gt(., vars(c), value = vars(a)),     ~ col_vals_not_null(., vars(b))   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/create_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a pointblank agent object ‚Äî create_agent","title":"Create a pointblank agent object ‚Äî create_agent","text":"create_agent() function creates agent object, used data quality reporting workflow. overall aim workflow generate useful reporting information assessing level data quality target table. can supply many validation functions user wishes write, thereby increasing level validation coverage table. agent assigned create_agent() call takes validation functions, expand validation steps (one numbered). process known developing validation plan. validation functions, called agent, merely instructions point interrogate() function called. kicks process agent acting validation plan getting results step. interrogation process complete, can say agent intel. Calling agent result reporting table. reporting interrogation can also accessed get_agent_report() function, reporting options.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/create_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a pointblank agent object ‚Äî create_agent","text":"","code":"create_agent(   tbl = NULL,   read_fn = NULL,   tbl_name = NULL,   label = NULL,   actions = NULL,   end_fns = NULL,   embed_report = FALSE,   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/reference/create_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a pointblank agent object ‚Äî create_agent","text":"tbl input table. can data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, function can used read input data table read_fn argument (case, tbl can NULL). read_fn table-prep formula used access target table. Even tbl provided, formula invoked obtain data (.e., read_fn takes priority). two ways specify read_fn: (1) right-hand side (RHS) formula expression (e.g., ~ { <table reading code>}) (2) function (e.g., function() { <table reading code>}). tbl_name optional name assign input table object. value provided, name generated based whatever information available. table name displayed header area agent report generated printing agent calling get_agent_report(). label optional label validation plan. value provided, label generated based current system time. Markdown can used make label visually appealing (appear header area agent report). actions option include list threshold levels validation steps can react accordingly exceeding set levels. created action_levels() helper function. action levels list used specific validation step, default set specified overridden. end_fns list expressions invoked end interrogation. expression form one-sided R formula, overall construction used: end_fns = list(~ <R statements>, ~ <R statements>, ...). example function included pointblank can sensibly used email_blast(), sends email validation report (based sending condition). embed_report option embed gt-based validation report ptblank_agent object. FALSE (default) table object generated available agent upon returning interrogation. lang language use automatic creation briefs (short descriptions validation step) agent report (summary table provides validation plan results interrogation. default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). locale optional locale ID use formatting values agent report summary table according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/create_agent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a pointblank agent object ‚Äî create_agent","text":"ptblank_agent object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/create_agent.html","id":"data-products-obtained-from-an-agent","dir":"Reference","previous_headings":"","what":"Data Products Obtained from an Agent","title":"Create a pointblank agent object ‚Äî create_agent","text":"detailed list object, known x-list, can obtained using get_agent_x_list() function agent. font information can taken whole, , broken step number (argument). Sometimes useful see rows failing ones. using get_data_extracts() function agent, either get list tibbles (steps data extracts) one tibble validation step specified argument. target data can split pieces represent 'pass' 'fail' portions get_sundered_data() function. primary requirement agent interrogate() called . addition, validation steps considered data splitting need operate values column (e.g., col_vals_*() functions conjointly()). -consideration validation steps, rows failing test units across validation steps comprise 'pass' data piece, rows least one failing test unit across series validations constitute 'fail' piece. just need know whether validations completely passed (.e., steps failing test units), all_passed() function used agent. However, practice, often case data validation steps free failing units. printing agent display agent report Viewer, can alternatively use get_agent_report() take advantage options (e.g., overriding language, modifying arrangement report rows, etc.), return report independent objects. example, display_table = TRUE option (default), get_agent_report() return gt table object (\"gt_tbl\"). display_table set FALSE, get data frame back instead.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/create_agent.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Create a pointblank agent object ‚Äî create_agent","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). example complex call create_agent() expressed R code corresponding YAML representation. practice, block YAML shorter since arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). requirement writing YAML representation agent read_fn specified (table supplied tbl ignored). typically follows chunk YAML steps part, corresponds addition validation steps via validation functions. Help articles validation function YAML section describes given validation function translated YAML. need preview transformation agent YAML (without committing anything disk), use yaml_agent_string() function. already .yml file holds agent, can get glimpse R expressions used regenerate agent yaml_agent_show_exprs().","code":"# R statement create_agent(   read_fn = ~ small_table,   tbl_name = \"small_table\",   label = \"An example.\",   actions = action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   ),    end_fns = list(     ~ beepr::beep(2),     ~ Sys.sleep(1)   ),    embed_report = TRUE,   lang = \"fr\",    locale = \"fr_CA\" )  # YAML representation type: agent read_fn: ~small_table tbl_name: small_table label: An example. lang: fr locale: fr_CA actions:   warn_fraction: 0.1 stop_fraction: 0.25 notify_fraction: 0.35 end_fns: - ~beepr::beep(2) - ~Sys.sleep(1) embed_report: true"},{"path":"https://rich-iannone.github.io/pointblank/reference/create_agent.html","id":"writing-an-agent-to-disk","dir":"Reference","previous_headings":"","what":"Writing an Agent to Disk","title":"Create a pointblank agent object ‚Äî create_agent","text":"agent object can written disk x_write_disk() function. can useful keeping history validations generating views data quality time. Agents stored serialized RDS format can easily retrieved x_read_disk() function. recommended table-prep formulas supplied read_fn argument create_agent(). way, agent read disk x_read_disk(), can reused access target table (may change, hence need use expression ).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/create_agent.html","id":"combining-several-agents-in-a-multiagent-object","dir":"Reference","previous_headings":"","what":"Combining Several Agents in a multiagent Object","title":"Create a pointblank agent object ‚Äî create_agent","text":"Multiple agent objects can part multiagent object, two functions can used : create_multiagent() read_disk_multiagent(). gathering multiple agents performed interrogations past, can get multiagent report showing data quality evolved time. use case interesting data quality monitoring management, , reporting (can customized get_multiagent_report()) robust changes validation steps given target table.","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/create_agent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Create a pointblank agent object ‚Äî create_agent","text":"1-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/create_agent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a pointblank agent object ‚Äî create_agent","text":"","code":"# Let's walk through a data quality # analysis of an extremely small table; # it's actually called `small_table` and # we can find it as a dataset in this # package small_table #> # A tibble: 13 √ó 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # We ought to think about what's # tolerable in terms of data quality so # let's designate proportional failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # static thresholds provided by `al` will # make the reporting a bit more useful agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want; then, we use `interrogate()` to # physically perform the validations and # gather intel agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5) %>%   col_vals_equal(     vars(d), value = vars(d),     na_pass = TRUE   ) %>%   col_vals_between(     vars(c),     left = vars(a), right = vars(d),     na_pass = TRUE   ) %>%   interrogate()    # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent)` report <- get_agent_report(agent) class(report) #> [1] \"ptblank_agent_report\" \"gt_tbl\"               \"list\"                  # What can you do with the report? # Print it from an R Markdown code # chunk, use it in a **blastula** email, # put it in a webpage, or further # modify it with the **gt** package  # From the report we know that Step # 4 had two test units (rows, really) # that failed; we can see those rows # with `get_data_extracts()`  agent %>% get_data_extracts(i = 4) #> # A tibble: 2 √ó 8 #>   date_time           date           a b             c     d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high  #> 2 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high   # We can get an x-list for the whole # validation (8 steps), or, just for # the 4th step with `get_agent_x_list()` xl_step_4 <-   agent %>% get_agent_x_list(i = 4)   # And then we can peruse the different # parts of the list; let's get the # fraction of test units that failed xl_step_4$f_failed #> [1] 0.15385  # Just printing the x-list will tell # us what's available therein xl_step_4 #> ‚îÄ‚îÄ The x-list for `small_table` ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ STEP 4 ‚îÄ‚îÄ #> $time_start $time_end (POSIXct [1]) #> $label $tbl_name $tbl_src $tbl_src_details (chr [1]) #> $tbl (spec_tbl_df, tbl_df, tbl, and data.frame) #> $col_names $col_types (chr [8]) #> $i $type $columns $values $label $briefs (mixed [1]) #> $eval_error $eval_warning (lgl [1]) #> $capture_stack (list [1]) #> $n $n_passed $n_failed $f_passed $f_failed (num [1]) #> $warn $stop $notify (lgl [1]) #> $lang (chr [1]) #> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # An x-list not specific to any step # will have way more information and a # slightly different structure; see # `help(get_agent_x_list)` for more info # get_agent_x_list(agent)"},{"path":"https://rich-iannone.github.io/pointblank/reference/create_informant.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a pointblank informant object ‚Äî create_informant","title":"Create a pointblank informant object ‚Äî create_informant","text":"create_informant() function creates informant object, used information management workflow. overall aim workflow record, collect, generate useful information data tables. can supply information useful describing particular data table. informant object created create_informant() function takes information-focused functions: info_columns(), info_tabular(), info_section(), info_snippet(). info_*() series functions allows progressive build information target table. info_columns() info_tabular() functions facilitate entry info text concerns table columns table proper; info_section() function allows creation arbitrary sections can multiple subsections full additional info text. system allows dynamic values culled target table way info_snippet(), getting named text extracts queries, use {<snippet_name>} info text. make use info_snippet() convenient common queries, set snip_*() functions provided package (snip_list(), snip_stats(), snip_lowest(), snip_highest()) though free use expressions. snippets need query target table return fragments info text, incorporate() function needs used initiate action. also necessary informant update metadata elements row column counts. incorporation process complete, snippets metadata updated. Calling informant result reporting table. reporting can also accessed get_informant_report() function, reporting options.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/create_informant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a pointblank informant object ‚Äî create_informant","text":"","code":"create_informant(   tbl = NULL,   read_fn = NULL,   agent = NULL,   tbl_name = NULL,   label = NULL,   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/reference/create_informant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a pointblank informant object ‚Äî create_informant","text":"tbl input table. can data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, function can used read input data table read_fn argument (case, tbl can NULL). read_fn function used reading data. Even tbl provided, function invoked obtain data (.e., read_fn takes priority). two ways specify read_fn: (1) using function (e.g., function() { <table reading code> }) , (2) R formula expression. agent pointblank agent object. object can used instead supplying table tbl table-prep formula read_fn. tbl_name optional name assign input table object. value provided, name generated based whatever information available. label optional label information report. value provided, label generated based current system time. Markdown can used make label visually appealing (appear header area information report). lang language use information report (summary table provides available information table. default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). locale optional locale ID use formatting values information report according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/create_informant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a pointblank informant object ‚Äî create_informant","text":"ptblank_informant object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/create_informant.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Create a pointblank informant object ‚Äî create_informant","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). example complex call create_informant() expressed R code corresponding YAML representation. generated YAML includes top-level keys type read_fn mandatory, , two metadata sections: table columns. Keys begin underscore character updated whenever incorporate() called informant. table metadata section can multiple subsections info text. columns metadata section can similarly multiple subsections, long children column keys (YAML example, date_time date column keys match table's column names). Additional sections can added must key names top level duplicate default set (.e., type, table, columns, etc. treated reserved keys).","code":"# R statement create_informant(   read_fn = ~ small_table,   tbl_name = \"small_table\",   label = \"An example.\",   lang = \"fr\",    locale = \"fr_CA\" )  # YAML representation type: informant read_fn: ~small_table tbl_name: small_table info_label: An example. lang: fr locale: fr_CA table:   name: small_table   _columns: 8   _rows: 13.0   _type: tbl_df columns:   date_time:     _type: POSIXct, POSIXt   date:     _type: Date   a:     _type: integer   b:     _type: character   c:     _type: numeric   d:     _type: numeric   e:     _type: logical   f:     _type: character"},{"path":"https://rich-iannone.github.io/pointblank/reference/create_informant.html","id":"writing-an-informant-to-disk","dir":"Reference","previous_headings":"","what":"Writing an Informant to Disk","title":"Create a pointblank informant object ‚Äî create_informant","text":"informant object can written disk x_write_disk() function. Informants stored serialized RDS format can easily retrieved x_read_disk() function. recommended table-prep formulas supplied read_fn argument create_informant(). way, informant read disk x_read_disk(), can reused access target table (may changed, hence need use expression ).","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/create_informant.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Create a pointblank informant object ‚Äî create_informant","text":"1-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/create_informant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a pointblank informant object ‚Äî create_informant","text":"","code":"# Let's walk through how we can # generate some useful information for a # really small table; it's actually # called `small_table` and we can find # it as a dataset in this package small_table #> # A tibble: 13 √ó 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # Create a pointblank `informant` # object with `create_informant()` # and the `small_table` dataset informant <-    create_informant(     read_fn = ~small_table,     tbl_name = \"small_table\",     label = \"An example.\"   )  # This function creates some information # without any extra help by profiling # the supplied table object; it adds # the sections: (1) 'table' and # (2) 'columns' and we can print the # object to see the information report  # Alternatively, we can get the same report # by using `get_informant_report()` report <- get_informant_report(informant) class(report) #> [1] \"ptblank_informant_report\" \"gt_tbl\"                   #> [3] \"list\""},{"path":"https://rich-iannone.github.io/pointblank/reference/create_multiagent.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a pointblank multiagent object ‚Äî create_multiagent","title":"Create a pointblank multiagent object ‚Äî create_multiagent","text":"Multiple agents can part single object called multiagent. can useful gathering multiple agents performed interrogations past (perhaps saved disk x_write_disk()). part multiagent, can get report shows data quality evolved time. can interest important monitor data quality even evolution validation plan . reporting table, generated printing ptblank_multiagent object using get_multiagent_report() function, , default, organized interrogation time automatically recognizes validation steps equivalent across interrogations.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/create_multiagent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a pointblank multiagent object ‚Äî create_multiagent","text":"","code":"create_multiagent(..., lang = NULL, locale = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/create_multiagent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a pointblank multiagent object ‚Äî create_multiagent","text":"... One pointblank agent objects. lang language use reporting generated multiagent. (e.g., individual agent reports, multiagent reports, etc.). default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). locale optional locale ID use formatting values reporting outputs according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/create_multiagent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a pointblank multiagent object ‚Äî create_multiagent","text":"ptblank_multiagent object.","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/create_multiagent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Create a pointblank multiagent object ‚Äî create_multiagent","text":"10-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/create_multiagent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a pointblank multiagent object ‚Äî create_multiagent","text":"","code":"if (interactive()) {  # Let's walk through several theoretical # data quality analyses of an extremely # small table; that table is called # `small_table` and we can find it as a # dataset in this package small_table  # To set failure limits and signal # conditions, we designate proportional # failure thresholds to the `warn`, `stop`, # and `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.05,     stop_at = 0.10,     notify_at = 0.20   )  # We will create four different agents # and have slightly different validation # steps in each of them; in the first, # `agent_1`, eight different validation # steps are created and the agent will # interrogate the `small_table` agent_1 <-   create_agent(     read_fn = ~ small_table,     label = \"An example.\",     actions = al   ) %>%   col_vals_gt(     vars(date_time),     value = vars(date),     na_pass = TRUE   ) %>%   col_vals_gt(     vars(b),      value = vars(g),     na_pass = TRUE   ) %>%   rows_distinct() %>%   col_vals_equal(     vars(d),      value = vars(d),     na_pass = TRUE   ) %>%   col_vals_between(     vars(c),      left = vars(a), right = vars(d)   ) %>%   col_vals_not_between(     vars(c),     left = 10, right = 20,     na_pass = TRUE   ) %>%   rows_distinct(vars(d, e, f)) %>%   col_is_integer(vars(a)) %>%   interrogate()  # The second agent, `agent_2`, retains # all of the steps of `agent_1` and adds # two more (the last of which is inactive) agent_2 <-    agent_1 %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),      regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     active = FALSE   ) %>%   interrogate()  # The third agent, `agent_3`, adds a single # validation step, removes the fifth one, # and deactivates the first agent_3 <-    agent_2 %>%   col_vals_in_set(     vars(f),     set = c(\"low\", \"mid\", \"high\")   ) %>%   remove_steps(i = 5) %>%   deactivate_steps(i = 1) %>%   interrogate()  # The fourth and final agent, `agent_4`, # reactivates steps 1 and 10, and removes # the sixth step agent_4 <-   agent_3 %>%   activate_steps(i = 1) %>%   activate_steps(i = 10) %>%   remove_steps(i = 6) %>%   interrogate()  # While all the agents are slightly # different from each other, we can still # get a combined report of them by # creating a 'multiagent' multiagent <-   create_multiagent(     agent_1, agent_2, agent_3, agent_4   )  # Calling `multiagent` in the console # prints the multiagent report; but we # can get a `gt_tbl` object with the # `get_multiagent_report(agent)` function report <- get_multiagent_report(multiagent)  class(report)  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/db_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a table from a database ‚Äî db_tbl","title":"Get a table from a database ‚Äî db_tbl","text":"target table database, db_tbl() function handy way accessing . function simplifies process getting tbl_dbi object, usually involves combination building connection database using dplyr::tbl() function connection table name (reference table schema). can use db_tbl() basis obtaining database table read_fn parameter create_agent() create_informant(). can done using leading ~ db_tbl() call (e.g,. read_fn = ~db_tbl(...)). Another great option supplying table-prep formula involving db_tbl() tbl_store() access database tables though single names via table store. username password supplied though environment variables. desired, can supplied directly enclosing values ().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/db_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a table from a database ‚Äî db_tbl","text":"","code":"db_tbl(   table,   dbname,   dbtype,   host = NULL,   port = NULL,   user = NULL,   password = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/reference/db_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a table from a database ‚Äî db_tbl","text":"table name table, , reference table schema (two-element vector names schema table). Alternatively, can supplied data table copy -memory database connection. works : (1) db either \"sqlite\" \"duckdb\", (2) dbname chosen \":memory:\", (3) data_tbl data frame tibble object. dbname database name. dbtype Either appropriate driver function (e.g., RPostgres::Postgres()) shortname database type. Valid names : \"postgresql\", \"postgres\", \"pgsql\" (PostgreSQL, using RPostgres::Postgres() driver function); \"mysql\" (MySQL, using RMySQL::MySQL()); \"duckdb\" (DuckDB, using duckdb::duckdb()); \"sqlite\" (SQLite, using RSQLite::SQLite()). host, port database host optional port number. user, password environment variables used access username password database.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/db_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a table from a database ‚Äî db_tbl","text":"tbl_dbi object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/db_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get a table from a database ‚Äî db_tbl","text":"1-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/db_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a table from a database ‚Äî db_tbl","text":"","code":"# You can use an in-memory database # table and supply an in-memory table # to it too: small_table_duckdb <-    db_tbl(     table = small_table,     dbname = \":memory:\",     dbtype = \"duckdb\"   )  if (interactive()) {  # It's also possible to obtain a remote # file and shove it into an in-memory # database; use the all-powerful # `file_tbl()` + `db_tbl()` combo all_revenue_large_duckdb <-   db_tbl(     table = file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"       )     ),     dbname = \":memory:\",     dbtype = \"duckdb\"   )  # For remote databases, it's much the # same; here's an example that accesses # the `rna` table (in the RNA Central # public database) using `db_tbl()` rna_db_tbl <-    db_tbl(     table = \"rna\",     dbname = \"pfmegrnargs\",     dbtype = \"postgres\",      host = \"hh-pgsql-public.ebi.ac.uk\",     port = 5432,     user = I(\"reader\"),     password = I(\"NWDMCE5xdipIjRrp\")   )  # Using `I()` for the user name and # password means that you're passing in # the actual values but, normally, you # would want use the names of environment # variables (envvars) to securely access # the appropriate username and password # values when connecting to a DB: example_db_tbl <-    db_tbl(     table = \"<table_name>\",     dbname = \"<database_name>\",     dbtype = \"<database_type_shortname>\",      host = \"<connection_url>\",     port = \"<connection_port>\",     user = \"<DB_USER_NAME>\",     password = \"<DB_PASSWORD>\"   )  # Environment variables can be created # by editing the user `.Renviron` file and # the `usethis::edit_r_environ()` function # makes this pretty easy to do  # Storing table-prep formulas in a table # store makes it easier to work with DB # tables in pointblank; here's how to # generate a table store with two named # entries for table preparations tbls <-   tbl_store(     small_table_duck ~ db_tbl(       table = pointblank::small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     small_high_duck ~ db_tbl(       table = pointblank::small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ) %>%       dplyr::filter(f == \"high\")   )  # Now it's easy to access either of these # tables (the second is a mutated version) # via the `tbl_get()` function tbl_get(\"small_table_duck\", store = tbls) tbl_get(\"small_high_duck\", store = tbls)  # The table-prep formulas in `tbls` # could also be used in functions with # the `read_fn` argument; this is thanks # to the `tbl_source()` function agent <-    create_agent(     read_fn = ~ tbl_source(       \"small_table_duck\",       store = tbls     )   )  informant <-    create_informant(     read_fn = ~ tbl_source(       \"small_high_duck\",       store = tbls     )   )  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/deactivate_steps.html","id":null,"dir":"Reference","previous_headings":"","what":"Deactivate one or more of an agent's validation steps ‚Äî deactivate_steps","title":"Deactivate one or more of an agent's validation steps ‚Äî deactivate_steps","text":"deactivation one validation steps necessary creation validation plan agent, deactivate_steps() function helpful . effect using active = FALSE option (active argument validation functions) selected validation steps. Please note directly edits validation step, wiping function may defined whether step active .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/deactivate_steps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deactivate one or more of an agent's validation steps ‚Äî deactivate_steps","text":"","code":"deactivate_steps(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/deactivate_steps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deactivate one or more of an agent's validation steps ‚Äî deactivate_steps","text":"agent agent object class ptblank_agent. validation step number, assigned validation step order definition.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/deactivate_steps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deactivate one or more of an agent's validation steps ‚Äî deactivate_steps","text":"ptblank_agent object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/deactivate_steps.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Deactivate one or more of an agent's validation steps ‚Äî deactivate_steps","text":"9-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/deactivate_steps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deactivate one or more of an agent's validation steps ‚Äî deactivate_steps","text":"","code":"# Create an agent that has the # `small_table` object as the # target table, add a few # validation steps, and then use # `interrogate()` agent_1 <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%   col_exists(vars(date)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]\"   ) %>%   interrogate()    # The second validation step has # is being reconsidered and may # be either phased out or improved # upon; in the interim period it # was decided that the step should # be deactivated for now agent_2 <-   agent_1 %>%   deactivate_steps(i = 2) %>%   interrogate() #> ‚Ñπ Step 2 is not set as active. Skipping."},{"path":"https://rich-iannone.github.io/pointblank/reference/draft_validation.html","id":null,"dir":"Reference","previous_headings":"","what":"Draft a starter pointblank validation .R/.Rmd file with a data table ‚Äî draft_validation","title":"Draft a starter pointblank validation .R/.Rmd file with a data table ‚Äî draft_validation","text":"Generate draft validation plan new .R .Rmd file using input data table. Using workflow, data table scanned learn column data set starter validation steps (constituting validation plan) written. best use data extract contains least 1000 rows relatively free spurious data. file, possible tweak validation steps better fit expectations particular domain. column inference used generate reasonable validation plans, difficult infer acceptable values without domain expertise. However, using draft_validation() get started floor 10 tackling data quality issues case better starting empty code editor view.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/draft_validation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draft a starter pointblank validation .R/.Rmd file with a data table ‚Äî draft_validation","text":"","code":"draft_validation(   tbl,   tbl_name = NULL,   file_name = tbl_name,   path = NULL,   lang = NULL,   output_type = c(\"R\", \"Rmd\"),   add_comments = TRUE,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/reference/draft_validation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draft a starter pointblank validation .R/.Rmd file with a data table ‚Äî draft_validation","text":"tbl input table. can data frame, tibble, tbl_dbi object, tbl_spark object. tbl_name optional name assign input table object. value provided, name generated based whatever information available. table name displayed header area agent report generated printing agent calling get_agent_report(). file_name optional name .R .Rmd file. name without extension. default, taken tbl_name nothing supplied , name contain text \"draft_validation_\" followed current date time. path path can specified attempt place generated file working directory. lang language use creating comments automatically- generated validation steps. default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). output_type option choosing type output generated. default, .R script (\"R\") alternatively R Markdown document (\"Rmd\"). add_comments comments explain features validation plan generated document? default, TRUE. overwrite file name overwritten? default, FALSE. quiet function inform file written? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/draft_validation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draft a starter pointblank validation .R/.Rmd file with a data table ‚Äî draft_validation","text":"Invisibly returns TRUE file written.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/draft_validation.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Draft a starter pointblank validation .R/.Rmd file with a data table ‚Äî draft_validation","text":"1-11","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/draft_validation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draft a starter pointblank validation .R/.Rmd file with a data table ‚Äî draft_validation","text":"","code":"if (interactive()) {  # Draft validation plan for the # `dplyr::storms` dataset draft_validation(tbl = dplyr::storms)  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/email_blast.html","id":null,"dir":"Reference","previous_headings":"","what":"Send email at a validation step or at the end of an interrogation ‚Äî email_blast","title":"Send email at a validation step or at the end of an interrogation ‚Äî email_blast","text":"email_blast() function useful sending email message explains result pointblank validation. powered blastula glue packages. function invoked part end_fns argument create_agent(). also possible invoke email_blast() part fns argument action_levels() function (.e., send multiple email messages granularity different validation steps exceeding failure thresholds). better get handle emailing email_blast(), analogous email_create() function can used pointblank agent object x-list obtained using get_agent_x_list() function.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/email_blast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Send email at a validation step or at the end of an interrogation ‚Äî email_blast","text":"","code":"email_blast(   x,   to,   from,   credentials = NULL,   msg_subject = NULL,   msg_header = NULL,   msg_body = stock_msg_body(),   msg_footer = stock_msg_footer(),   send_condition = ~TRUE %in% x$notify )"},{"path":"https://rich-iannone.github.io/pointblank/reference/email_blast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Send email at a validation step or at the end of an interrogation ‚Äî email_blast","text":"x reference x-list object prepared internally agent. version x-list generated via get_agent_x_list(<agent>) except version internally generated hence available internal evaluation context. , email addresses recipients sender. credentials credentials list object produced either blastula::creds(), blastula::creds_anonymous(), blastula::creds_key(), blastula::creds_file() functions. Please refer blastula documentation information use functions. msg_subject subject line email message. msg_header, msg_body, msg_footer Content header, body, footer components HTML email message. send_condition expression evaluate logical vector length 1. evaluated TRUE email sent, FALSE happen. expression can use x-list variables (e.g., x$notify, x$type, etc.) variables can explored using get_agent_x_list() function. default expression ~TRUE %% x$notify, results TRUE TRUE values x$notify logical vector (.e., validation step results 'notify' condition).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/email_blast.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Send email at a validation step or at the end of an interrogation ‚Äî email_blast","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). example use email_blast() inside end_fns argument create_agent() expressed R code corresponding YAML representation.","code":"# R statement create_agent(   read_fn = ~ small_table,   tbl_name = \"small_table\",   label = \"An example.\",   actions = al,   end_fns = list(     ~ email_blast(       x,       to = \"joe_public@example.com\",       from = \"pb_notif@example.com\",       msg_subject = \"Table Validation\",       credentials = blastula::creds_key(         id = \"smtp2go\"       ),     )   ) ) %>%   col_vals_gt(vars(a), 1) %>%   col_vals_lt(vars(a), 7)   # YAML representation type: agent read_fn: ~small_table tbl_name: small_table label: An example. lang: en locale: en actions:   warn_count: 1.0   notify_count: 2.0 end_fns: ~email_blast(x, to = \"joe_public@example.com\",    from = \"pb_notif@example.com\", msg_subject = \"Table Validation\",   credentials = blastula::creds_key(id = \"smtp2go\"),   ) embed_report: true steps:   - col_vals_gt:     columns: vars(a)     value: 1.0   - col_vals_lt:     columns: vars(a)     value: 7.0"},{"path":"https://rich-iannone.github.io/pointblank/reference/email_blast.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Send email at a validation step or at the end of an interrogation ‚Äî email_blast","text":"4-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/email_blast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Send email at a validation step or at the end of an interrogation ‚Äî email_blast","text":"","code":"# Create an `action_levels()` list # with absolute values for the # `warn`, and `notify` states (with # thresholds of 1 and 2 'fail' units) al <-    action_levels(     warn_at = 1,     notify_at = 2   )    if (interactive()) {  # Validate that values in column # `a` from `small_tbl` are always > 1 # and that they are always < 7; first, # apply the `actions_levels()` # directive to `actions` and set up # an `email_blast()` as one of the # `end_fns` (by default, the email # will be sent if there is a single # 'notify' state across all # validation steps) agent <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al,     end_fns = list(       ~ email_blast(         x,         to = \"joe_public@example.com\",         from = \"pb_notif@example.com\",         msg_subject = \"Table Validation\",         credentials = blastula::creds_key(           id = \"smtp2go\"         ),       )     )   ) %>%   col_vals_gt(vars(a), value = 1) %>%   col_vals_lt(vars(a), value = 7) %>%   interrogate()  }  # The above example was intentionally # not run because email credentials # aren't available and the `to` # and `from` email addresses are # nonexistent  # To get a blastula email object # instead of eagerly sending the # message, we can use the  # `email_create()` function email_object <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al   ) %>%   col_vals_gt(vars(a), value = 5) %>%   col_vals_lt(vars(a), value = 7) %>%   interrogate() %>%   email_create()"},{"path":"https://rich-iannone.github.io/pointblank/reference/email_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an email object from a pointblank agent or informant ‚Äî email_create","title":"Create an email object from a pointblank agent or informant ‚Äî email_create","text":"email_create() function produces email message object sent using blastula package. x need either pointblank agent, agent x-list (produced agent get_agent_x_list() function), pointblank informant. cases, email message appear Viewer blastula email_message object returned.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/email_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an email object from a pointblank agent or informant ‚Äî email_create","text":"","code":"email_create(   x,   msg_header = NULL,   msg_body = stock_msg_body(),   msg_footer = stock_msg_footer() )"},{"path":"https://rich-iannone.github.io/pointblank/reference/email_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an email object from a pointblank agent or informant ‚Äî email_create","text":"x pointblank agent, agent x-list, pointblank informant. x-list object can created get_agent_x_list() function. recommended option = NULL used get_agent_x_list() supplying x-list x. Furthermore, option generate_report = TRUE used create_agent() agent report available within email. msg_header, msg_body, msg_footer Content header, body, footer components HTML email message.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/email_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an email object from a pointblank agent or informant ‚Äî email_create","text":"blastulaemail_message object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/email_create.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Create an email object from a pointblank agent or informant ‚Äî email_create","text":"4-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/email_create.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an email object from a pointblank agent or informant ‚Äî email_create","text":"","code":"if (interactive()) {  # Create an `action_levels()` list # with absolute values for the # `warn`, and `notify` states (with # thresholds of 1 and 2 'fail' units) al <-    action_levels(     warn_at = 1,     notify_at = 2   )  # In a workflow that involves an # `agent` object, we can make use of # the `end_fns` argument and # programmatically email the report # with the `email_blast()` function, # however, an alternate workflow is to # produce the email object and choose # to send outside of the pointblank API; # the `email_create()` function lets # us do this with an `agent` object email_object_1 <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al   ) %>%   col_vals_gt(vars(a), value = 1) %>%   col_vals_lt(vars(a), value = 7) %>%   interrogate() %>%   email_create()  # We can view the HTML email just # by printing `email_object`; it # should appear in the Viewer  # The `email_create()` function can # also be used on an agent x-list to # get the same email message object email_object_2 <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al   ) %>%   col_vals_gt(vars(a), value = 5) %>%   col_vals_lt(vars(b), value = 5) %>%   interrogate() %>%   get_agent_x_list() %>%   email_create()  # An information report that's # produced by the informant can # made into an email message object; # let's create an informant and use # `email_create()` email_object_3 <-   create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%   info_tabular(     info = \"A simple table in the     *Examples* section of the function     called `email_create()`.\"   ) %>%   info_columns(     columns = vars(a),     info = \"Numbers. On the high side.\"   ) %>%   info_columns(     columns = vars(b),     info = \"Lower numbers. Zeroes, even.\"   ) %>%   incorporate() %>%   email_create()  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/export_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Export an agent, informant, multiagent, or table scan to HTML ‚Äî export_report","title":"Export an agent, informant, multiagent, or table scan to HTML ‚Äî export_report","text":"agent, informant, multiagent, table scan object can easily written HTML export_report(). Furthermore, report objects agent, informant, multiagent (generated using get_agent_report(), get_informant_report(), get_multiagent_report()) can provided HTML export. HTML document written disk self-contained easily viewable web browser.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/export_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export an agent, informant, multiagent, or table scan to HTML ‚Äî export_report","text":"","code":"export_report(x, filename, path = NULL, quiet = FALSE)"},{"path":"https://rich-iannone.github.io/pointblank/reference/export_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export an agent, informant, multiagent, or table scan to HTML ‚Äî export_report","text":"x agent object class ptblank_agent, informant class ptblank_informant, multiagent class ptblank_multiagent, table scan class ptblank_tbl_scan, , customized reporting objects (ptblank_agent_report, ptblank_informant_report, ptblank_multiagent_report.wide, ptblank_multiagent_report.long). filename filename create disk HTML export object provided. recommended extension \".html\" included. path optional path file saved (automatically combined filename). quiet function inform file written? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/export_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export an agent, informant, multiagent, or table scan to HTML ‚Äî export_report","text":"Invisibly returns TRUE file written.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/export_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Export an agent, informant, multiagent, or table scan to HTML ‚Äî export_report","text":"9-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/export_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export an agent, informant, multiagent, or table scan to HTML ‚Äî export_report","text":"","code":"if (interactive()) {  # A: Writing an agent report as HTML   # Let's go through the process of (1) # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # (2) interrogating the agent with the # `interrogate()` function, and (3) writing # the agent and all its intel to a file  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`export_report()`\",     actions = al   )  # Then, as with any agent object, we # can add steps to the validation plan by # using as many validation functions as we # want; then, we `interrogate()` agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5) %>%   interrogate()  # The agent report can be written to an # HTML file with `export_report()` export_report(   agent,   filename = \"agent-small_table.html\" )  # If you're consistently writing agent # reports when periodically checking data, # we could make use of `affix_date()` or # `affix_datetime()` depending on the # granularity you need; here's an example # that writes the file with the format: # 'agent-small_table-YYYY-mm-dd_HH-MM-SS.html' export_report(   agent,   filename = affix_datetime(     \"agent-small_table.html\"   ) )  # B: Writing an informant report as HTML  # Let's go through the process of (1) # creating an informant object that # minimally describes the `small_table` # dataset, (2) ensuring that data is # captured from the target table using # the `incorporate()` function, and (3) # writing the informant report to HTML  # Create a pointblank `informant` # object with `create_informant()` # and the `small_table` dataset; # `incorporate()` so that info snippets # are integrated into the text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`export_report()`\"   ) %>%   info_snippet(     snippet_name = \"high_a\",     fn = snip_highest(column = \"a\")   ) %>%   info_snippet(     snippet_name = \"low_a\",     fn = snip_lowest(column = \"a\")   ) %>%   info_columns(     columns = vars(a),     info = \"From {low_a} to {high_a}.\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values.\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`.\"   ) %>%   incorporate()  # The informant report can be written # to an HTML file with `export_report()`; # let's do this with `affix_date()` so # the filename has a datestamp export_report(   informant,   filename = affix_date(     \"informant-small_table.html\"   ) )  # C: Writing a table scan as HTML  # We can get an report that describes all # of the data in the `storms` dataset tbl_scan <- scan_data(tbl = dplyr::storms)  # The table scan object can be written # to an HTML file with `export_report()` export_report(   tbl_scan,   filename = \"tbl_scan-storms.html\" )  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/file_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a table from a local or remote file ‚Äî file_tbl","title":"Get a table from a local or remote file ‚Äî file_tbl","text":"target table file, stored either locally remotely, file_tbl() function can make possible access single function call. Compatible file types function : CSV (.csv), TSV (.tsv), RDA (.rda), RDS (.rds) files. function generates -memory tbl_dbl object, can used target table create_agent() create_informant(). ideal option data access file_tbl() using function read_fn parameter either aforementioned create_*() functions. can done using leading ~ (e.g,. read_fn = ~file_tbl(...)). remote data use case, can specify URL starting http://, https://, etc., ending file containing data table. data files available GitHub repository can use from_github() function specify name location table data repository.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/file_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a table from a local or remote file ‚Äî file_tbl","text":"","code":"file_tbl(file, type = NULL, ..., keep = FALSE, verify = TRUE)"},{"path":"https://rich-iannone.github.io/pointblank/reference/file_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a table from a local or remote file ‚Äî file_tbl","text":"file complete file path leading compatible data table either user system http://, https://, ftp://, ftps:// URL. file hosted GitHub repository, call from_github() function can used . type file type. normally inferred file extension default NULL indicate extension dictate type file reading performed internally. However, extension (valid extensions .csv, .tsv, .rda, .rds), can provide type either csv, tsv, rda, rds. ... Options passed readr's read_csv() read_tsv() function. functions arguments one used internally based file extension explicit value given type. keep case downloaded file, stored working directory (keep = TRUE) downloaded temporary directory? default, FALSE. verify TRUE (default) verification data object data.frame class carried .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/file_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a table from a local or remote file ‚Äî file_tbl","text":"tbl_df object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/file_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get a table from a local or remote file ‚Äî file_tbl","text":"1-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/file_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a table from a local or remote file ‚Äî file_tbl","text":"","code":"# A local CSV file can be obtained as # a tbl object by supplying a path to # the file and some CSV reading options # (the ones used by `readr::read_csv()`) # to the `file_tbl()` function; for # this example we could obtain a path # to a CSV file in the pointblank # package with `system.file()`: csv_path <-    system.file(     \"data_files\", \"small_table.csv\",     package = \"pointblank\"   )  # Then use that path in `file_tbl()` # with the option to specify the column # types in that CSV   tbl <-    file_tbl(     file = csv_path,     col_types = \"TDdcddlc\"   )    # Now that we have a `tbl` object that # is a tibble, it can be introduced to # `create_agent()` for validation agent <- create_agent(tbl = tbl)  # A different strategy is to provide # the data-reading function call # directly to `create_agent()`: agent <-    create_agent(     read_fn = ~ file_tbl(       file = system.file(         \"data_files\", \"small_table.csv\",         package = \"pointblank\"       ),       col_types = \"TDdcddlc\"     )   ) %>%   col_vals_gt(vars(a), value = 0)  # All of the file-reading instructions # are encapsulated in the `read_fn` so # the agent will always obtain the most # recent version of the dataset (and the # logic can be translated to YAML, for # later use)  if (interactive()) {  # A CSV can be obtained from a public # GitHub repo by using the `from_github()` # helper function; let's create an agent # a supply a table-prep formula that # gets the same CSV file from the GitHub # repository for the pointblank package  agent <-    create_agent(     read_fn = ~ file_tbl(       file = from_github(         file = \"inst/data_files/small_table.csv\",         repo = \"rich-iannone/pointblank\"       ),       col_types = \"TDdcddlc\"     )   ) %>%   col_vals_gt(vars(a), value = 0) %>%   interrogate()  # This interrogated the data that was # obtained from the remote source file, # and, there's nothing to clean up (by # default, the downloaded file goes into # a system temp directory)  # Storing table-prep formulas in a table # store makes it easier to work with # tabular data originating from files; # here's how to generate a table store # with two named entries for table # preparations tbls <-   tbl_store(     small_table_file ~ file_tbl(       file = system.file(         \"data_files\", \"small_table.csv\",         package = \"pointblank\"       ),       col_types = \"TDdcddlc\"     ),     small_high_file ~ file_tbl(       file = system.file(         \"data_files\", \"small_table.csv\",         package = \"pointblank\"       ),       col_types = \"TDdcddlc\"     ) %>%       dplyr::filter(f == \"high\")   )  # Now it's easy to access either of these # tables (the second is a mutated version) # via the `tbl_get()` function tbl_get(\"small_table_file\", store = tbls) tbl_get(\"small_high_file\", store = tbls)  # The table-prep formulas in `tbls` # could also be used in functions with # the `read_fn` argument; this is thanks # to the `tbl_source()` function agent <-    create_agent(     read_fn = ~ tbl_source(       \"small_table_file\",       store = tbls     )   )  informant <-    create_informant(     read_fn = ~ tbl_source(       \"small_high_file\",       store = tbls     )   )  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/from_github.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify a file for download from GitHub ‚Äî from_github","title":"Specify a file for download from GitHub ‚Äî from_github","text":"from_github() function helpful generating valid URL points data file public GitHub repository. function can used file argument file_tbl() function anywhere else GitHub URLs raw user content needed.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/from_github.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify a file for download from GitHub ‚Äî from_github","text":"","code":"from_github(file, repo, subdir = NULL, default_branch = \"main\")"},{"path":"https://rich-iannone.github.io/pointblank/reference/from_github.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify a file for download from GitHub ‚Äî from_github","text":"file name file target GitHub repository. can path leading including file. combined path given subdir. repo GitHub repository address format username/repo[/subdir][@ref|#pull|@*release]. subdir path string representing subdirectory GitHub repository. combined path components included file. default_branch name default branch repo. usually \"main\" (default used ).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/from_github.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify a file for download from GitHub ‚Äî from_github","text":"character vector length 1 contains URL.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/from_github.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Specify a file for download from GitHub ‚Äî from_github","text":"13-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/from_github.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify a file for download from GitHub ‚Äî from_github","text":"","code":"# A valid URL to a data file in GitHub can be # obtained from the HEAD of the default branch # from_github( #   file = \"inst/data_files/small_table.csv\", #   repo = \"rich-iannone/pointblank\" # )  # The path to the file location can be supplied # fully or partially to `subdir` # from_github( #   file = \"small_table.csv\", #   repo = \"rich-iannone/pointblank\", #   subdir = \"inst/data_files\" # )  # We can use the first call in combination with # `file_tbl()` and `create_agent()`; this # supplies a table-prep formula that gets # a CSV file from the GitHub repository for the # pointblank package  # agent <-  #   create_agent( #     read_fn = ~ file_tbl( #       file = from_github( #         file = \"inst/data_files/small_table.csv\", #         repo = \"rich-iannone/pointblank\" #       ), #       col_types = \"TDdcddlc\" #     ) #   ) %>% #   col_vals_gt(vars(a), 0) %>% #   interrogate()  # The `from_github()` helper function is # pretty powerful and can get at lots of # different files in a repository  # A data file from GitHub can be obtained from # a commit at release time # from_github( #   file = \"inst/extdata/small_table.csv\", #   repo = \"rich-iannone/pointblank@v0.2.1\" # )  # A file may also be obtained from a repo at the # point in time of a specific commit (partial or # full SHA-1 hash for the commit can be used) # from_github( #   file = \"data-raw/small_table.csv\", #   repo = \"rich-iannone/pointblank@e04a71\" # )  # A file may also be obtained from an # *open* pull request # from_github( #   file = \"data-raw/small_table.csv\", #   repo = \"rich-iannone/pointblank#248\" # )"},{"path":"https://rich-iannone.github.io/pointblank/reference/game_revenue.html","id":null,"dir":"Reference","previous_headings":"","what":"A table with game revenue data ‚Äî game_revenue","title":"A table with game revenue data ‚Äî game_revenue","text":"table subset sj_all_revenue table intendo data package. first 2,000 rows table revenue records range 2015-01-01 2015-01-21.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/game_revenue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A table with game revenue data ‚Äî game_revenue","text":"","code":"game_revenue"},{"path":"https://rich-iannone.github.io/pointblank/reference/game_revenue.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A table with game revenue data ‚Äî game_revenue","text":"tibble 2,000 rows 11 variables: player_id character column unique identifiers user/player. session_id character column contains unique identifiers player session. session_start date-time column indicates session (containing revenue event) started. time date-time column indicates exactly player purchase (revenue event) occurred. item_type character column provides class item purchased. item_name character column provides name item purchased. item_revenue numeric column revenue amounts per item purchased. session_duration numeric column states length session (minutes) purchase occurred. start_day Date column provides date first login player making purchase. acquisition character column provides method acquisition player. country character column provides probable country residence player.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/game_revenue.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A table with game revenue data ‚Äî game_revenue","text":"14-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/game_revenue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A table with game revenue data ‚Äî game_revenue","text":"","code":"# Here is a glimpse at the data # available in `game_revenue` dplyr::glimpse(game_revenue) #> Rows: 2,000 #> Columns: 11 #> $ player_id        <chr> \"ECPANOIXLZHF896\", \"ECPANOIXLZHF896\", \"ECPANOIXLZHF89‚Ä¶ #> $ session_id       <chr> \"ECPANOIXLZHF896-eol2j8bs\", \"ECPANOIXLZHF896-eol2j8bs‚Ä¶ #> $ session_start    <dttm> 2015-01-01 01:31:03, 2015-01-01 01:31:03, 2015-01-01‚Ä¶ #> $ time             <dttm> 2015-01-01 01:31:27, 2015-01-01 01:36:57, 2015-01-01‚Ä¶ #> $ item_type        <chr> \"iap\", \"iap\", \"iap\", \"ad\", \"ad\", \"ad\", \"ad\", \"ad\", \"a‚Ä¶ #> $ item_name        <chr> \"offer2\", \"gems3\", \"gold7\", \"ad_20sec\", \"ad_5sec\", \"a‚Ä¶ #> $ item_revenue     <dbl> 8.991, 22.491, 107.991, 0.760, 0.030, 0.070, 0.080, 1‚Ä¶ #> $ session_duration <dbl> 16.3, 16.3, 16.3, 16.3, 35.2, 35.2, 35.2, 35.2, 35.2,‚Ä¶ #> $ start_day        <date> 2015-01-01, 2015-01-01, 2015-01-01, 2015-01-01, 2015‚Ä¶ #> $ acquisition      <chr> \"google\", \"google\", \"google\", \"google\", \"google\", \"go‚Ä¶ #> $ country          <chr> \"Germany\", \"Germany\", \"Germany\", \"Germany\", \"Germany\"‚Ä¶"},{"path":"https://rich-iannone.github.io/pointblank/reference/game_revenue_info.html","id":null,"dir":"Reference","previous_headings":"","what":"A table with metadata for the game_revenue dataset ‚Äî game_revenue_info","title":"A table with metadata for the game_revenue dataset ‚Äî game_revenue_info","text":"table contains metadata game_revenue table. first column (named column) provides column names game_revenue. second column (info) contains descriptions columns dataset. table correct format use info_columns_from_tbl() function.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/game_revenue_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A table with metadata for the game_revenue dataset ‚Äî game_revenue_info","text":"","code":"game_revenue_info"},{"path":"https://rich-iannone.github.io/pointblank/reference/game_revenue_info.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A table with metadata for the game_revenue dataset ‚Äî game_revenue_info","text":"tibble 11 rows 2 variables: column character column unique identifiers user/player. info character column contains unique identifiers player session.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/game_revenue_info.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A table with metadata for the game_revenue dataset ‚Äî game_revenue_info","text":"14-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/game_revenue_info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A table with metadata for the game_revenue dataset ‚Äî game_revenue_info","text":"","code":"# Here is a glimpse at the data # available in `game_revenue_info` dplyr::glimpse(game_revenue_info) #> Rows: 11 #> Columns: 2 #> $ column <chr> \"player_id\", \"session_id\", \"session_start\", \"time\", \"item_type\"‚Ä¶ #> $ info   <chr> \"A `character` column with unique identifiers for each user/pla‚Ä¶"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_agent_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a summary report from an agent ‚Äî get_agent_report","title":"Get a summary report from an agent ‚Äî get_agent_report","text":"can get informative summary table agent using get_agent_report() function. table can provided two substantially different forms: gt based display table (default), , tibble. amount fields intel different depending whether agent performed interrogation (interrogate() function). Basically, interrogate() called, agent contain just validation plan (however many rows depends many validation functions supplied part plan). Post-interrogation, information passing failing test units provided, along indicators whether certain failure states entered (provided set actions). display table variant agent report, default form, following columns: (unlabeled): validation step number STEP: name validation function used validation step COLUMNS: names target columns used validation step (applicable) VALUES: values used validation step, applicable; literal values, column names, expression, set sub-validations (conjointly() validation step), etc. TBL: indicates whether preconditions apply interrogation; , script '' stands 'identity' , , right-facing arrow appears EVAL: character value denotes result validation step functions' evaluation interrogation N: total number test units validation step PASS: number test units received pass FAIL: fraction test units received pass W, S, N: indicators show whether warn, stop, notify states entered; unset states appear dashes, states set thresholds appear unfilled circles entered filled thresholds exceeded (colors W, S, N amber, red, blue) EXT: column provides buttons data extracts validation step failed rows available (CSV files) small version display table (obtained using size = \"small\") omits COLUMNS, TBL, EXT columns. width small table 575px; standard table 875px wide. choosing get tibble (display_table = FALSE), following columns: : validation step number type: name validation function used validation step columns: names target columns used validation step (applicable) values: values used validation step, applicable; conjointly() validation step, listing sub-validations precon: indicates whether preconditions apply interrogation , , number statements used active: logical value indicates whether validation step set \"active\" interrogation eval: character value denotes result validation step functions' evaluation interrogation units: total number test units validation step n_pass: number test units received pass f_pass: fraction test units received pass W, S, N: logical value stating whether warn, stop, notify states entered extract: logical value indicates whether data extract available validation step","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_agent_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a summary report from an agent ‚Äî get_agent_report","text":"","code":"get_agent_report(   agent,   arrange_by = c(\"i\", \"severity\"),   keep = c(\"all\", \"fail_states\"),   display_table = TRUE,   size = \"standard\",   title = \":default:\",   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_agent_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a summary report from an agent ‚Äî get_agent_report","text":"agent agent object class ptblank_agent. arrange_by choice arrange report table rows validation step number (\"\", default), , arrange descending order severity failure state (\"severity\"). keep option keep \"\" report's table rows (default), , keep rows reflect one \"fail_states\". display_table display table generated? TRUE (default), gt package installed, display table report shown Viewer. FALSE, gt available, tibble returned. size size display table, can either \"standard\" (default) \"small\". applies display table (display_table = TRUE). title Options customizing title report. default keyword \":default:\" produces generic title text refers pointblank package language governed lang option. Another keyword option \":tbl_name:\", presents name table title report. title wanted, \":none:\" keyword option can used. Aside keyword options, text can provided title glue::glue() calls can used construct text string. providing text, interpreted Markdown text transformed internally HTML. circumvent transformation, use text () explicitly state supplied text transformed. lang language use automatic creation briefs (short descriptions validation step) agent report (summary table provides validation plan results interrogation. default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). lang option override previously set language setting (e.g., create_agent() call). locale optional locale ID use formatting values agent report summary table according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). locale option override previously set locale value (e.g., create_agent() call).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_agent_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a summary report from an agent ‚Äî get_agent_report","text":"gt table object display_table = TRUE tibble display_table = FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_agent_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get a summary report from an agent ‚Äî get_agent_report","text":"6-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/get_agent_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a summary report from an agent ‚Äî get_agent_report","text":"","code":"# Create a simple table with a # column of numerical values tbl <-    dplyr::tibble(a = c(5, 7, 8, 5))  # Validate that values in column # `a` are always greater than 4 agent <-   create_agent(tbl = tbl) %>%   col_vals_gt(vars(a), value = 4) %>%   interrogate()  # Get a tibble-based report from the # agent by using `get_agent_report()` # with `display_table = FALSE` agent %>%   get_agent_report(display_table = FALSE) #> # A tibble: 1 √ó 14 #>       i type  columns values precon active eval  units n_pass f_pass W     S     #>   <int> <chr> <chr>   <chr>  <chr>  <lgl>  <chr> <dbl>  <dbl>  <dbl> <lgl> <lgl> #> 1     1 col_‚Ä¶ a       4      NA     TRUE   OK        4      4      1 NA    NA    #> # ‚Ä¶ with 2 more variables: N <lgl>, extract <int>    # View a the report by printing the # `agent` object anytime, but, return a # gt table object by using this with # `display_table = TRUE` (the default) report <- get_agent_report(agent) class(report) #> [1] \"ptblank_agent_report\" \"gt_tbl\"               \"list\"                  # What can you do with the report? # Print it from an R Markdown code, # use it in an email, put it in a # webpage, or further modify it with # the **gt** package  # The agent report as a **gt** display # table comes in two sizes: \"standard\" # (the default) and \"small\" small_report <-    get_agent_report(     agent = agent,     size = \"small\"   )  class(small_report) #> [1] \"ptblank_agent_report\" \"gt_tbl\"               \"list\"                  # The standard report is 875px wide # the small one is 575px wide"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_agent_x_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the agent's x-list ‚Äî get_agent_x_list","title":"Get the agent's x-list ‚Äî get_agent_x_list","text":"agent's x-list record information agent possesses given time. x-list contain complete information interrogation taken place (, data largely reflects validation plan). x-list can constrained particular validation step (supplying step number argument), , can get information validation steps leaving unspecified. x-list indeed R list object contains veritable cornucopia information. x-list obtained specified validation step, following components available: time_start: time interrogation began (POSIXct [0 1]) time_end: time interrogation ended (POSIXct [0 1]) label: optional label given agent (chr [1]) tbl_name: name table object, available (chr [1]) tbl_src: type table used validation (chr [1]) tbl_src_details: table database table, provides details DB table (chr [1]) tbl: table object col_names: table's column names (chr [ncol(tbl)]) col_types: table's column types (chr [ncol(tbl)]) : validation step index (int [1]) type: type validation, value validation function name (chr [1]) columns: columns specified validation function (chr [variable length]) values: values specified validation function (mixed types [variable length]) briefs: brief validation step specified lang (chr [1]) eval_error, eval_warning: indicates whether evaluation step function, interrogation, resulted error warning (lgl [1]) capture_stack: list captured errors warnings step-function evaluation interrogation time (list [1]) n: number test units validation step (num [1]) n_passed, n_failed: number passing failing test units validation step (num [1]) f_passed: fraction passing test units validation step, n_passed / n (num [1]) f_failed: fraction failing test units validation step, n_failed / n (num [1]) warn, stop, notify: logical value indicating whether level failing test units caused corresponding conditions entered (lgl [1]) lang: two-letter language code indicates language used briefs, agent report, reporting generated scan_data() function (chr [1]) unspecified (.e., constrained specific validation step) certain length-one components x-list expanded total number validation steps (: , type, columns, values, briefs, eval_error, eval_warning, capture_stack, n, n_passed, n_failed, f_passed, f_failed, warn, stop, notify). x-list also additional components NULL, : report_object: gt table object, also presented default print method ptblank_agent email_object: blastula email_message object default set components report_html: HTML source report_object, provided length-one character vector report_html_small: HTML source narrower, condensed version report_object, provided length-one character vector; HTML inlined styles, making suitable email message bodies","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_agent_x_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the agent's x-list ‚Äî get_agent_x_list","text":"","code":"get_agent_x_list(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_agent_x_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the agent's x-list ‚Äî get_agent_x_list","text":"agent agent object class ptblank_agent. validation step number, assigned validation step order invocation. NULL (default), x-list provide information validation steps. valid step number provided x-list information pertaining step.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_agent_x_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the agent's x-list ‚Äî get_agent_x_list","text":"list object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_agent_x_list.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get the agent's x-list ‚Äî get_agent_x_list","text":"8-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/get_agent_x_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the agent's x-list ‚Äî get_agent_x_list","text":"","code":"# Create a simple data frame with # a column of numerical values tbl <- dplyr::tibble(a = c(5, 7, 8, 5))  # Create an `action_levels()` list # with fractional values for the # `warn`, `stop`, and `notify` states al <-   action_levels(     warn_at = 0.2,     stop_at = 0.8,     notify_at = 0.345   )  # Create an agent (giving it the # `tbl` and the `al` objects), # supply two validation step # functions, then interrogate agent <-   create_agent(     tbl = tbl,     actions = al   ) %>%   col_vals_gt(vars(a), value = 7) %>%   col_is_numeric(vars(a)) %>%   interrogate()    # Get the agent x-list x <- get_agent_x_list(agent)  # Print the x-list object `x` x #> ‚îÄ‚îÄ The x-list for `tbl` ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ALL STEPS ‚îÄ‚îÄ #> $time_start $time_end (POSIXct [1]) #> $label $tbl_name $tbl_src $tbl_src_details (chr [1]) #> $tbl (tbl_df, tbl, and data.frame) #> $col_names $col_types (chr [1]) #> $i $type $columns $values $label $briefs (mixed [2]) #> $eval_error $eval_warning (lgl [2]) #> $capture_stack (list [2]) #> $n $n_passed $n_failed $f_passed $f_failed (num [2]) #> $warn $stop $notify (lgl [2]) #> $validation_set (tbl_df [2, 35]) #> $lang (chr [1]) #> $report_object (gt_tbl) #> $email_object (blastula_message) #> $report_html $report_html_small (chr [1]) #> ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # Get the `f_passed` component # of the x-list x$f_passed #> [1] 0.25 1.00"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_data_extracts.html","id":null,"dir":"Reference","previous_headings":"","what":"Collect data extracts from a validation step ‚Äî get_data_extracts","title":"Collect data extracts from a validation step ‚Äî get_data_extracts","text":"agent-based workflow (.e., initiating create_agent()), interrogation interrogate(), can extract row data pass row-based validation steps get_data_extracts() function. one discrete extract per row-based validation step amount data available particular extract depends fraction test units pass validation step level sampling explicit collection set units. extracts can collected programmatically get_data_extracts() may also downloaded CSV files HTML report generated agent's print method use get_agent_report(). availability data extracts row-based validation step depends whether extract_failed set TRUE within interrogate() call (default). amount fail rows extracted depends collection parameters interrogate(), default behavior collect first 5000 fail rows. Row-based validation steps based validation functions form col_vals_*() also include conjointly() rows_distinct(). functions combined set validation functions can yield data extracts.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_data_extracts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collect data extracts from a validation step ‚Äî get_data_extracts","text":"","code":"get_data_extracts(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_data_extracts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collect data extracts from a validation step ‚Äî get_data_extracts","text":"agent agent object class ptblank_agent. interrogate() called , validation steps carried sample rows non-passing validations potentially available object. validation step number, assigned validation step pointblank order definition. NULL (default), data extract tables provided list object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_data_extracts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collect data extracts from a validation step ‚Äî get_data_extracts","text":"list tables provided, , standalone table given.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_data_extracts.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Collect data extracts from a validation step ‚Äî get_data_extracts","text":"8-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/get_data_extracts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collect data extracts from a validation step ‚Äî get_data_extracts","text":"","code":"# Create a series of two validation # steps focused on testing row values # for part of the `small_table` object; # `interrogate()` immediately agent <-   create_agent(     read_fn = ~ small_table %>%       dplyr::select(a:f),     label = \"`get_data_extracts()`\"   ) %>%   col_vals_gt(vars(d), value = 1000) %>%   col_vals_between(     vars(c),     left = vars(a), right = vars(d),     na_pass = TRUE   ) %>%   interrogate()  # Using `get_data_extracts()` with its # defaults returns of a list of tables, # where each table is named after the # validation step that has an extract # available agent %>% get_data_extracts() #> $`1` #> # A tibble: 6 √ó 6 #>       a b             c     d e     f     #>   <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1     8 3-ldm-038     7  284. TRUE  low   #> 2     7 1-knw-093     3  843. TRUE  high  #> 3     3 5-bce-642     9  838. FALSE high  #> 4     3 5-bce-642     9  838. FALSE high  #> 5     4 2-dmx-010     7  834. TRUE  low   #> 6     2 7-dmx-010     8  108. FALSE low   #>  #> $`2` #> # A tibble: 4 √ó 6 #>       a b             c     d e     f     #>   <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1     6 8-kdg-938     3 2343. TRUE  high  #> 2     8 3-ldm-038     7  284. TRUE  low   #> 3     7 1-knw-093     3  843. TRUE  high  #> 4     4 5-boe-639     2 1036. FALSE low   #>   # We can get an extract for a specific # step by specifying it in the `i` # argument; let's get the failing rows # from the first validation step # (`col_vals_gt`) agent %>% get_data_extracts(i = 1) #> # A tibble: 6 √ó 6 #>       a b             c     d e     f     #>   <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1     8 3-ldm-038     7  284. TRUE  low   #> 2     7 1-knw-093     3  843. TRUE  high  #> 3     3 5-bce-642     9  838. FALSE high  #> 4     3 5-bce-642     9  838. FALSE high  #> 5     4 2-dmx-010     7  834. TRUE  low   #> 6     2 7-dmx-010     8  108. FALSE low"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_informant_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a table information report from an informant object ‚Äî get_informant_report","title":"Get a table information report from an informant object ‚Äî get_informant_report","text":"can get table information report informant object generated create_informant() function. report provided gt based display table. amount information shown depends extent added via use info_*() functions direct editing pointblank YAML file (informant can written pointblank YAML yaml_write(informant = <informant>, ...)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_informant_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a table information report from an informant object ‚Äî get_informant_report","text":"","code":"get_informant_report(   informant,   size = \"standard\",   title = \":default:\",   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_informant_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a table information report from an informant object ‚Äî get_informant_report","text":"informant informant object class ptblank_informant. size size display table, can either \"standard\" (default, width 875px) \"small\" (width 575px). title Options customizing title report. default keyword \":default:\" produces generic title text refers pointblank package language governed lang option. Another keyword option \":tbl_name:\", presents name table title report. title wanted, \":none:\" keyword option can used. Aside keyword options, text can provided title glue::glue() calls can used construct text string. providing text, interpreted Markdown text transformed internally HTML. circumvent transformation, use text () explicitly state supplied text transformed. lang language use information report (summary table provides validation plan results interrogation. default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). lang option override previously set language setting (e.g., create_agent() call). locale optional locale ID use formatting values information report summary table according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). locale option override previously set locale value (e.g., create_agent() call).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_informant_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a table information report from an informant object ‚Äî get_informant_report","text":"gt table object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_informant_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get a table information report from an informant object ‚Äî get_informant_report","text":"7-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/get_informant_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a table information report from an informant object ‚Äî get_informant_report","text":"","code":"# Generate an informant object using # the `small_table` dataset informant <- create_informant(small_table)  # This function creates some information # without any extra help by profiling # the supplied table object; it adds # the sections 'table' and columns' and # we can print the object to see the # table information report  # Alternatively, we can get the same report # by using `get_informant_report()` report <- get_informant_report(informant) class(report) #> [1] \"ptblank_informant_report\" \"gt_tbl\"                   #> [3] \"list\""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_multiagent_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a summary report using multiple agents ‚Äî get_multiagent_report","title":"Get a summary report using multiple agents ‚Äî get_multiagent_report","text":"can get informative summary table collective agents using get_multiagent_report() function. Information multiple agent can provided three forms: (1) Long Display (stacked reports), (2) Wide Display (comparison report), (3) tibble packed columns.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_multiagent_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a summary report using multiple agents ‚Äî get_multiagent_report","text":"","code":"get_multiagent_report(   multiagent,   display_table = TRUE,   display_mode = c(\"long\", \"wide\"),   title = \":default:\",   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_multiagent_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a summary report using multiple agents ‚Äî get_multiagent_report","text":"multiagent multiagent object class ptblank_multiagent. display_table display table generated? TRUE (default) display table report shown Viewer. FALSE tibble returned. display_mode getting display table, agent data presented \"long\" \"wide\" form? default \"long\" comparing multiple runs target table might preferable choose \"wide\". title Options customizing title report display_table = TRUE. default keyword \":default:\" produces generic title text. title wanted, \":none:\" keyword option can used. Another keyword option \":tbl_name:\", presents name table title report (can used display_mode = \"long\"). Aside keyword options, text can provided title glue::glue() calls can used construct text string. providing text, interpreted Markdown text transformed internally HTML. circumvent transformation, use text () explicitly state supplied text transformed. lang language use long wide report forms. default, NULL preserve language set component reports. following options force language across component reports: English (\"en\"), French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). locale optional locale ID use formatting values long wide report forms (according locale's rules). Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). locale option override previously set locale values.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_multiagent_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a summary report using multiple agents ‚Äî get_multiagent_report","text":"gt table object display_table = TRUE tibble display_table = FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_multiagent_report.html","id":"the-long-display","dir":"Reference","previous_headings":"","what":"The Long Display","title":"Get a summary report using multiple agents ‚Äî get_multiagent_report","text":"displayed \"long\" multiagent report stack individual agent reports single document order agents multiagent object. validation plan (possibly interrogation info) provided output equivalent calling get_agent_report() agents within multiagent object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_multiagent_report.html","id":"the-wide-display","dir":"Reference","previous_headings":"","what":"The Wide Display","title":"Get a summary report using multiple agents ‚Äî get_multiagent_report","text":"displayed \"wide\" multiagent report show data individual agents columns, rows standing validation steps common across agents. validation step represented icon (standing name validation function) associated SHA1 hash. highly trustworthy way ascertaining validation steps effectively identical across interrogations. way organizing report beneficial different agents may used different steps want track validation results validation step change target table (.e., new rows added, existing rows updated, etc.). single table display mode following columns: STEP: SHA1 hash validation step, possibly shared among several interrogations. subsequent columns: column beyond STEP represents separate interrogation agent object. time stamp completion interrogation shown column label.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_multiagent_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get a summary report using multiple agents ‚Äî get_multiagent_report","text":"10-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/get_multiagent_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a summary report using multiple agents ‚Äî get_multiagent_report","text":"","code":"if (interactive()) {  # Let's walk through several theoretical # data quality analyses of an extremely # small table; that table is called # `small_table` and we can find it as a # dataset in this package small_table  # To set failure limits and signal # conditions, we designate proportional # failure thresholds to the `warn`, `stop`, # and `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.05,     stop_at = 0.10,     notify_at = 0.20   )  # We will create four different agents # and have slightly different validation # steps in each of them; in the first, # `agent_1`, eight different validation # steps are created and the agent will # interrogate the `small_table` agent_1 <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`get_multiagent_report()`\",     actions = al   ) %>%   col_vals_gt(     vars(date_time),     value = vars(date),     na_pass = TRUE   ) %>%   col_vals_gt(     vars(b),      value = vars(g),     na_pass = TRUE   ) %>%   rows_distinct() %>%   col_vals_equal(     vars(d),      value = vars(d),     na_pass = TRUE   ) %>%   col_vals_between(     vars(c),      left = vars(a), right = vars(d)   ) %>%   col_vals_not_between(     vars(c),     left = 10, right = 20,     na_pass = TRUE   ) %>%   rows_distinct(vars(d, e, f)) %>%   col_is_integer(vars(a)) %>%   interrogate()  # The second agent, `agent_2`, retains # all of the steps of `agent_1` and adds # two more (the last of which is inactive) agent_2 <-    agent_1 %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),      regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     active = FALSE   ) %>%   interrogate()  # The third agent, `agent_3`, adds a single # validation step, removes the fifth one, # and deactivates the first agent_3 <-    agent_2 %>%   col_vals_in_set(     vars(f),     set = c(\"low\", \"mid\", \"high\")   ) %>%   remove_steps(i = 5) %>%   deactivate_steps(i = 1) %>%   interrogate()  # The fourth and final agent, `agent_4`, # reactivates steps 1 and 10, and removes # the sixth step agent_4 <-   agent_3 %>%   activate_steps(i = 1) %>%   activate_steps(i = 10) %>%   remove_steps(i = 6) %>%   interrogate()  # While all the agents are slightly # different from each other, we can still # get a combined report of them by # creating a 'multiagent' multiagent <-   create_multiagent(     agent_1, agent_2, agent_3, agent_4   )  # Calling `multiagent` in the console # prints the multiagent report; but we # can use some non-default option with # the `get_multiagent_report()` function  # By default, `get_multiagent_report()` # gives you a tall report with agent # reports being stacked report_1 <-    get_multiagent_report(multiagent)    # We can modify the title with that's # more suitable or use a keyword like # `:tbl_name:` to give us the target # table name in each section report_2 <-    get_multiagent_report(     multiagent,     title = \":tbl_name:\"   )  # We can opt for a wide display of # the reporting info, and this is # great when reporting on multiple # validations of the same target # table report_3 <-    get_multiagent_report(     multiagent,     display_mode = \"wide\"   ) }"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_sundered_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Sunder the data, splitting it into 'pass' and 'fail' pieces ‚Äî get_sundered_data","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces ‚Äî get_sundered_data","text":"Validation data one thing , sometimes, want use best part input dataset something else. get_sundered_data() function works agent object intel (.e., post interrogate()) gets either 'pass' data piece (rows failing test units across row-based validation functions), , 'fail' data piece (rows least one failing test unit across series validations). final option, can emit data new column (called .pb_combined) labels row passing failing across validation steps. labels \"pass\" \"fail\" default values can easily customized.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_sundered_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces ‚Äî get_sundered_data","text":"","code":"get_sundered_data(   agent,   type = c(\"pass\", \"fail\", \"combined\"),   pass_fail = c(\"pass\", \"fail\"),   id_cols = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_sundered_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces ‚Äî get_sundered_data","text":"agent agent object class ptblank_agent. interrogate() called , validation steps actually carried . type desired piece data resulting splitting. Options returning single table \"pass\" (default) \"fail\". options return single table , \"pass\" case, rows passed across validation steps (.e., failing test units part row validation step), , complementary set rows \"fail\" case. Providing NULL returns split data tables list (names \"pass\" \"fail\"). option \"combined\" applies categorical (pass/fail) label (settable pass_fail argument) new .pb_combined flag column. case ordering rows fully retained input table. pass_fail vector encoding flag column 'pass' 'fail' values type = \"combined\". default c(\"pass\", \"fail\") options c(TRUE, FALSE), c(1, 0), c(1L, 0L). id_cols optional specification one identifying columns. taken together, can count single column grouping columns distinguish rows. table undergoing validation data frame tibble, columns need specified id_cols.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_sundered_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces ‚Äî get_sundered_data","text":"list table objects type NULL, , single table type given.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_sundered_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces ‚Äî get_sundered_data","text":"caveats sundering. validation steps considered splitting row-based variety (e.g., col_vals_*() functions conjointly(), rows_distinct()). Furthermore, validation steps experienced evaluation issues interrogation considered, , validation steps active = FALSE disregarded. collection validation steps fulfill requirements sundering termed -consideration validation steps. using preconditions validation steps, must ensure -consideration validation steps use specified preconditions function. Put another way, split target table using collection -consideration validation steps use different forms input table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_sundered_data.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces ‚Äî get_sundered_data","text":"8-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/get_sundered_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces ‚Äî get_sundered_data","text":"","code":"# Create a series of two validation # steps focused on testing row values # for part of the `small_table` object; # `interrogate()` immediately agent <-   create_agent(     read_fn = ~ small_table %>%       dplyr::select(a:f),     label = \"`get_sundered_data()`\"   ) %>%   col_vals_gt(vars(d), value = 1000) %>%   col_vals_between(     vars(c),     left = vars(a), right = vars(d),     na_pass = TRUE   ) %>%   interrogate()  # Get the sundered data piece that # contains only rows that passed both # validation steps (the default piece); # this yields 5 of 13 total rows agent %>% get_sundered_data() #> # A tibble: 5 √ó 6 #>       a b             c      d e     f     #>   <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1     2 1-bcd-345     3  3423. TRUE  high  #> 2     3 5-egh-163     8 10000. TRUE  low   #> 3     2 5-jdo-903    NA  3892. FALSE mid   #> 4     4 2-dhe-923     4  3291. TRUE  mid   #> 5     1 3-dka-303    NA  2230. TRUE  high   # Get the complementary data piece: # all of those rows that failed either # of the two validation steps; # this yields 8 of 13 total rows agent %>%   get_sundered_data(type = \"fail\") #> # A tibble: 8 √ó 6 #>       a b             c     d e     f     #>   <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1     6 8-kdg-938     3 2343. TRUE  high  #> 2     8 3-ldm-038     7  284. TRUE  low   #> 3     7 1-knw-093     3  843. TRUE  high  #> 4     4 5-boe-639     2 1036. FALSE low   #> 5     3 5-bce-642     9  838. FALSE high  #> 6     3 5-bce-642     9  838. FALSE high  #> 7     4 2-dmx-010     7  834. TRUE  low   #> 8     2 7-dmx-010     8  108. FALSE low      # We can get all of the input data # returned with a flag column (called # `.pb_combined`); this is done by # using `type = \"combined\"` and that # rightmost column will contain `\"pass\"` # and `\"fail\"` values agent %>%   get_sundered_data(type = \"combined\") #> # A tibble: 13 √ó 7 #>        a b             c      d e     f     .pb_combined #>    <int> <chr>     <dbl>  <dbl> <lgl> <chr> <chr>        #>  1     2 1-bcd-345     3  3423. TRUE  high  pass         #>  2     3 5-egh-163     8 10000. TRUE  low   pass         #>  3     6 8-kdg-938     3  2343. TRUE  high  fail         #>  4     2 5-jdo-903    NA  3892. FALSE mid   pass         #>  5     8 3-ldm-038     7   284. TRUE  low   fail         #>  6     4 2-dhe-923     4  3291. TRUE  mid   pass         #>  7     7 1-knw-093     3   843. TRUE  high  fail         #>  8     4 5-boe-639     2  1036. FALSE low   fail         #>  9     3 5-bce-642     9   838. FALSE high  fail         #> 10     3 5-bce-642     9   838. FALSE high  fail         #> 11     4 2-dmx-010     7   834. TRUE  low   fail         #> 12     2 7-dmx-010     8   108. FALSE low   fail         #> 13     1 3-dka-303    NA  2230. TRUE  high  pass          # We can change the `\"pass\"` or `\"fail\"` # text values to another type of coding # with the `pass_fail` argument; one # possibility is TRUE/FALSE agent %>%   get_sundered_data(     type = \"combined\",     pass_fail = c(TRUE, FALSE)   ) #> # A tibble: 13 √ó 7 #>        a b             c      d e     f     .pb_combined #>    <int> <chr>     <dbl>  <dbl> <lgl> <chr> <lgl>        #>  1     2 1-bcd-345     3  3423. TRUE  high  TRUE         #>  2     3 5-egh-163     8 10000. TRUE  low   TRUE         #>  3     6 8-kdg-938     3  2343. TRUE  high  FALSE        #>  4     2 5-jdo-903    NA  3892. FALSE mid   TRUE         #>  5     8 3-ldm-038     7   284. TRUE  low   FALSE        #>  6     4 2-dhe-923     4  3291. TRUE  mid   TRUE         #>  7     7 1-knw-093     3   843. TRUE  high  FALSE        #>  8     4 5-boe-639     2  1036. FALSE low   FALSE        #>  9     3 5-bce-642     9   838. FALSE high  FALSE        #> 10     3 5-bce-642     9   838. FALSE high  FALSE        #> 11     4 2-dmx-010     7   834. TRUE  low   FALSE        #> 12     2 7-dmx-010     8   108. FALSE low   FALSE        #> 13     1 3-dka-303    NA  2230. TRUE  high  TRUE          # ...and using `0` and `1` might be # worthwhile in some situations agent %>%   get_sundered_data(     type = \"combined\",     pass_fail = 0:1   ) #> # A tibble: 13 √ó 7 #>        a b             c      d e     f     .pb_combined #>    <int> <chr>     <dbl>  <dbl> <lgl> <chr>        <int> #>  1     2 1-bcd-345     3  3423. TRUE  high             0 #>  2     3 5-egh-163     8 10000. TRUE  low              0 #>  3     6 8-kdg-938     3  2343. TRUE  high             1 #>  4     2 5-jdo-903    NA  3892. FALSE mid              0 #>  5     8 3-ldm-038     7   284. TRUE  low              1 #>  6     4 2-dhe-923     4  3291. TRUE  mid              0 #>  7     7 1-knw-093     3   843. TRUE  high             1 #>  8     4 5-boe-639     2  1036. FALSE low              1 #>  9     3 5-bce-642     9   838. FALSE high             1 #> 10     3 5-bce-642     9   838. FALSE high             1 #> 11     4 2-dmx-010     7   834. TRUE  low              1 #> 12     2 7-dmx-010     8   108. FALSE low              1 #> 13     1 3-dka-303    NA  2230. TRUE  high             0"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_tt_param.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a parameter value from a summary table ‚Äî get_tt_param","title":"Get a parameter value from a summary table ‚Äî get_tt_param","text":"get_tt_param() function can help obtain single parameter value summary table generated tt_*() functions tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_tbl_colnames(). following parameters used depending input tbl: tt_summary_stats(): \"min\", \"p05\", \"q_1\", \"med\", \"q_3\", \"p95\", \"max\", \"iqr\", \"range\" tt_string_info(): \"length_mean\", \"length_min\", \"length_max\" tt_tbl_dims(): \"rows\", \"columns\" tt_tbl_colnames(): integer present .param. column tt_summary_stats() tt_string_info() functions generate summary tables columns mirror numeric character columns input tables, respectively. reason, column name must supplied column argument get_tt_param().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_tt_param.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a parameter value from a summary table ‚Äî get_tt_param","text":"","code":"get_tt_param(tbl, param, column = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/get_tt_param.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a parameter value from a summary table ‚Äî get_tt_param","text":"tbl summary table generated either tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_tbl_colnames() functions. param parameter name associated value gotten. parameter names always available first column (.param.) summary table obtained tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_tbl_colnames(). column column summary table data value obtained. must supplied summary tables generated tt_summary_stats() tt_string_info() (tt_tbl_dims() tt_tbl_colnames() functions always generate two-column summary table).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/get_tt_param.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get a parameter value from a summary table ‚Äî get_tt_param","text":"12-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/get_tt_param.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a parameter value from a summary table ‚Äî get_tt_param","text":"","code":"# Get summary statistics for the # first quarter of the `game_revenue` # dataset that's included in the package stat_tbl <-    game_revenue %>%   tt_time_slice(slice_point = 0.25) %>%   tt_summary_stats()  # Based on player behavior for the first # quarter of the year, test whether the # maximum session duration during the # rest of the year is never higher game_revenue %>%   tt_time_slice(     slice_point = 0.25,     keep = \"right\"   ) %>%   test_col_vals_lte(     columns = vars(session_duration),      value = get_tt_param(       tbl = stat_tbl,       param = \"max\",       column = \"session_duration\"     )   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/has_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if one or more columns exist in a table ‚Äî has_columns","title":"Determine if one or more columns exist in a table ‚Äî has_columns","text":"utility function can help easily determine whether column specified name present table object. function works well enough table object can also used part formula validation function's active argument. Using active = ~ . %>% has_columns(\"column_1\") means validation step inactive target table contain column named column_1. can also use multiple columns vars() active = ~ . %>% has_columns(vars(column_1, column_2)) validation step make inactive interrogate() time unless columns column_1 column_2 present.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/has_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if one or more columns exist in a table ‚Äî has_columns","text":"","code":"has_columns(x, columns)"},{"path":"https://rich-iannone.github.io/pointblank/reference/has_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if one or more columns exist in a table ‚Äî has_columns","text":"x table object. columns One column names checked existence table x.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/has_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine if one or more columns exist in a table ‚Äî has_columns","text":"length-1 logical vector.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/has_columns.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Determine if one or more columns exist in a table ‚Äî has_columns","text":"13-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/has_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine if one or more columns exist in a table ‚Äî has_columns","text":"","code":"# The `small_table` dataset in the # package has the columns `date_time`, # `date`, and the `a` through `f` # columns small_table #> # A tibble: 13 √ó 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high   # With `has_columns()` we can check for # column existence by using it directly # with the table; a column name can be # verified as present by using it in # double quotes small_table %>% has_columns(\"date\") #> [1] TRUE  # Multiple column names can be supplied; # this is `TRUE` because both columns are # present in `small_table` small_table %>% has_columns(c(\"a\", \"b\")) #> [1] TRUE  # It's possible to supply column names # in `vars()` as well small_table %>% has_columns(vars(a, b)) #> [1] TRUE  # Because column `h` isn't present, this # returns `FALSE` (all specified columns # need to be present to obtain `TRUE`) small_table %>% has_columns(vars(a, h)) #> [1] FALSE  # The `has_columns()` function can be # useful in expressions that involve the # target table, especially if it is # uncertain that the table will contain # a column that's involved in a validation  # In the following agent-based validation, # the first two steps will be 'active' # because all columns checked for in the # expressions are present; the third step # is inactive because column `j` isn't # there (without the `active` statement we # would get an evaluation failure in the # agent report) agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\"   ) %>%   col_vals_gt(     vars(c), value = vars(a),     active = ~ . %>% has_columns(vars(a, c))   ) %>%   col_vals_lt(     vars(h), value = vars(d),     preconditions = ~ . %>% dplyr::mutate(h = d - a),     active = ~ . %>% has_columns(vars(a, d))   ) %>%   col_is_character(     vars(j),     active = ~ . %>% has_columns(\"j\")   ) %>%   interrogate()  #> ‚Ñπ Step 3 is not set as active. Skipping."},{"path":"https://rich-iannone.github.io/pointblank/reference/incorporate.html","id":null,"dir":"Reference","previous_headings":"","what":"Given an informant object, update and incorporate table snippets ‚Äî incorporate","title":"Given an informant object, update and incorporate table snippets ‚Äî incorporate","text":"informant object number snippets available (using info_snippet()) strings use (using info_*() functions {<snippet_name>} text elements), process incorporating aspects table info text can occur using incorporate() function. , information fully updated (getting current state table dimensions, re-rendering info text, etc.) can print informant object use get_informant_report() function see information report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/incorporate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Given an informant object, update and incorporate table snippets ‚Äî incorporate","text":"","code":"incorporate(informant)"},{"path":"https://rich-iannone.github.io/pointblank/reference/incorporate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Given an informant object, update and incorporate table snippets ‚Äî incorporate","text":"informant informant object class ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/incorporate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Given an informant object, update and incorporate table snippets ‚Äî incorporate","text":"ptblank_informant object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/incorporate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Given an informant object, update and incorporate table snippets ‚Äî incorporate","text":"7-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/incorporate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Given an informant object, update and incorporate table snippets ‚Äî incorporate","text":"","code":"if (interactive()) {  # Take the `small_table` and # assign it to `test_table`; we'll # modify it later test_table <- small_table  # Generate an informant object, add # two snippets with `info_snippet()`, # add information with some other # `info_*()` functions and then # `incorporate()` the snippets into # the info text informant <-    create_informant(     read_fn = ~ test_table,     tbl_name = \"test_table\"   ) %>%   info_snippet(     snippet_name = \"row_count\",     fn = ~ . %>% nrow()   ) %>%   info_snippet(     snippet_name = \"col_count\",     fn = ~ . %>% ncol()   ) %>%   info_columns(     columns = vars(a),     info = \"In the range of 1 to 10. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`. (CALC)\"   ) %>%   info_section(     section_name = \"rows\",     row_count = \"There are {row_count} rows available.\"   ) %>%   incorporate()  # We can print the `informant` object # to see the information report  # Let's modify `test_table` to give # it more rows and an extra column test_table <-    dplyr::bind_rows(test_table, test_table) %>%   dplyr::mutate(h = a + c)  # Using `incorporate()` will cause # the snippets to be reprocessed, and, # the strings to be updated informant <-   informant %>% incorporate()    # When printed again, we'll see that the # row and column counts in the header # have been updated to reflect the # changed `test_table`  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Add information that focuses on aspects of a data table's columns ‚Äî info_columns","title":"Add information that focuses on aspects of a data table's columns ‚Äî info_columns","text":"Upon creation informant object (create_informant() function), two sections containing properties: (1) 'table' (2) 'columns'. 'columns' section initialized table's column names types (_type). Beyond , useful provide details nature column can info_columns() function. single column (multiple columns) targeted, series named arguments (form entry_name = \"*info text*.\") serves additional information column columns.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add information that focuses on aspects of a data table's columns ‚Äî info_columns","text":"","code":"info_columns(x, columns, ..., .add = TRUE)"},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add information that focuses on aspects of a data table's columns ‚Äî info_columns","text":"x informant object class ptblank_informant. columns column set columns focus . Can defined column name quotes (e.g., \"<column_name>\"), one column names vars() (e.g., vars(<column_name>)), select helper (e.g., starts_with(\"date\")). ... Information entries series named arguments. names refer subsection titles within COLUMN -> <COLUMN_NAME> RHS contains info text (informational text can written Markdown styled Text Tricks). .add new text added existing text? TRUE default; setting FALSE replaces existing text property.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add information that focuses on aspects of a data table's columns ‚Äî info_columns","text":"ptblank_informant object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns.html","id":"info-text","dir":"Reference","previous_headings":"","what":"Info Text","title":"Add information that focuses on aspects of a data table's columns ‚Äî info_columns","text":"info text used info_*() functions readily accepts Markdown formatting, , Text Tricks can used spice presentation. Markdown links written < link url > [ link text ]( link url ) get nicely-styled links. dates expressed ISO-8601 standard parentheses, \"(2004-12-01)\", styled font variation (monospaced) underlined purple. Spans text can converted label-style text using: (1) double parentheses around text rectangular border ((label text)), (2) triple parentheses around text rounded-rectangular border like (((label text))). CSS style rules can applied spans info text following form: [[ info text ]]<< CSS style rules >> example practice suppose like change color text red make font appear somewhat thinner. variation following might used: \"[[factor]]<<color: red; font-weight: 300;>> value.\" quite CSS style rules can used great effect. might like: color: <color value>; (text color) background-color: <color value>; (text's background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); examples, 'length value' refers CSS length can expressed different units measure (e.g., 12px, 1em, etc.). lengths can expressed positive negative values (e.g., letter-spacing). Color values can expressed ways, common form hexadecimal color values CSS color names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Add information that focuses on aspects of a data table's columns ‚Äî info_columns","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). way information table columns represented YAML works like : info text goes subsections YAML keys named columns, part top-level columns key. example several calls info_columns() expressed R code result corresponds YAML representation. Subsections represented column names automatically generated creating informant. Within , can multiple subsections used holding info text column. subsections used across different columns needn't either, commonality enforced presence _type key (automatically updated every incorporate() invocation). safest use single quotation marks around info text directly editing YAML file. Note Markdown formatting info snippet placeholders (shown {snippet_1}, see info_snippet() information) preserved YAML. Markdown HTML conversion done printing informant (invoking get_informant_report() informant) processing snippets (generation insertion) done using incorporate() function. Thus, source text always maintained YAML representation never written processed form.","code":"# R statement informant %>%    info_columns(     columns = \"date_time\",     info = \"*info text* 1.\"   ) %>%   info_columns(     columns = \"date\",     info = \"*info text* 2.\"   ) %>%   info_columns(     columns = \"item_count\",     info = \"*info text* 3. Statistics: {snippet_1}.\"   ) %>%   info_columns(     columns = vars(date, date_time),     info = \"UTC time.\"   )  # YAML representation columns:   date_time:     _type: POSIXct, POSIXt     info: '*info text* 1. UTC time.'   date:     _type: Date     info: '*info text* 2. UTC time.'   item_count:     _type: integer     info: '*info text* 3. Statistics: {snippet_1}.'"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Add information that focuses on aspects of a data table's columns ‚Äî info_columns","text":"3-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add information that focuses on aspects of a data table's columns ‚Äî info_columns","text":"","code":"# Create a pointblank `informant` # object with `create_informant()`; # we specify a `read_fn` with the # `~` followed by a statement that # gets the `small_table` dataset informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   )  # We can add *info text* to describe # the columns in the table with multiple # `info_columns()` calls; the *info text* # calls are additive to existing content # in subsections informant <-   informant %>%   info_columns(     columns = vars(a),     info = \"In the range of 1 to 10. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`. (CALC)\"   )  # Upon printing the `informant` object, we see # the additions made to the 'Columns' section  if (interactive()) {  # The `informant` object can be written to # a YAML file with the `yaml_write()` # function; then, information can # be directly edited or modified yaml_write(   informant = informant,   filename = \"informant.yml\" )  # The YAML file can then be read back # into an informant object with the # `yaml_read_informant()` function informant <-   yaml_read_informant(     filename = \"informant.yml\"   )  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns_from_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Add column information from another data table ‚Äî info_columns_from_tbl","title":"Add column information from another data table ‚Äî info_columns_from_tbl","text":"info_columns_from_tbl() function wrapper around info_columns() function useful wish apply info text columns information already exists data frame (form can readily coaxed data frame). form input tbl (one contains column metadata) basic requirements: data frame must two columns columns must class character first column contain column names second contain info text column matches across tables (.e., tbl target table informant) new entry \"info\" property. Empty missing info text pruned tbl.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns_from_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add column information from another data table ‚Äî info_columns_from_tbl","text":"","code":"info_columns_from_tbl(x, tbl, .add = TRUE)"},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns_from_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add column information from another data table ‚Äî info_columns_from_tbl","text":"x informant object class ptblank_informant. tbl two-column data frame contains metadata target table informant object. .add new text added existing text? TRUE default; setting FALSE replaces existing text \"info\" property.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns_from_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add column information from another data table ‚Äî info_columns_from_tbl","text":"ptblank_informant object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns_from_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Add column information from another data table ‚Äî info_columns_from_tbl","text":"3-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/info_columns_from_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add column information from another data table ‚Äî info_columns_from_tbl","text":"","code":"# Create a pointblank `informant` # object with `create_informant()`; # we specify a `read_fn` with the # `~` followed by a statement that # gets the `game_revenue` dataset informant <-    create_informant(     read_fn = ~ game_revenue,     tbl_name = \"game_revenue\",     label = \"An example.\"   )  # We can add *info text* to describe # the columns in the table by using # information in another table; the # `info_columns_from_tbl()` takes a # table object where the first column # has the column names and the second # contains the *info text* (the # `game_revenue_info` dataset contains # metadata for `game_revenue`) informant <-   informant %>%   info_columns_from_tbl(     tbl = game_revenue_info   )  # We can continue to add more *info # text* since the process is additive; # the `info_columns_from_tbl()` # function populates the `info` # subsection informant <-   informant %>%   info_columns(     columns = \"item_revenue\",     info = \"Revenue reported in USD.\"   ) %>%   info_columns(     columns = \"acquisition\",     `top list` = \"{top5_aq}\"   ) %>%   info_snippet(     snippet_name = \"top5_aq\",     fn = snip_list(column = \"acquisition\")   ) %>%   incorporate() #>  #> ‚îÄ‚îÄ Incorporation Started - there is a single snippet to process ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚úî Information gathered. #> ‚úî Snippets processed. #> ‚úî Information built. #>  #> ‚îÄ‚îÄ Incorporation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"},{"path":"https://rich-iannone.github.io/pointblank/reference/info_section.html","id":null,"dir":"Reference","previous_headings":"","what":"Add information that focuses on some key aspect of the data table ‚Äî info_section","title":"Add information that focuses on some key aspect of the data table ‚Äî info_section","text":"info_tabular() info_columns() functions allow us add/modify info text specific sections, info_section() makes possible add sections choosing information make sense sections. Define section_name provide series named arguments (form entry_name = \"*info text*.\") build informational content section.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_section.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add information that focuses on some key aspect of the data table ‚Äî info_section","text":"","code":"info_section(x, section_name, ...)"},{"path":"https://rich-iannone.github.io/pointblank/reference/info_section.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add information that focuses on some key aspect of the data table ‚Äî info_section","text":"x informant object class ptblank_informant. section_name name section information pertains. ... Information entries series named arguments. names refer subsection titles within section defined section_name RHS info text (informational text can written Markdown styled Text Tricks).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_section.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add information that focuses on some key aspect of the data table ‚Äî info_section","text":"ptblank_informant object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_section.html","id":"info-text","dir":"Reference","previous_headings":"","what":"Info Text","title":"Add information that focuses on some key aspect of the data table ‚Äî info_section","text":"info text used info_*() functions readily accepts Markdown formatting, , Text Tricks can used spice presentation. Markdown links written < link url > [ link text ]( link url ) get nicely-styled links. dates expressed ISO-8601 standard parentheses, \"(2004-12-01)\", styled font variation (monospaced) underlined purple. Spans text can converted label-style text using: (1) double parentheses around text rectangular border ((label text)), (2) triple parentheses around text rounded-rectangular border like (((label text))). CSS style rules can applied spans info text following form: [[ info text ]]<< CSS style rules >> example practice suppose like change color text red make font appear somewhat thinner. variation following might used: \"[[factor]]<<color: red; font-weight: 300;>> value.\" quite CSS style rules can used great effect. might like: color: <color value>; (text color) background-color: <color value>; (text's background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); examples, 'length value' refers CSS length can expressed different units measure (e.g., 12px, 1em, etc.). lengths can expressed positive negative values (e.g., letter-spacing). Color values can expressed ways, common form hexadecimal color values CSS color names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_section.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Add information that focuses on some key aspect of the data table ‚Äî info_section","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). Extra sections (.e., neither table columns sections) can generated filled info text using one calls info_section(). expressed R code YAML representation. Subsections represented column names automatically generated creating informant. Within top-level sections (.e., History Additional Notes) can multiple subsections used holding info text. safest use single quotation marks around info text directly editing YAML file. Note Markdown formatting info snippet placeholders (shown {snippet}, see info_snippet() information) preserved YAML. Markdown HTML conversion done printing informant (invoking get_informant_report() informant) processing snippets (generation insertion) done using incorporate() function. Thus, source text always maintained YAML representation never written processed form.","code":"# R statement informant %>%    info_section(     section_name = \"History\",     Changes = \" - Change 1 - Change 2 - Change 3\",     `Last Update` = \"(2020-10-23) at 3:28 PM.\"   ) %>%   info_section(     section_name = \"Additional Notes\",     `Notes 1` = \"Notes with a {snippet}.\",     `Notes 2` = \"**Bold notes**.\"   )  # YAML representation History:   Changes: |2-        - Change 1     - Change 2     - Change 3   Last Update: (2020-10-23) at 3:28 PM. Additional Notes:   Notes 1: Notes with a {snippet}.   Notes 2: '**Bold notes**.'"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/info_section.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Add information that focuses on some key aspect of the data table ‚Äî info_section","text":"3-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/info_section.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add information that focuses on some key aspect of the data table ‚Äî info_section","text":"","code":"# Create a pointblank `informant` # object with `create_informant()`; # we specify a `read_fn` with the # `~` followed by a statement that # gets the `small_table` dataset informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   )  # The `informant` object has the 'table' # and 'columns' sections; we can create # entirely different sections with their # own properties using `info_section()`  # We can add *info text* to sections # entirely different than `table` and # `columns` with `info_section()` informant <-   informant %>%   info_section(     section_name = \"Notes\",     creation = \"Dataset generated on (2020-01-15).\",     usage = \"`small_table %>% dplyr::glimpse()`\"   ) %>%   incorporate() #>  #> ‚îÄ‚îÄ Incorporation Started ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚úî Information gathered. #> ‚úî Information built. #>  #> ‚îÄ‚îÄ Incorporation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # Upon printing the `informant` object, we see # the addition of the 'Notes' section and its # own information  if (interactive()) {  # The `informant` object can be written to # a YAML file with the `yaml_write()` # function; then, information can # be directly edited or modified yaml_write(   informant = informant,   filename = \"informant.yml\" )  # The YAML file can then be read back # into an informant object with the # `yaml_read_informant()` function informant <-   yaml_read_informant(     filename = \"informant.yml\"   )  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/info_snippet.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a useful text 'snippet' from the target table ‚Äî info_snippet","title":"Generate a useful text 'snippet' from the target table ‚Äî info_snippet","text":"Getting little snippets information table goes hand--hand mixing bits info table info. Call info_snippet() define snippet get target table. snippet definition supplied either formula, , pointblank-supplied snip_*() function. long know interact table extract information, can easily define snippets informant object. snippets defined, can insert info text defined info_*() functions (info_tabular(), info_columns(), info_section()). Use curly braces just snippet_name inside (e.g., \"column {n_cat} categories.\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_snippet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a useful text 'snippet' from the target table ‚Äî info_snippet","text":"","code":"info_snippet(x, snippet_name, fn)"},{"path":"https://rich-iannone.github.io/pointblank/reference/info_snippet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a useful text 'snippet' from the target table ‚Äî info_snippet","text":"x informant object class ptblank_informant. snippet_name name snippet, used interpolating result snippet formula info text defined info_*() function. fn formula obtains snippet data target table. best use leading dot (.) stands table use pipes construct series operations performed table (e.g., ~ . %>% dplyr::pull(column_2) %>% max(na.rm = TRUE)). long result length-1 vector, 'll likely valid insertion info text. Alternatively, snip_*() function can used (functions always return formula suitable types data sources).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_snippet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a useful text 'snippet' from the target table ‚Äî info_snippet","text":"ptblank_informant object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_snippet.html","id":"snip-functions-provided-in-pointblank","dir":"Reference","previous_headings":"","what":"Snip functions provided in pointblank","title":"Generate a useful text 'snippet' from the target table ‚Äî info_snippet","text":"convenience, several snip_*() functions provided package work column data informant's target table. : snip_list(): get list column categories snip_stats(): get inline statistical summary snip_lowest(): get lowest value column snip_highest() : get highest value column understood target table , column functions necessary obtaining resultant text.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_snippet.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Generate a useful text 'snippet' from the target table ‚Äî info_snippet","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). Snippets stored YAML representation expressed R code YAML output (showing meta_snippets columns keys demonstrate relationship ).","code":"# R statement informant %>%    info_columns(     columns = \"date_time\",     `Latest Date` = \"The latest date is {latest_date}.\"   ) %>%   info_snippet(     snippet_name = \"latest_date\",     fn = ~ . %>% dplyr::pull(date) %>% max(na.rm = TRUE)   ) %>%   incorporate()  # YAML representation meta_snippets:   latest_date: ~. %>% dplyr::pull(date) %>% max(na.rm = TRUE) ... columns:   date_time:     _type: POSIXct, POSIXt     Latest Date: The latest date is {latest_date}.   date:     _type: Date   item_count:     _type: integer"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/info_snippet.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Generate a useful text 'snippet' from the target table ‚Äî info_snippet","text":"3-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/info_snippet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a useful text 'snippet' from the target table ‚Äî info_snippet","text":"","code":"# Take the `small_table` and # assign it to `test_table`; we'll # modify it later test_table <- small_table  # Generate an informant object, add # two snippets with `info_snippet()`, # add information with some other # `info_*()` functions and then # `incorporate()` the snippets into # the info text informant <-    create_informant(     read_fn = ~ test_table,     tbl_name = \"test_table\",     label = \"An example.\"   ) %>%   info_snippet(     snippet_name = \"row_count\",     fn = ~ . %>% nrow()   ) %>%   info_snippet(     snippet_name = \"max_a\",     fn = snip_highest(column = \"a\")   ) %>%   info_columns(     columns = vars(a),     info = \"In the range of 1 to {max_a}. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`. (CALC)\"   ) %>%   info_section(     section_name = \"rows\",     row_count = \"There are {row_count} rows available.\"   ) %>%   incorporate() #> Error in rlang::eval_tidy(., env = caller_env(n = 1)): object 'test_table' not found  # We can print the `informant` object # to see the information report  # Let's modify `test_table` to give # it more rows and an extra column test_table <-    dplyr::bind_rows(test_table, test_table) %>%   dplyr::mutate(h = a + c)  # Using `incorporate()` will cause # the snippets to be reprocessed, and, # the info text to be updated informant <-   informant %>% incorporate() #> Error in incorporate(.): object 'informant' not found"},{"path":"https://rich-iannone.github.io/pointblank/reference/info_tabular.html","id":null,"dir":"Reference","previous_headings":"","what":"Add information that focuses on aspects of the data table as a whole ‚Äî info_tabular","title":"Add information that focuses on aspects of the data table as a whole ‚Äî info_tabular","text":"informant object created create_informant() function, two starter sections: (1) 'table' (2) 'columns'. 'table' section contain properties upon creation, supplied table name (name) table dimensions (_columns _rows). can add table-based properties info_tabular() function. providing series named arguments (form entry_name = \"*info text*.\"), can add information makes sense describing table whole.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_tabular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add information that focuses on aspects of the data table as a whole ‚Äî info_tabular","text":"","code":"info_tabular(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/reference/info_tabular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add information that focuses on aspects of the data table as a whole ‚Äî info_tabular","text":"x informant object class ptblank_informant. ... Information entries series named arguments. names refer subsection titles within TABLE section RHS info text (informational text can written Markdown styled Text Tricks).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_tabular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add information that focuses on aspects of the data table as a whole ‚Äî info_tabular","text":"ptblank_informant object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_tabular.html","id":"info-text","dir":"Reference","previous_headings":"","what":"Info Text","title":"Add information that focuses on aspects of the data table as a whole ‚Äî info_tabular","text":"info text used info_*() functions readily accepts Markdown formatting, , Text Tricks can used spice presentation. Markdown links written < link url > [ link text ]( link url ) get nicely-styled links. dates expressed ISO-8601 standard parentheses, \"(2004-12-01)\", styled font variation (monospaced) underlined purple. Spans text can converted label-style text using: (1) double parentheses around text rectangular border ((label text)), (2) triple parentheses around text rounded-rectangular border like (((label text))). CSS style rules can applied spans info text following form: [[ info text ]]<< CSS style rules >> example practice suppose like change color text red make font appear somewhat thinner. variation following might used: \"[[factor]]<<color: red; font-weight: 300;>> value.\" quite CSS style rules can used great effect. might like: color: <color value>; (text color) background-color: <color value>; (text's background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); examples, 'length value' refers CSS length can expressed different units measure (e.g., 12px, 1em, etc.). lengths can expressed positive negative values (e.g., letter-spacing). Color values can expressed ways, common form hexadecimal color values CSS color names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/info_tabular.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Add information that focuses on aspects of the data table as a whole ‚Äî info_tabular","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). info_tabular() represented YAML, info text goes subsections top-level table key. example call info_tabular() expressed R code corresponding YAML representation. Subsection titles defined info_tabular() can set backticks syntactically correct argument name without (e.g., using spaces, hyphens, etc.). safest use single quotation marks around info text directly editing YAML file. Note Markdown formatting info snippet placeholders (shown {snippet_1}, see info_snippet() information) preserved YAML. Markdown HTML conversion done printing informant (invoking get_informant_report() informant) processing snippets (generation insertion) done using incorporate() function. Thus, source text always maintained YAML representation never written processed form.","code":"# R statement informant %>%    info_tabular(     section_1 = \"*info text* 1.\",     `section 2` = \"*info text* 2 and {snippet_1}\"   )  # YAML representation table:   _columns: 23   _rows: 205.0   _type: tbl_df   section_1: '*info text* 1.'   section 2: '*info text* 2 and {snippet_1}'"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/info_tabular.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Add information that focuses on aspects of the data table as a whole ‚Äî info_tabular","text":"3-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/info_tabular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add information that focuses on aspects of the data table as a whole ‚Äî info_tabular","text":"","code":"# Create a pointblank `informant` # object with `create_informant()`; # we specify a `read_fn` with the # `~` followed by a statement that # gets the `small_table` dataset informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   )  # We can add *info text* to describe # the table with `info_tabular()` informant <-   informant %>%   info_tabular(     `Row Definition` = \"A row has randomized values.\",     Source = c(       \"- From the **pointblank** package.\",       \"- [https://rich-iannone.github.io/pointblank/]()\"      )    )  # Upon printing the `informant` object, we see # the additions made to the 'Table' section  if (interactive()) {  # The `informant` object can be written to # a YAML file with the `yaml_write()` # function; then information can # be directly edited or modified yaml_write(   informant = informant,   filename = \"informant.yml\" )  # The YAML file can then be read back # into an informant object with the # `yaml_read_informant()` function informant <-   yaml_read_informant(     filename = \"informant.yml\"   )  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/interrogate.html","id":null,"dir":"Reference","previous_headings":"","what":"Given an agent that has a validation plan, perform an interrogation ‚Äî interrogate","title":"Given an agent that has a validation plan, perform an interrogation ‚Äî interrogate","text":"agent information (.e., validation plan series validation steps), interrogation process can occur according plan. , agent gathered intel, can use functions like get_agent_report() all_passed() understand interrogation went .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/interrogate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Given an agent that has a validation plan, perform an interrogation ‚Äî interrogate","text":"","code":"interrogate(   agent,   extract_failed = TRUE,   get_first_n = NULL,   sample_n = NULL,   sample_frac = NULL,   sample_limit = 5000 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/interrogate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Given an agent that has a validation plan, perform an interrogation ‚Äî interrogate","text":"agent agent object class ptblank_agent created create_agent(). extract_failed option collect rows pass particular validation step. default TRUE options allow fine control rows collected. get_first_n option collect non-passing rows chosen, option collect first n rows . Supply number rows extract top non-passing rows table (ordering data original table retained). sample_n option collect non-passing rows chosen, option allows sampling n rows. Supply number rows sample non-passing rows table. n greater number non-passing rows, rows returned. sample_frac option collect non-passing rows chosen, option allows sampling fraction rows. Provide number range 0 1. number rows return may extremely large (especially querying remote databases), however, sample_limit option apply hard limit returned rows. sample_limit value limits possible number rows returned sampling non-passing rows using sample_frac option.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/interrogate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Given an agent that has a validation plan, perform an interrogation ‚Äî interrogate","text":"ptblank_agent object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/interrogate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Given an agent that has a validation plan, perform an interrogation ‚Äî interrogate","text":"6-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/interrogate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Given an agent that has a validation plan, perform an interrogation ‚Äî interrogate","text":"","code":"if (interactive()) {  # Create a simple table with two # columns of numerical values tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 0, 3)   )  # Validate that values in column # `a` from `tbl` are always > 5, # using `interrogate()` carries out # the validation plan and completes # the whole process agent <-   create_agent(tbl = tbl) %>%   col_vals_gt(vars(a), value = 5) %>%   interrogate()  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/log4r_step.html","id":null,"dir":"Reference","previous_headings":"","what":"Enable logging of failure conditions at the validation step level ‚Äî log4r_step","title":"Enable logging of failure conditions at the validation step level ‚Äî log4r_step","text":"log4r_step() function can used action action_levels() function (list component fns list). Place call function every failure condition produce log (.e., warn, stop, notify). failure condition highest severity given validation step produce log entry (skipping failure conditions lower severity) long call log4r_step() present.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/log4r_step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enable logging of failure conditions at the validation step level ‚Äî log4r_step","text":"","code":"log4r_step(x, message = NULL, append_to = \"pb_log_file\")"},{"path":"https://rich-iannone.github.io/pointblank/reference/log4r_step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enable logging of failure conditions at the validation step level ‚Äî log4r_step","text":"x reference x-list object prepared agent. version x-list generated via get_agent_x_list(<agent>, = <step>) except version internally generated hence available internal evaluation context. message message use log entry. provided, default glue string used messaging. dynamic since internal glue::glue() call occurs environment x, x-list constrained validation step. default message, used message = NULL glue string \"Step {x$} exceeded {level} failure threshold (f_failed = {x$f_failed}) ['{x$type}']\". can seen, custom message can crafted uses elements x-list {x$<component>} construction. append_to file log entries warn level appended. can alternatively one log4r appenders.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/log4r_step.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Enable logging of failure conditions at the validation step level ‚Äî log4r_step","text":"5-1","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator ‚Äî %>%","title":"Pipe operator ‚Äî %>%","text":"See magrittr::[\\%>\\%][magrittr::\\%>\\%] details.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator ‚Äî %>%","text":"","code":"lhs %>% rhs"},{"path":"https://rich-iannone.github.io/pointblank/reference/print.action_levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the action_levels object ‚Äî print.action_levels","title":"Print the action_levels object ‚Äî print.action_levels","text":"function allow action_levels nicely printed.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.action_levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the action_levels object ‚Äî print.action_levels","text":"","code":"# S3 method for action_levels print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/reference/print.action_levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the action_levels object ‚Äî print.action_levels","text":"x object class action_levels. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the ptblank_agent object ‚Äî print.ptblank_agent","title":"Print the ptblank_agent object ‚Äî print.ptblank_agent","text":"function allow agent object print useful HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the ptblank_agent object ‚Äî print.ptblank_agent","text":"","code":"# S3 method for ptblank_agent print(x, view = interactive(), ...)"},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the ptblank_agent object ‚Äî print.ptblank_agent","text":"x object class ptblank_agent. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_informant.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the ptblank_informant object ‚Äî print.ptblank_informant","title":"Print the ptblank_informant object ‚Äî print.ptblank_informant","text":"function allow informant object print useful HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_informant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the ptblank_informant object ‚Äî print.ptblank_informant","text":"","code":"# S3 method for ptblank_informant print(x, view = interactive(), ...)"},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_informant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the ptblank_informant object ‚Äî print.ptblank_informant","text":"x informant object class ptblank_informant. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_multiagent.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the ptblank_multiagent object ‚Äî print.ptblank_multiagent","title":"Print the ptblank_multiagent object ‚Äî print.ptblank_multiagent","text":"function allow multiagent object print useful HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_multiagent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the ptblank_multiagent object ‚Äî print.ptblank_multiagent","text":"","code":"# S3 method for ptblank_multiagent print(x, view = interactive(), ...)"},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_multiagent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the ptblank_multiagent object ‚Äî print.ptblank_multiagent","text":"x object class ptblank_multiagent. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_multiagent_report.long.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the ptblank_multiagent_report.long object ‚Äî print.ptblank_multiagent_report.long","title":"Print the ptblank_multiagent_report.long object ‚Äî print.ptblank_multiagent_report.long","text":"function print ptblank_multiagent_report.long object, HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_multiagent_report.long.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the ptblank_multiagent_report.long object ‚Äî print.ptblank_multiagent_report.long","text":"","code":"# S3 method for ptblank_multiagent_report.long print(x, view = interactive(), ...)"},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_multiagent_report.long.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the ptblank_multiagent_report.long object ‚Äî print.ptblank_multiagent_report.long","text":"x object class ptblank_multiagent_report.long. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_tbl_scan.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the ptblank_tbl_scan object ‚Äî print.ptblank_tbl_scan","title":"Print the ptblank_tbl_scan object ‚Äî print.ptblank_tbl_scan","text":"function print ptblank_tbl_scan object, HTML-based report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_tbl_scan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the ptblank_tbl_scan object ‚Äî print.ptblank_tbl_scan","text":"","code":"# S3 method for ptblank_tbl_scan print(x, ..., view = interactive())"},{"path":"https://rich-iannone.github.io/pointblank/reference/print.ptblank_tbl_scan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the ptblank_tbl_scan object ‚Äî print.ptblank_tbl_scan","text":"x object class ptblank_tbl_scan. ... additional parameters. view value print()s browse argument.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.read_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the read_fn object ‚Äî print.read_fn","title":"Print the read_fn object ‚Äî print.read_fn","text":"function allow read_fn nicely printed.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.read_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the read_fn object ‚Äî print.read_fn","text":"","code":"# S3 method for read_fn print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/reference/print.read_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the read_fn object ‚Äî print.read_fn","text":"x object class read_fn. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.tbl_store.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the tbl_store object ‚Äî print.tbl_store","title":"Print the tbl_store object ‚Äî print.tbl_store","text":"function allow tbl_store nicely printed.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.tbl_store.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the tbl_store object ‚Äî print.tbl_store","text":"","code":"# S3 method for tbl_store print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/reference/print.tbl_store.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the tbl_store object ‚Äî print.tbl_store","text":"x object class tbl_store. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.x_list_i.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a single-step x-list to the console ‚Äî print.x_list_i","title":"Print a single-step x-list to the console ‚Äî print.x_list_i","text":"function print x-list object, single step, console.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.x_list_i.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a single-step x-list to the console ‚Äî print.x_list_i","text":"","code":"# S3 method for x_list_i print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/reference/print.x_list_i.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a single-step x-list to the console ‚Äî print.x_list_i","text":"x x-list object class x_list_i. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.x_list_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Print an x-list comprising all validation steps to the console ‚Äî print.x_list_n","title":"Print an x-list comprising all validation steps to the console ‚Äî print.x_list_n","text":"function print x-list object, validation steps included, console.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/print.x_list_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print an x-list comprising all validation steps to the console ‚Äî print.x_list_n","text":"","code":"# S3 method for x_list_n print(x, ...)"},{"path":"https://rich-iannone.github.io/pointblank/reference/print.x_list_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print an x-list comprising all validation steps to the console ‚Äî print.x_list_n","text":"x x-list object class x_list_n. ... additional parameters.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/read_disk_multiagent.html","id":null,"dir":"Reference","previous_headings":"","what":"Read pointblank agents stored on disk as a multiagent ‚Äî read_disk_multiagent","title":"Read pointblank agents stored on disk as a multiagent ‚Äî read_disk_multiagent","text":"agent informant can written disk x_write_disk() function. useful later retrieving stored agent x_read_disk() also possible read series -disk agents read_disk_multiagent() function, creates ptblank_multiagent object. multiagent object can also generated via create_multiagent() function less convenient use one just using agents previous written disk.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/read_disk_multiagent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read pointblank agents stored on disk as a multiagent ‚Äî read_disk_multiagent","text":"","code":"read_disk_multiagent(filenames = NULL, pattern = NULL, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/read_disk_multiagent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read pointblank agents stored on disk as a multiagent ‚Äî read_disk_multiagent","text":"filenames names files (holding agent objects) previously written x_write_disk(). pattern regex pattern accessing saved--disk agent files located directory (specified path argument). path path collection files. either optional case files specified filenames (path combined filenames), , required providing pattern file names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/read_disk_multiagent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read pointblank agents stored on disk as a multiagent ‚Äî read_disk_multiagent","text":"ptblank_multiagent object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/read_disk_multiagent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Read pointblank agents stored on disk as a multiagent ‚Äî read_disk_multiagent","text":"10-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages ‚Äî reexports","title":"Objects exported from other packages ‚Äî reexports","text":"objects imported packages. Follow links see documentation. blastula creds, creds_anonymous, creds_file, creds_key dplyr , case_when, vars rlang expr tidyselect contains, ends_with, everything, matches, starts_with","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_read_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove a table-prep formula associated with an agent or informant ‚Äî remove_read_fn","title":"Remove a table-prep formula associated with an agent or informant ‚Äî remove_read_fn","text":"Removing agent informant's association table-pre formula can done remove_read_fn(). may good idea interactive session needing rely direct association 'fixed' data table (settable create_agent() create_informant()'s tbl argument set_tbl()) instead using table-prep formula might produce different different table expected. table-prep formula can always set set_read_fn().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_read_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove a table-prep formula associated with an agent or informant ‚Äî remove_read_fn","text":"","code":"remove_read_fn(x)"},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_read_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove a table-prep formula associated with an agent or informant ‚Äî remove_read_fn","text":"x agent object class ptblank_agent, , informant class ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_read_fn.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Remove a table-prep formula associated with an agent or informant ‚Äî remove_read_fn","text":"9-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_read_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove a table-prep formula associated with an agent or informant ‚Äî remove_read_fn","text":"","code":"# Set proportional failure thresholds # to the `warn`, `stop`, and `notify` # states using `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Create an agent that directly ingests # the `small_table` object and also has # a table-prep formula (when both are # present the latter always obtains the # table); apply the actions, add some # validation steps and then interrogate # the data that was read in agent_1 <-    create_agent(     tbl = small_table,     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate()    # In a situation where `small_table` # changes frequently and it's desirable # to have a snapshot of the table, we # can remove the table-prep formula so # that the ingested `small_table` will # be used agent_2 <-   agent_1 %>%   remove_read_fn() %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_steps.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove one or more of an agent's validation steps ‚Äî remove_steps","title":"Remove one or more of an agent's validation steps ‚Äî remove_steps","text":"Validation steps can removed agent object use remove_steps() function. useful, instance, getting agent disk (via x_read_disk() function) omitting one steps agent's validation plan. Please note removing validation steps stored data extracts removed agent.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_steps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove one or more of an agent's validation steps ‚Äî remove_steps","text":"","code":"remove_steps(agent, i = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_steps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove one or more of an agent's validation steps ‚Äî remove_steps","text":"agent agent object class ptblank_agent. validation step number, assigned validation step order definition. NULL (default) step removal occur index.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_steps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove one or more of an agent's validation steps ‚Äî remove_steps","text":"ptblank_agent object. ptblank_agent object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_steps.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Remove one or more of an agent's validation steps ‚Äî remove_steps","text":"9-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_steps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove one or more of an agent's validation steps ‚Äî remove_steps","text":"","code":"# Create an agent that has the # `small_table` object as the # target table, add a few # validation steps, and then use # `interrogate()` agent_1 <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%   col_exists(vars(date)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]\"   ) %>%   interrogate()    # The second validation step has # been determined to be unneeded and # is to be removed; this can be done # by used `remove_steps()` with the # agent object agent_2 <-   agent_1 %>%   remove_steps(i = 2) %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove a data table associated with an agent or informant ‚Äî remove_tbl","title":"Remove a data table associated with an agent or informant ‚Äî remove_tbl","text":"Removing agent informant's association data table can done remove_tbl() function. can useful ensure table data unintentionally written disk. usually best avoid directly associating table agent informant tbl argument, instead opting setting table-prep formula (via create_agent() create_informant()'s read_fn argument, , set_read_fn()). necessary, association table can set set_tbl().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove a data table associated with an agent or informant ‚Äî remove_tbl","text":"","code":"remove_tbl(x)"},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove a data table associated with an agent or informant ‚Äî remove_tbl","text":"x agent object class ptblank_agent, , informant class ptblank_informant.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Remove a data table associated with an agent or informant ‚Äî remove_tbl","text":"9-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/remove_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove a data table associated with an agent or informant ‚Äî remove_tbl","text":"","code":"# Set proportional failure thresholds # to the `warn`, `stop`, and `notify` # states using `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Create an agent that has # `small_table` set as the target # table via `tbl`; apply the actions, # add some validation steps and then # interrogate the data agent_1 <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate()    # In this case where `small_table` # changes (and the aim is to have # validations run periodically) it is # better to obtain the table from the # source with a table-prep formula; # while doing this, the direct # association to `small_table` can be # removed with `remove_tbl()` so it's # no longer part of the agent object agent_2 <-   agent_1 %>%   remove_tbl() %>%   set_read_fn(read_fn = ~ small_table) %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/reference/row_count_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Does the row count match that of a different table? ‚Äî row_count_match","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"row_count_match() validation function, expect_row_count_match() expectation function, test_row_count_match() test function check whether row count target table matches comparison table. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation, single test unit hinges whether row counts two tables (preconditions applied).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/row_count_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"","code":"row_count_match(   x,   tbl_compare,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_row_count_match(   object,   tbl_compare,   preconditions = NULL,   threshold = 1 )  test_row_count_match(object, tbl_compare, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/row_count_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). tbl_compare table compare target table terms row count values. can either table object, table-prep formula.can table object data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, table-prep formula (~ <table reading code>) function (function() <table reading code>) can used lazily read table interrogation time. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/row_count_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/row_count_match.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires operation target table row count comparison takes place. Using preconditions can useful times since since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed. Alternatively, function instead supplied.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/row_count_match.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/row_count_match.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/row_count_match.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/row_count_match.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). row_count_match() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call row_count_match() validation step expressed R code corresponding YAML representation. practice, often shorter. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    row_count_match(     tbl_compare = ~ file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       ),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `row_count_match()` step.\",     active = FALSE   )  # YAML representation steps: - row_count_match:     tbl_compare: ~ file_tbl(       file = from_github(         file = \"all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       )     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `row_count_match()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/row_count_match.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"2-31","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/row_count_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Does the row count match that of a different table? ‚Äî row_count_match","text":"","code":"# Create a simple table with three # columns and four rows of values tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5),     b = c(7, 1, 0, 0),     c = c(1, 1, 1, 3)   )  # Create a second table which is # quite different but has the # same number of rows as `tbl` tbl_2 <-   dplyr::tibble(     e = c(\"a\", NA, \"a\", \"c\"),     f = c(2.6, 1.2, 0, NA)   )  # Validate that when considering only # data in columns `a` and `b`, there # are only complete rows (i.e., all # rows have no `NA` values) agent <-   create_agent(tbl = tbl) %>%   row_count_match(tbl_compare = tbl_2) %>%   interrogate()  # Determine if this validation passed # by using `all_passed()` all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_complete.html","id":null,"dir":"Reference","previous_headings":"","what":"Are row data complete? ‚Äî rows_complete","title":"Are row data complete? ‚Äî rows_complete","text":"rows_complete() validation function, expect_rows_complete() expectation function, test_rows_complete() test function check whether rows contain NA/NULL values (optionally constrained selection specified columns). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation, operate number test units equal number rows table (preconditions applied). can specify constraining column names quotes, vars(), following tidyselect helper functions: starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_complete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are row data complete? ‚Äî rows_complete","text":"","code":"rows_complete(   x,   columns = NULL,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_rows_complete(   object,   columns = NULL,   preconditions = NULL,   threshold = 1 )  test_rows_complete(object, columns = NULL, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_complete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are row data complete? ‚Äî rows_complete","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_complete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are row data complete? ‚Äî rows_complete","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_complete.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are row data complete? ‚Äî rows_complete","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_complete.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are row data complete? ‚Äî rows_complete","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_complete.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are row data complete? ‚Äî rows_complete","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_complete.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are row data complete? ‚Äî rows_complete","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_complete.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are row data complete? ‚Äî rows_complete","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). rows_complete() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call rows_complete() validation step expressed R code corresponding YAML representation. practice, often shorter. value columns necessary checking unique values across subset columns. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    rows_complete(     columns = vars(a, b),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `rows_complete()` step.\",     active = FALSE   )  # YAML representation steps: - rows_complete:     columns: vars(a, b)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `rows_complete()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_complete.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are row data complete? ‚Äî rows_complete","text":"2-21","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_complete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are row data complete? ‚Äî rows_complete","text":"","code":"# Create a simple table with three # columns of numerical values tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 8, 3),     c = c(1, 1, 1, 3, 3, 3)   )  # Validate that when considering only # data in columns `a` and `b`, there # are only complete rows (i.e., all # rows have no `NA` values) agent <-   create_agent(tbl = tbl) %>%   rows_complete(vars(a, b)) %>%   interrogate()  # Determine if these column # validations have all passed # by using `all_passed()` all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_distinct.html","id":null,"dir":"Reference","previous_headings":"","what":"Are row data distinct? ‚Äî rows_distinct","title":"Are row data distinct? ‚Äî rows_distinct","text":"rows_distinct() validation function, expect_rows_distinct() expectation function, test_rows_distinct() test function check whether row values (optionally constrained selection specified columns) , taken complete unit, distinct units table. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation, operate number test units equal number rows table (preconditions applied). can specify constraining column names quotes, vars(), following tidyselect helper functions: starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_distinct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are row data distinct? ‚Äî rows_distinct","text":"","code":"rows_distinct(   x,   columns = NULL,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_rows_distinct(   object,   columns = NULL,   preconditions = NULL,   threshold = 1 )  test_rows_distinct(object, columns = NULL, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_distinct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are row data distinct? ‚Äî rows_distinct","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). columns column (set columns, provided character vector) validation applied. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_distinct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are row data distinct? ‚Äî rows_distinct","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_distinct.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are row data distinct? ‚Äî rows_distinct","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_distinct.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are row data distinct? ‚Äî rows_distinct","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_distinct.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are row data distinct? ‚Äî rows_distinct","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_distinct.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are row data distinct? ‚Äî rows_distinct","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_distinct.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are row data distinct? ‚Äî rows_distinct","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). rows_distinct() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call rows_distinct() validation step expressed R code corresponding YAML representation. practice, often shorter. value columns necessary checking unique values across subset columns. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    rows_distinct(     columns = vars(a, b),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `rows_distinct()` step.\",     active = FALSE   )  # YAML representation steps: - rows_distinct:     columns: vars(a, b)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `rows_distinct()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_distinct.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are row data distinct? ‚Äî rows_distinct","text":"2-20","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/rows_distinct.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are row data distinct? ‚Äî rows_distinct","text":"","code":"# Create a simple table with three # columns of numerical values tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 8, 3),     c = c(1, 1, 1, 3, 3, 3)   )  # Validate that when considering only # data in columns `a` and `b`, there # are no duplicate rows (i.e., all # rows are distinct) agent <-   create_agent(tbl = tbl) %>%   rows_distinct(vars(a, b)) %>%   interrogate()  # Determine if these column # validations have all passed # by using `all_passed()` all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/scan_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Thoroughly scan a table to better understand it ‚Äî scan_data","title":"Thoroughly scan a table to better understand it ‚Äî scan_data","text":"Generate HTML report scours input table data. calling agent validate data, good idea understand data level precision. Make initial step well-balanced data quality reporting workflow. reporting output contains several sections make everything digestible, : Overview Table dimensions, duplicate row counts, column types, reproducibility information Variables summary table variable statistics summaries depending variable type Interactions matrix plot shows interactions variables Correlations set correlation matrix plots numerical variables Missing Values summary figure shows degree missingness across variables Sample table provides head tail rows dataset output HTML report appear RStudio Viewer can also integrated R Markdown HTML output. need output HTML string, possible get using .character() (e.g., scan_data(tbl = mtcars) %>% .character()). resulting HTML string complete HTML document Bootstrap jQuery embedded within.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/scan_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Thoroughly scan a table to better understand it ‚Äî scan_data","text":"","code":"scan_data(   tbl,   sections = \"OVICMS\",   navbar = TRUE,   width = NULL,   lang = NULL,   locale = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/reference/scan_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Thoroughly scan a table to better understand it ‚Äî scan_data","text":"tbl input table. can data frame, tibble, tbl_dbi object, tbl_spark object. sections sections include finalized Table Scan report. string key characters representing section names required . default string \"OVICMS\" wherein letter stands following sections default order: \"O\": \"overview\"; \"V\": \"variables\"; \"\": \"interactions\"; \"C\": \"correlations\"; \"M\": \"missing\"; \"S\": \"sample\". string can comprised less characters order can changed suit desired layout report. tbl_dbi tbl_spark objects supplied tbl, \"interactions\" \"correlations\" sections currently excluded. navbar navigation bar anchored top report page? default TRUE. width optional fixed width (pixels) HTML report. default, fixed width applied. lang language use label text report. default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"),  Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). locale optional locale ID use formatting values report according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\").","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/scan_data.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Thoroughly scan a table to better understand it ‚Äî scan_data","text":"1-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/scan_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Thoroughly scan a table to better understand it ‚Äî scan_data","text":"","code":"if (interactive()) {  # Get an HTML document that describes all of # the data in the `dplyr::storms` dataset tbl_scan <- scan_data(tbl = dplyr::storms)  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/serially.html","id":null,"dir":"Reference","previous_headings":"","what":"Run several tests and a final validation in a serial manner ‚Äî serially","title":"Run several tests and a final validation in a serial manner ‚Äî serially","text":"serially() validation function allows series tests run sequence either culminating final validation step simply exiting series. construction allows pre-testing may make sense validation step. example, may situations vital check column type performing validation column (since wrong type can result evaluation error subsequent validation). Another serial workflow might entail bundle checks prescribed order , pass, goal testing achieved (e.g., checking table matches another series increasingly specific tests). series specified inside serially() composed listing calls, draw upon test functions (T) describe tests optionally provide finalizing call validation function (V). following constraints apply: must least one test function series (T -> V good, V ) can one validation function call, V; optional , included, must placed end (T -> T -> V good, sequences bad: (1) T -> V -> T, (2) T -> T -> V -> V) validation function call (V), included, yield multiple validation steps (may happen providing multiple columns segments) example arrange expressions: series concentrates column called count first checks whether column exists, checks column numeric, finally validates whether values column greater 2. Note listing calls, . stands target table always necessary . Also important test_*() functions threshold argument set 1 default. need bump threshold value can changed different integer value (absolute threshold failing test units) decimal value 0 1 (serving fractional threshold failing test units).","code":"~ test_col_exists(., columns = vars(count)), ~ test_col_is_numeric(., columns = vars(count)), ~ col_vals_gt(., columns = vars(count), value = 2)"},{"path":"https://rich-iannone.github.io/pointblank/reference/serially.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run several tests and a final validation in a serial manner ‚Äî serially","text":"","code":"serially(   x,   ...,   .list = list2(...),   preconditions = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_serially(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )  test_serially(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )"},{"path":"https://rich-iannone.github.io/pointblank/reference/serially.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run several tests and a final validation in a serial manner ‚Äî serially","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). ... collection one-sided formulas consist test_*() function calls (e.g., test_col_vals_between(), etc.) arranged sequence intended interrogation order. Typically, validations final one threshold value set (default 1) short circuiting within series. finishing validation function call (e.g., col_vals_increasing(), etc.) can optionally inserted end series, serving validation step undergoes interrogation prior tests adequately pass. example ~ test_column_exists(., vars()), ~ col_vals_not_null(., vars())). .list Allows use list input alternative .... preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/serially.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run several tests and a final validation in a serial manner ‚Äî serially","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/serially.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Run several tests and a final validation in a serial manner ‚Äî serially","text":"providing multiple column names supplied validation steps, result expansion sub-validation steps number column names. Aside column names quotes vars(), tidyselect helper functions available specifying columns. : starts_with(), ends_with(), contains(), matches(), everything().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/serially.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Run several tests and a final validation in a serial manner ‚Äî serially","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/serially.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Run several tests and a final validation in a serial manner ‚Äî serially","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/serially.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Run several tests and a final validation in a serial manner ‚Äî serially","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/serially.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Run several tests and a final validation in a serial manner ‚Äî serially","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). serially() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call serially() validation step expressed R code corresponding YAML representation. practice, often shorter expressions validation steps necessary. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    serially(     ~ col_vals_lt(., vars(a), 8),     ~ col_vals_gt(., vars(c), vars(a)),     ~ col_vals_not_null(., vars(b)),     preconditions = ~ . %>% dplyr::filter(a < 10),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),      label = \"The `serially()` step.\",     active = FALSE   )  # YAML representation steps: - serially:     fns:     - ~col_vals_lt(., vars(a), 8)     - ~col_vals_gt(., vars(c), vars(a))     - ~col_vals_not_null(., vars(b))     preconditions: ~. %>% dplyr::filter(a < 10)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `serially()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/serially.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Run several tests and a final validation in a serial manner ‚Äî serially","text":"2-33","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/serially.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run several tests and a final validation in a serial manner ‚Äî serially","text":"","code":"# For all examples here, we'll use # a simple table with three numeric # columns (`a`, `b`, and `c`); this is # a very basic table but it'll be more # useful when explaining things later tbl <-   dplyr::tibble(     a = c(5, 2, 6),     b = c(6, 4, 9),     c = c(1, 2, 3)   )    tbl #> # A tibble: 3 √ó 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     6     1 #> 2     2     4     2 #> 3     6     9     3    # A: Using an `agent` with validation #    functions and then `interrogate()`  # The `serially()` function can be set # up to perform a series of tests and # then perform a validation (only if # all tests pass); here, we are going # to (1) test whether columns `a` and # `b` are numeric, (2) check that both # don't have any `NA` values, and (3) # perform a finalizing validation that # checks whether values in `b` are # greater than values in `a` agent_1 <-   create_agent(tbl = tbl) %>%   serially(     ~ test_col_is_numeric(., vars(a, b)),     ~ test_col_vals_not_null(., vars(a, b)),     ~ col_vals_gt(., vars(b), vars(a))     ) %>%   interrogate()    # Determine if this validation # had no failing test units (there are # are 4 tests and a final validation) all_passed(agent_1) #> [1] TRUE  # Calling `agent` in the console # prints the agent's report; but we # can get a `gt_tbl` object directly # with `get_agent_report(agent_1)`  # What's going on? All four of the tests # passed and so the final validation # occurred; there were no failing test # units in that either!  # The final validation is optional; here # is a different agent where only the # serial tests are performed agent_2 <-   create_agent(tbl = tbl) %>%   serially(     ~ test_col_is_numeric(., vars(a, b)),     ~ test_col_vals_not_null(., vars(a, b))   ) %>%   interrogate()    # Everything is good here too: all_passed(agent_2) #> [1] TRUE  # B: Using the validation function #    directly on the data (no `agent`)  # This way of using validation functions # acts as a data filter: data is passed # through but should `stop()` if there # is a single test unit failing; the # behavior of side effects can be # customized with the `actions` option tbl %>%   serially(     ~ test_col_is_numeric(., vars(a, b)),     ~ test_col_vals_not_null(., vars(a, b)),     ~ col_vals_gt(., vars(b), vars(a))   ) #> # A tibble: 3 √ó 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     6     1 #> 2     2     4     2 #> 3     6     9     3  # C: Using the expectation function  # With the `expect_*()` form, we would # typically perform one validation at a # time; this is primarily used in # testthat tests expect_serially(   tbl,   ~ test_col_is_numeric(., vars(a, b)),   ~ test_col_vals_not_null(., vars(a, b)),   ~ col_vals_gt(., vars(b), vars(a)) )  # D: Using the test function  # With the `test_*()` form, we should # get a single logical value returned # to us tbl %>%   test_serially(     ~ test_col_is_numeric(., vars(a, b)),     ~ test_col_vals_not_null(., vars(a, b)),     ~ col_vals_gt(., vars(b), vars(a))   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/set_read_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Set a table-prep formula to an agent or informant ‚Äî set_read_fn","title":"Set a table-prep formula to an agent or informant ‚Äî set_read_fn","text":"table-prep formula can associated agent informant set_read_fn(). tbl read_fn associated agent informant, read_fn take priority. can specify value read_fn RHS formula expression (e.g., ~ { <table reading code> }). table-prep formula can removed remove_read_fn() replaced set_read_fn().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/set_read_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set a table-prep formula to an agent or informant ‚Äî set_read_fn","text":"","code":"set_read_fn(x, read_fn)"},{"path":"https://rich-iannone.github.io/pointblank/reference/set_read_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set a table-prep formula to an agent or informant ‚Äî set_read_fn","text":"x agent object class ptblank_agent, , informant class ptblank_informant. read_fn R formula expression (e.g., ~ { <table reading code> }) used prepare table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/set_read_fn.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Set a table-prep formula to an agent or informant ‚Äî set_read_fn","text":"9-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/set_read_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set a table-prep formula to an agent or informant ‚Äî set_read_fn","text":"","code":"# Set proportional failure thresholds # to the `warn`, `stop`, and `notify` # states using `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Create an agent that reads in # `small_table` with a table-prep # formula; apply the actions, # add some validation steps and then # interrogate the data agent_1 <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate()    # Change the table-prep formula to use # a mutated version of `small_table` # (one that removes duplicate rows); # then, interrogate the target table # again agent_2 <-   agent_1 %>%   set_read_fn(     read_fn = ~ small_table %>% dplyr::distinct()   ) %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/reference/set_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Set a data table to an agent or informant ‚Äî set_tbl","title":"Set a data table to an agent or informant ‚Äî set_tbl","text":"Setting data table agent informant set_tbl() replaces associated table (data frame, tibble, objects class tbl_dbi tbl_spark). data table associated agent informant tbl argument object table-prep formula (settable create_agent() create_informant()'s read_fn argument set_read_fn()), table-prep formula take precedence. undesirable, removed remove_read_fn() function. association table can removed remove_tbl().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/set_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set a data table to an agent or informant ‚Äî set_tbl","text":"","code":"set_tbl(x, tbl)"},{"path":"https://rich-iannone.github.io/pointblank/reference/set_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set a data table to an agent or informant ‚Äî set_tbl","text":"x agent object class ptblank_agent, , informant class ptblank_informant. tbl input table agent. can data frame, tibble, tbl_dbi object, tbl_spark object. table already associated agent informant overwritten.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/set_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Set a data table to an agent or informant ‚Äî set_tbl","text":"9-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/set_tbl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set a data table to an agent or informant ‚Äî set_tbl","text":"","code":"# Set proportional failure thresholds # to the `warn`, `stop`, and `notify` # states using `action_levels()` al <-    action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   )  # Create an agent that has # `small_table` set as the target # table via `tbl`; apply the actions, # add some validation steps and then # interrogate the data agent_1 <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate()    # Replace the agent's association to # `small_table` with a mutated version # of it (one that removes duplicate rows); # then, interrogate the new target table agent_2 <-   agent_1 %>%   set_tbl(     tbl = small_table %>% dplyr::distinct()   ) %>%   interrogate()"},{"path":"https://rich-iannone.github.io/pointblank/reference/small_table.html","id":null,"dir":"Reference","previous_headings":"","what":"A small table that is useful for testing ‚Äî small_table","title":"A small table that is useful for testing ‚Äî small_table","text":"small table different types columns. probably just useful testing functions pointblank. Rows 9 10 exact duplicates. c column contains two NA values.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/small_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A small table that is useful for testing ‚Äî small_table","text":"","code":"small_table"},{"path":"https://rich-iannone.github.io/pointblank/reference/small_table.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A small table that is useful for testing ‚Äî small_table","text":"tibble 13 rows 8 variables: date_time date-time column (POSIXct class) dates correspond exactly date column. Time values somewhat randomized 'seconds' values 00. date Date column dates 2016-01-04 2016-01-30. integer column values ranging 1 8. b character column values adhere common pattern. c integer column values ranging 2 9. Contains two NA values. d numeric column values ranging 108 10000. e logical column. f character column \"low\", \"mid\", \"high\" values.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/small_table.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A small table that is useful for testing ‚Äî small_table","text":"14-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/small_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A small table that is useful for testing ‚Äî small_table","text":"","code":"# Here is a glimpse at the data # available in `small_table` dplyr::glimpse(small_table) #> Rows: 13 #> Columns: 8 #> $ date_time <dttm> 2016-01-04 11:00:00, 2016-01-04 00:32:00, 2016-01-05 13:32:‚Ä¶ #> $ date      <date> 2016-01-04, 2016-01-04, 2016-01-05, 2016-01-06, 2016-01-09,‚Ä¶ #> $ a         <int> 2, 3, 6, 2, 8, 4, 7, 4, 3, 3, 4, 2, 1 #> $ b         <chr> \"1-bcd-345\", \"5-egh-163\", \"8-kdg-938\", \"5-jdo-903\", \"3-ldm-0‚Ä¶ #> $ c         <dbl> 3, 8, 3, NA, 7, 4, 3, 2, 9, 9, 7, 8, NA #> $ d         <dbl> 3423.29, 9999.99, 2343.23, 3892.40, 283.94, 3291.03, 843.34,‚Ä¶ #> $ e         <lgl> TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, FAL‚Ä¶ #> $ f         <chr> \"high\", \"low\", \"high\", \"mid\", \"low\", \"mid\", \"high\", \"low\", \"‚Ä¶"},{"path":"https://rich-iannone.github.io/pointblank/reference/small_table_sqlite.html","id":null,"dir":"Reference","previous_headings":"","what":"An SQLite version of the small_table dataset ‚Äî small_table_sqlite","title":"An SQLite version of the small_table dataset ‚Äî small_table_sqlite","text":"small_table_sqlite() function creates SQLite, tbl_dbi version small_table dataset. requirement availability DBI RSQLite packages. packages can installed using install.packages(\"DBI\") install.packages(\"RSQLite\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/small_table_sqlite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An SQLite version of the small_table dataset ‚Äî small_table_sqlite","text":"","code":"small_table_sqlite()"},{"path":"https://rich-iannone.github.io/pointblank/reference/small_table_sqlite.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"An SQLite version of the small_table dataset ‚Äî small_table_sqlite","text":"14-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/small_table_sqlite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"An SQLite version of the small_table dataset ‚Äî small_table_sqlite","text":"","code":"# Use `small_table_sqlite()` to # create an SQLite version of the # `small_table` table # # small_table_sqlite <- small_table_sqlite()"},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_highest.html","id":null,"dir":"Reference","previous_headings":"","what":"A fn for info_snippet(): get the highest value from a column ‚Äî snip_highest","title":"A fn for info_snippet(): get the highest value from a column ‚Äî snip_highest","text":"snip_lowest() function can used info_snippet() function (.e., provided fn) get highest numerical, time value, alphabetical value column target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_highest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A fn for info_snippet(): get the highest value from a column ‚Äî snip_highest","text":"","code":"snip_highest(column)"},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_highest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A fn for info_snippet(): get the highest value from a column ‚Äî snip_highest","text":"column name column contains target values.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_highest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A fn for info_snippet(): get the highest value from a column ‚Äî snip_highest","text":"formula needed info_snippet()'s fn argument.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_highest.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A fn for info_snippet(): get the highest value from a column ‚Äî snip_highest","text":"3-9","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_highest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A fn for info_snippet(): get the highest value from a column ‚Äî snip_highest","text":"","code":"# Generate an informant object, add # a snippet with `info_snippet()` # and `snip_highest()` (giving us a # method to get the highest value in # column `a`); define a location for # the snippet result in `{ }` and # then `incorporate()` the snippet # into the info text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%    info_columns(     columns = \"a\",     `Highest Value` = \"Highest value is {highest_a}.\"   ) %>%   info_snippet(     snippet_name = \"highest_a\",     fn = snip_highest(column = \"a\")   ) %>%   incorporate() #>  #> ‚îÄ‚îÄ Incorporation Started - there is a single snippet to process ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚úî Information gathered. #> ‚úî Snippets processed. #> ‚úî Information built. #>  #> ‚îÄ‚îÄ Incorporation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # We can print the `informant` object # to see the information report"},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_list.html","id":null,"dir":"Reference","previous_headings":"","what":"A fn for info_snippet(): get a list of column categories ‚Äî snip_list","title":"A fn for info_snippet(): get a list of column categories ‚Äî snip_list","text":"snip_list() function can used info_snippet() function (.e., provided fn) get catalog list table column. can limit items list limit value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A fn for info_snippet(): get a list of column categories ‚Äî snip_list","text":"","code":"snip_list(   column,   limit = 5,   sorting = c(\"inorder\", \"infreq\", \"inseq\"),   reverse = FALSE,   sep = \",\",   and_or = NULL,   oxford = TRUE,   as_code = TRUE,   quot_str = NULL,   lang = NULL )"},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A fn for info_snippet(): get a list of column categories ‚Äî snip_list","text":"column name column contains target values. limit limit items put generated list. returned text state remaining number items beyond limit. default, limit 5. sorting keyword used designate type sorting use list. three options \"inorder\" (default), \"infreq\", \"inseq\". \"inorder\", distinct items listed order firsts appear. Using \"infreq\" orders items decreasing frequency item. \"inseq\" option applies alphanumeric sorting distinct list items. reverse option reverse ordering list items. default, FALSE using TRUE reverse items applying limit. sep separator use list items. default, comma. and_or type conjunction use final penultimate list items (item length limit value). NULL (default) used, '' conjunction used. Alternatively, following keywords can used: \"\", \"\", empty string (conjunction ). oxford Whether use Oxford comma certain conditions. default, TRUE. as_code list item appear 'code font' (.e., monospaced text)? default TRUE. Using FALSE keeps list items font rest information report. quot_str option whether list items set double quotes. NULL (default), quotation marks mainly associated list items derived character factor values; numbers, dates, logical values quotation marks. can explicitly use quotations () either TRUE FALSE . lang language use joining words (and_or option) additional words generated list string. default, NULL use whichever lang setting available parent informant object (settable create_informant() lang argument). specified override, language options English (\"en\"), French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A fn for info_snippet(): get a list of column categories ‚Äî snip_list","text":"formula needed info_snippet()'s fn argument.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_list.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A fn for info_snippet(): get a list of column categories ‚Äî snip_list","text":"3-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A fn for info_snippet(): get a list of column categories ‚Äî snip_list","text":"","code":"# Generate an informant object, add # a snippet with `info_snippet()` # and `snip_list()` (giving us a # method to get a distinct list of # column values for column `f`); # define a location for the snippet # result in `{ }` and then # `incorporate()` the snippet into # the info text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%    info_columns(     columns = \"f\",     `Items` = \"This column contains {values_f}.\"   ) %>%   info_snippet(     snippet_name = \"values_f\",     fn = snip_list(column = \"f\")   ) %>%   incorporate() #>  #> ‚îÄ‚îÄ Incorporation Started - there is a single snippet to process ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚úî Information gathered. #> ‚úî Snippets processed. #> ‚úî Information built. #>  #> ‚îÄ‚îÄ Incorporation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # We can print the `informant` object # to see the information report"},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_lowest.html","id":null,"dir":"Reference","previous_headings":"","what":"A fn for info_snippet(): get the lowest value from a column ‚Äî snip_lowest","title":"A fn for info_snippet(): get the lowest value from a column ‚Äî snip_lowest","text":"snip_lowest() function can used info_snippet() function (.e., provided fn) get lowest numerical, time value, alphabetical value column target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_lowest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A fn for info_snippet(): get the lowest value from a column ‚Äî snip_lowest","text":"","code":"snip_lowest(column)"},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_lowest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A fn for info_snippet(): get the lowest value from a column ‚Äî snip_lowest","text":"column name column contains target values.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_lowest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A fn for info_snippet(): get the lowest value from a column ‚Äî snip_lowest","text":"formula needed info_snippet()'s fn argument.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_lowest.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A fn for info_snippet(): get the lowest value from a column ‚Äî snip_lowest","text":"3-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_lowest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A fn for info_snippet(): get the lowest value from a column ‚Äî snip_lowest","text":"","code":"# Generate an informant object, add # a snippet with `info_snippet()` # and `snip_lowest()` (giving us a # method to get the lowest value in # column `a`); define a location for # the snippet result in `{ }` and # then `incorporate()` the snippet # into the info text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%    info_columns(     columns = \"a\",     `Lowest Value` = \"Lowest value is {lowest_a}.\"   ) %>%   info_snippet(     snippet_name = \"lowest_a\",     fn = snip_lowest(column = \"a\")   ) %>%   incorporate() #>  #> ‚îÄ‚îÄ Incorporation Started - there is a single snippet to process ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚úî Information gathered. #> ‚úî Snippets processed. #> ‚úî Information built. #>  #> ‚îÄ‚îÄ Incorporation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # We can print the `informant` object # to see the information report"},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"A fn for info_snippet(): get an inline statistical summary ‚Äî snip_stats","title":"A fn for info_snippet(): get an inline statistical summary ‚Äî snip_stats","text":"snip_stats() function can used info_snippet() function (.e., provided fn) produce five- seven-number statistical summary. inline summary works well within paragraph text can help describing distribution numerical values column. given column, three different types inline statistical summaries can provided: five-number summary (\"5num\"): minimum, Q1, median, Q3, maximum seven-number summary (\"7num\"): P2, P9, Q1, median, Q3, P91, P98 Bowley's seven-figure summary (\"bowley\"): minimum, P10, Q1, median, Q3, P90, maximum","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A fn for info_snippet(): get an inline statistical summary ‚Äî snip_stats","text":"","code":"snip_stats(column, type = c(\"5num\", \"7num\", \"bowley\"))"},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A fn for info_snippet(): get an inline statistical summary ‚Äî snip_stats","text":"column name column contains target values. type type summary. default, \"5num\" keyword used generate five-number summary. Two options provide seven-number summaries: \"7num\" \"bowley\".","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A fn for info_snippet(): get an inline statistical summary ‚Äî snip_stats","text":"formula needed info_snippet()'s fn argument.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_stats.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A fn for info_snippet(): get an inline statistical summary ‚Äî snip_stats","text":"3-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/snip_stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A fn for info_snippet(): get an inline statistical summary ‚Äî snip_stats","text":"","code":"# Generate an informant object, add # a snippet with `info_snippet()` # and `snip_stats()` (giving us a # method to get some summary stats for # column `a`); define a location for # the snippet result in `{ }` and # then `incorporate()` the snippet # into the info text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%    info_columns(     columns = \"a\",     `Stats` = \"Stats (fivenum): {stats_a}.\"   ) %>%   info_snippet(     snippet_name = \"stats_a\",     fn = snip_stats(column = \"a\")   ) %>%   incorporate() #>  #> ‚îÄ‚îÄ Incorporation Started - there is a single snippet to process ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚úî Information gathered. #> ‚úî Snippets processed. #> ‚úî Information built. #>  #> ‚îÄ‚îÄ Incorporation Completed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  # We can print the `informant` object # to see the information report"},{"path":"https://rich-iannone.github.io/pointblank/reference/specially.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform a specialized validation with a user-defined function ‚Äî specially","title":"Perform a specialized validation with a user-defined function ‚Äî specially","text":"specially() validation function allows custom validation function provide. major proviso provided function must either return logical vector table final column logical. function operate table object, , can whatever like, also operate types objects. , can transform input table preconditions inject entirely different object . interrogation, checks ensure data table object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/specially.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform a specialized validation with a user-defined function ‚Äî specially","text":"","code":"specially(   x,   fn,   preconditions = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_specially(object, fn, preconditions = NULL, threshold = 1)  test_specially(object, fn, preconditions = NULL, threshold = 1)"},{"path":"https://rich-iannone.github.io/pointblank/reference/specially.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform a specialized validation with a user-defined function ‚Äî specially","text":"x data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent created create_agent(). fn function performs specialized validation data. must either return logical vector table last column logical column. preconditions optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. actions list containing threshold levels validation step can react accordingly exceeding set levels. created action_levels() helper function. step_id One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label optional label validation step. label appears agent report best appearance kept short. brief optional, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(vars(d, e))). default active TRUE. object data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/specially.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform a specialized validation with a user-defined function ‚Äî specially","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/specially.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Perform a specialized validation with a user-defined function ‚Äî specially","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. Within specially(), function special, internal checking whether preconditions-based output table. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/specially.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Perform a specialized validation with a user-defined function ‚Äî specially","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/specially.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Perform a specialized validation with a user-defined function ‚Äî specially","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/specially.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Perform a specialized validation with a user-defined function ‚Äî specially","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). serially() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call serially() validation step expressed R code corresponding YAML representation. practice, often shorter expressions validation steps necessary. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"# R statement agent %>%    specially(     fn = function(x) { ... },     preconditions = ~ . %>% dplyr::filter(a < 10),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),      label = \"The `specially()` step.\",     active = FALSE   )  # YAML representation steps: - specially:     fn: function(x) { ... }     preconditions: ~. %>% dplyr::filter(a < 10)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `specially()` step.     active: false"},{"path":"https://rich-iannone.github.io/pointblank/reference/specially.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Perform a specialized validation with a user-defined function ‚Äî specially","text":"2-34","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/specifications.html","id":null,"dir":"Reference","previous_headings":"","what":"A table containing data pertaining to various specifications ‚Äî specifications","title":"A table containing data pertaining to various specifications ‚Äî specifications","text":"specifications dataset useful testing col_vals_within_spec(), test_col_vals_within_spec(), expect_col_vals_within_spec() functions. column, holding character values different specifications, rows 1-5 contain valid values, 6th row NA value, final two values (rows 7 8) invalid. Different specification (spec) keywords apply columns validating aforementioned functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/specifications.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A table containing data pertaining to various specifications ‚Äî specifications","text":"","code":"specifications"},{"path":"https://rich-iannone.github.io/pointblank/reference/specifications.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A table containing data pertaining to various specifications ‚Äî specifications","text":"tibble 8 rows 12 variables: isbn_numbers ISBN-13 numbers; can validated \"isbn\" specification. vin_numbers VIN numbers (identifiers motor vehicles); can validated \"vin\" specification. zip_codes Postal codes U.S.; can validated \"postal[USA]\" specification \"zip\" alias. credit_card_numbers Credit card numbers; can validated \"credit_card\" specification \"cc\" alias. iban_austria IBAN numbers Austrian accounts; can validated \"iban[AUT]\" specification. swift_numbers Swift-BIC numbers; can validated \"swift\" specification. phone_numbers Phone numbers; can validated \"phone\" specification. email_addresses Email addresses; can validated \"email\" specification. urls URLs; can validated  \"url\" specification. ipv4_addresses IPv4 addresses; can validated \"ipv4\" specification ipv6_addresses IPv6 addresses; can validated \"ipv6\" specification mac_addresses MAC addresses; can validated \"mac\" specification","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/specifications.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A table containing data pertaining to various specifications ‚Äî specifications","text":"14-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/specifications.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A table containing data pertaining to various specifications ‚Äî specifications","text":"","code":"# Here is a glimpse at the data # available in `specifications` dplyr::glimpse(specifications) #> Rows: 8 #> Columns: 12 #> $ isbn_numbers        <chr> \"978 1 85715 201 2\", \"978-1-84159-362-3\", \"978 1 8‚Ä¶ #> $ vin_numbers         <chr> \"4UZAANDH85CV12329\", \"JM1BL1S59A1134659\", \"1GCEK14‚Ä¶ #> $ zip_codes           <chr> \"99553\", \"36264\", \"71660\", \"85225\", \"90309\", NA, \"‚Ä¶ #> $ credit_card_numbers <chr> \"340000000000009\", \"378734493671000\", \"67034444444‚Ä¶ #> $ iban_austria        <chr> \"AT582774098454337653\", \"AT220332087576467472\", \"A‚Ä¶ #> $ swift_numbers       <chr> \"RBOSGGSX\", \"RZTIAT22263\", \"BCEELULL\", \"MARKDEFF\",‚Ä¶ #> $ phone_numbers       <chr> \"+5-555-555-5555\", \"+5 555 555 5555\", \"+5.555.555.‚Ä¶ #> $ email_addresses     <chr> \"test@test.com\", \"mail+mail@example.com\", \"mail.em‚Ä¶ #> $ urls                <chr> \"http://foo.com/blah_blah\", \"http://foo.com/blah_b‚Ä¶ #> $ ipv4_addresses      <chr> \"93.184.220.20\", \"161.148.172.130\", \"161.148.172.1‚Ä¶ #> $ ipv6_addresses      <chr> \"2001:0db8:0000:85a3:0000:0000:ac1f:8001\", \"2001:d‚Ä¶ #> $ mac_addresses       <chr> \"01-2d-4c-ef-89-ab\", \"01-2D-4C-EF-89-AB\", \"01:2d:4‚Ä¶"},{"path":"https://rich-iannone.github.io/pointblank/reference/stock_msg_body.html","id":null,"dir":"Reference","previous_headings":"","what":"Provide simple email message body components: body ‚Äî stock_msg_body","title":"Provide simple email message body components: body ‚Äî stock_msg_body","text":"stock_msg_body() function simply provides stock text email message sent via email_blast() obtained standalone object email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/stock_msg_body.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Provide simple email message body components: body ‚Äî stock_msg_body","text":"","code":"stock_msg_body()"},{"path":"https://rich-iannone.github.io/pointblank/reference/stock_msg_body.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Provide simple email message body components: body ‚Äî stock_msg_body","text":"Text suitable msg_body arguments email_blast() email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/stock_msg_body.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Provide simple email message body components: body ‚Äî stock_msg_body","text":"4-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/stock_msg_footer.html","id":null,"dir":"Reference","previous_headings":"","what":"Provide simple email message body components: footer ‚Äî stock_msg_footer","title":"Provide simple email message body components: footer ‚Äî stock_msg_footer","text":"stock_msg_footer() functions simply provide stock text email message sent via email_blast() obtained standalone object email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/stock_msg_footer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Provide simple email message body components: footer ‚Äî stock_msg_footer","text":"","code":"stock_msg_footer()"},{"path":"https://rich-iannone.github.io/pointblank/reference/stock_msg_footer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Provide simple email message body components: footer ‚Äî stock_msg_footer","text":"Text suitable msg_footer argument email_blast() email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/stock_msg_footer.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Provide simple email message body components: footer ‚Äî stock_msg_footer","text":"4-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/stop_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"The next generation of stopifnot()-type functions: stop_if_not() ‚Äî stop_if_not","title":"The next generation of stopifnot()-type functions: stop_if_not() ‚Äî stop_if_not","text":"stopifnot() twist: works well standalone, replacement stopifnot() also customized use validation checks R Markdown documents pointblank loaded. Using stop_if_not() code chunk validate = TRUE option set yield correct reporting successes failures whereas stopifnot() .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/stop_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The next generation of stopifnot()-type functions: stop_if_not() ‚Äî stop_if_not","text":"","code":"stop_if_not(...)"},{"path":"https://rich-iannone.github.io/pointblank/reference/stop_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The next generation of stopifnot()-type functions: stop_if_not() ‚Äî stop_if_not","text":"... R expressions evaluate (logical vector ) TRUE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/stop_if_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The next generation of stopifnot()-type functions: stop_if_not() ‚Äî stop_if_not","text":"NULL statements ... TRUE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/stop_if_not.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"The next generation of stopifnot()-type functions: stop_if_not() ‚Äî stop_if_not","text":"13-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/stop_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The next generation of stopifnot()-type functions: stop_if_not() ‚Äî stop_if_not","text":"","code":"# This checks whether the number of # rows in `small_table` is greater # than `10` stop_if_not(nrow(small_table) > 10) #> NULL  # This will stop for sure: there # isn't a `time` column in `small_table` # (but there are the `date_time` and # `date` columns) # stop_if_not(\"time\" %in% colnames(small_table))  # You're not bound to using tabular # data here, any statements that # evaluate to logical vectors will work stop_if_not(1 < 20:25 - 18) #> NULL"},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_get.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain a materialized table via a table store ‚Äî tbl_get","title":"Obtain a materialized table via a table store ‚Äî tbl_get","text":"tbl_get() function gives us means materialize table entry table store (.e., table-prep formula unique name). table store used can form tbl_store object (created tbl_store() function) -disk YAML representation table store (created using yaml_write() tbl_store object). want table-prep formula table store use value read_fn (create_agent(), create_informant(), set_read_fn()), look tbl_source() function.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_get.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain a materialized table via a table store ‚Äî tbl_get","text":"","code":"tbl_get(tbl, store = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_get.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain a materialized table via a table store ‚Äî tbl_get","text":"tbl table retrieve table store. table identified name (e.g., tbl = \"large_table\") supplying reference using subset ($) tbl_store object (e.g., tbl = store$large_table). using latter method nothing needs supplied store. store Either table store object created tbl_store() function path table store YAML file created yaml_write().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_get.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain a materialized table via a table store ‚Äî tbl_get","text":"table object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_get.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtain a materialized table via a table store ‚Äî tbl_get","text":"1-10","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_get.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain a materialized table via a table store ‚Äî tbl_get","text":"","code":"if (interactive()) {  # Define a `tbl_store` object by adding # table-prep formulas in `tbl_store()` tbls <-    tbl_store(     small_table_duck ~ db_tbl(       table = small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     ~ db_tbl(       table = \"rna\",       dbname = \"pfmegrnargs\",       dbtype = \"postgres\",       host = \"hh-pgsql-public.ebi.ac.uk\",       port = 5432,       user = I(\"reader\"),       password = I(\"NWDMCE5xdipIjRrp\")     ),     all_revenue ~ db_tbl(       table = file_tbl(         file = from_github(           file = \"all_revenue_large.rds\",           repo = \"rich-iannone/intendo\",           subdir = \"data-large\"         )       ),       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     sml_table ~ pointblank::small_table   )  # Once this object is available, you can # check that the table of interest is # produced to your specification tbl_get(   tbl = \"small_table_duck\",   store = tbls )  # An alternative method for getting the # same table materialized is by using `$` # to get the formula of choice from `tbls` tbls$small_table_duck %>% tbl_get()  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_source.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain a table-prep formula from a table store ‚Äî tbl_source","title":"Obtain a table-prep formula from a table store ‚Äî tbl_source","text":"tbl_source() function provides convenient means access table-prep formula either tbl_store object table store YAML file (can created yaml_write() function). call tbl_source() useful input read_fn argument create_agent(), create_informant(), set_read_fn(). need obtain table (generated via table-prep formula), tbl_get() function used .","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_source.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain a table-prep formula from a table store ‚Äî tbl_source","text":"","code":"tbl_source(tbl, store = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_source.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain a table-prep formula from a table store ‚Äî tbl_source","text":"tbl table name associated table-prep formula. part table store. table identified name (e.g., tbl = \"large_table\") supplying reference using subset ($) tbl_store object (e.g., tbl = store$large_table). using latter method nothing needs supplied store. store Either table store object created tbl_store() function path table store YAML file created yaml_write().","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_source.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain a table-prep formula from a table store ‚Äî tbl_source","text":"table-prep formula.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_source.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtain a table-prep formula from a table store ‚Äî tbl_source","text":"1-9","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_source.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain a table-prep formula from a table store ‚Äî tbl_source","text":"","code":"if (interactive()) {  # Let's create a `tbl_store` object by # giving two table-prep formulas to # `tbl_store()` tbls <-    tbl_store(     small_table_duck ~ db_tbl(       table = small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     sml_table ~ pointblank::small_table   )  # We can pass a table-prep formula # to `create_agent()` and interrogate # the table shortly thereafter agent <-    create_agent(     read_fn = ~ tbl_source(\"sml_table\", tbls),     label = \"An example that uses a table store.\",     actions = action_levels(warn_at = 0.10)   ) %>%    col_exists(vars(date, date_time)) %>%   interrogate()  # Both the `tbl_store` object and the # `agent` can be transformed to YAML with # the `yaml_write()` function  # This writes the `tbl_store.yml` file # by default (but a different name # could be used) yaml_write(tbls)  # Let's modify the agent's `read_fn` to point # to the YAML representation of the `tbl_store` agent <-   agent %>%    set_read_fn(     ~ tbl_source(         tbl = \"sml_table\",         store = \"tbl_store.yml\"       )   )  # Then we can write agent to a YAML # file (writes to `agent-sml_table.yml` # by default) yaml_write(agent)  # Now that both are in this on-disk format # an interrogation can be done by accessing # the agent YAML agent <-   yaml_agent_interrogate(     filename = \"agent-sml_table.yml\"   )  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_store.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a store of tables with table-prep formulas: a table store ‚Äî tbl_store","title":"Define a store of tables with table-prep formulas: a table store ‚Äî tbl_store","text":"can useful set data sources need just draw necessary. upfront configuration tbl_store() lets us define methods obtaining tabular data mixed sources (e.g., database tables, tables generated flat files, etc.) provide names data preparation procedures. convenient way access materialized tables tbl_get(), , table-prep formulas tbl_source(). Table-prep formulas can simple getting table location, , can involve much mutation necessary (imagine procuring several mutated variations source table, generating table multiple sources, pre-filtering database table according system time). Another nice aspect organizing table-prep formulas single object supplying read_fn argument create_agent() create_informant() via $ notation (e.g, create_agent(read_fn = <tbl_store>$<name>)) tbl_source() (e.g., create_agent(read_fn = ~ tbl_source(\"<name>\", <tbl_store>))).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_store.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a store of tables with table-prep formulas: a table store ‚Äî tbl_store","text":"","code":"tbl_store(..., .list = list2(...))"},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_store.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a store of tables with table-prep formulas: a table store ‚Äî tbl_store","text":"... Expressions contain table-prep formulas table names data retrieval. Two-sided formulas (e.g, <LHS> ~ <RHS>) used, left-hand side given name right-hand portion used obtain table. .list Allows use list input alternative ....","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_store.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a store of tables with table-prep formulas: a table store ‚Äî tbl_store","text":"tbl_store object contains table-prep formulas.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_store.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Define a store of tables with table-prep formulas: a table store ‚Äî tbl_store","text":"pointblank table store can written YAML yaml_write() resulting YAML can used several ways. ideal scenario pointblank agents informants also YAML form. way agent informant can refer table store YAML (via tbl_source()), , processing agents informants can performed yaml_agent_interrogate() yaml_informant_incorporate(). following R code, table store two table-prep formulas generated written YAML (filename given YAML written \"tbl_store.yml\"). useful want get fresh pulls prepared data source materialized R session (tbl_get() function. example, sml_table_high table can obtained using tbl_get(\"sml_table_high\", \"tbl_store.yml\"). get agent check prepared data periodically, following example tbl_source() useful: Now, whenever sml_table_high table needs validated, can done yaml_agent_interrogate() (e.g., yaml_agent_interrogate(\"agent-sml_table_high.yml\")).","code":"# R statement for generating the \"tbl_store.yml\" file tbl_store(   tbl_duckdb ~ db_tbl(small_table, dbname = \":memory:\", dbtype = \"duckdb\"),   sml_table_high ~ small_table %>% dplyr::filter(f == \"high\") ) %>%   yaml_write()  # YAML representation (\"tbl_store.yml\") tbls:   tbl_duckdb: ~ db_tbl(small_table, dbname = \":memory:\", dbtype = \"duckdb\")   sml_table_high: ~ small_table %>% dplyr::filter(f == \"high\") # Generate agent that checks `sml_table_high`, write it to YAML create_agent(   read_fn = ~ tbl_source(\"sml_table_high\", \"tbl_store.yml\"),   label = \"An example that uses a table store.\",   actions = action_levels(warn_at = 0.10) ) %>%    col_exists(vars(date, date_time)) %>%   write_yaml()    # YAML representation (\"agent-sml_table_high.yml\") read_fn: ~ tbl_source(\"sml_table_high\", \"tbl_store.yml\") tbl_name: sml_table_high label: An example that uses a table store. actions:   warn_fraction: 0.1 locale: en steps:   - col_exists:     columns: vars(date, date_time)"},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_store.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Define a store of tables with table-prep formulas: a table store ‚Äî tbl_store","text":"1-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/tbl_store.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a store of tables with table-prep formulas: a table store ‚Äî tbl_store","text":"","code":"if (interactive()) {  # Define a `tbl_store` object by adding # table-prep formulas inside the # `tbl_store()` call tbls <-    tbl_store(     small_table_duck ~ db_tbl(       table = small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     ~ db_tbl(       table = \"rna\",       dbname = \"pfmegrnargs\",       dbtype = \"postgres\",       host = \"hh-pgsql-public.ebi.ac.uk\",       port = 5432,       user = I(\"reader\"),       password = I(\"NWDMCE5xdipIjRrp\")     ),     all_revenue ~ db_tbl(       table = file_tbl(         file = from_github(           file = \"all_revenue_large.rds\",           repo = \"rich-iannone/intendo\",           subdir = \"data-large\"         )       ),       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     sml_table ~ pointblank::small_table   )  # Once this object is available, you # can check that the table of interest # is produced to your specification with # the `tbl_get()` function tbl_get(   tbl = \"small_table_duck\",   store = tbls )  # Another simpler way to get the same # table materialized is by using `$` to # get the entry of choice for `tbl_get()` tbls$small_table_duck %>% tbl_get()  # Creating an agent is easy when all # table-prep formulas are encapsulated # in a `tbl_store` object; use `$`  # notation to pass the appropriate # procedure for reading a table to the # `read_fn` argument agent_1 <-   create_agent(     read_fn = tbls$small_table_duck   )    # There are other ways to use the # table store to assign a target table # to an agent, like using the # `tbl_source()` function agent_2 <-   create_agent(     read_fn = ~ tbl_source(       tbl = \"small_table_duck\",       store = tbls       )   )  # The table store can be moved to # YAML with `yaml_write` and the # `tbl_source()` call could then # refer to that on-disk table store; # let's do that YAML conversion yaml_write(tbls)  # The above writes the `tbl_store.yml` # file (by not providing a `filename` # this default filename is chosen); # next, modify the `tbl_source()` # so that `store` refer to the YAML # file agent_3 <-   create_agent(     read_fn = ~ tbl_source(       tbl = \"small_table_duck\",       store = \"tbl_store.yml\"     )   )  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_string_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: obtain a summary table for string columns ‚Äî tt_string_info","title":"Table Transformer: obtain a summary table for string columns ‚Äî tt_string_info","text":"table object, can produce summary table scoped string-based columns. output summary table leading column called \".param.\" labels three rows, corresponding following pieces information pertaining string length: Mean String Length (\"length_mean\") Minimum String Length (\"length_min\") Maximum String Length (\"length_max\") string data input table generate columns output table. Column names input used output, preserving order well.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_string_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: obtain a summary table for string columns ‚Äî tt_string_info","text":"","code":"tt_string_info(tbl)"},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_string_info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: obtain a summary table for string columns ‚Äî tt_string_info","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_string_info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: obtain a summary table for string columns ‚Äî tt_string_info","text":"tibble object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_string_info.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: obtain a summary table for string columns ‚Äî tt_string_info","text":"12-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_string_info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: obtain a summary table for string columns ‚Äî tt_string_info","text":"","code":"# Get string information for the # string-based columns in the # `game_revenue` dataset tt_string_info(game_revenue) #> # A tibble: 3 √ó 7 #>   .param.     player_id session_id item_type item_name acquisition country #>   <chr>           <dbl>      <dbl>     <dbl>     <dbl>       <dbl>   <dbl> #> 1 length_mean        15         24      2.22      7.35        7.97    8.53 #> 2 length_min         15         24      2         5           5       5    #> 3 length_max         15         24      3        11          14      14     # Ensure that `player_id` and # `session_id` values always have # the same number of characters # throughout the table tt_string_info(game_revenue) %>%   col_vals_equal(     columns = vars(player_id),     value = 15   ) %>%   col_vals_equal(     columns = vars(session_id),     value = 24   ) #> # A tibble: 3 √ó 7 #>   .param.     player_id session_id item_type item_name acquisition country #>   <chr>           <dbl>      <dbl>     <dbl>     <dbl>       <dbl>   <dbl> #> 1 length_mean        15         24      2.22      7.35        7.97    8.53 #> 2 length_min         15         24      2         5           5       5    #> 3 length_max         15         24      3        11          14      14     # Check that the maximum string # length in column `f` of the # `small_table` dataset is no # greater than `4` tt_string_info(small_table) %>%   test_col_vals_lte(     columns = vars(f),     value = 4   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_summary_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: obtain a summary stats table for numeric columns ‚Äî tt_summary_stats","title":"Table Transformer: obtain a summary stats table for numeric columns ‚Äî tt_summary_stats","text":"table object, can produce summary table scoped numeric column values. output summary table leading column called \".param.\" labels nine rows, corresponding following summary statistics: Minimum (\"min\") 5th Percentile (\"p05\") 1st Quartile (\"q_1\") Median (\"med\") 3rd Quartile (\"q_3\") 95th Percentile (\"p95\") Maximum (\"max\") Interquartile Range (\"iqr\") Range (\"range\") numerical data input table generate columns output table. Column names input used output, preserving order well.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_summary_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: obtain a summary stats table for numeric columns ‚Äî tt_summary_stats","text":"","code":"tt_summary_stats(tbl)"},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_summary_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: obtain a summary stats table for numeric columns ‚Äî tt_summary_stats","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_summary_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: obtain a summary stats table for numeric columns ‚Äî tt_summary_stats","text":"tibble object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_summary_stats.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: obtain a summary stats table for numeric columns ‚Äî tt_summary_stats","text":"12-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_summary_stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: obtain a summary stats table for numeric columns ‚Äî tt_summary_stats","text":"","code":"# Get summary statistics for the # `game_revenue` dataset that is # included in the package tt_summary_stats(game_revenue) #> # A tibble: 9 √ó 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0                 3.2 #> 2 p05             0.02              8.2 #> 3 q_1             0.09             18.5 #> 4 med             0.38             26.5 #> 5 q_3             1.25             33.8 #> 6 p95            22.0              39.5 #> 7 max           143.               41   #> 8 iqr             1.16             15.3 #> 9 range         143.               37.8  # Ensure that the maximum revenue # for individual purchases in the # `game_revenue` table is less than # $150 tt_summary_stats(game_revenue) %>%   col_vals_lt(     columns = vars(item_revenue),     value = 150,     segments = .param. ~ \"max\"   ) #> # A tibble: 9 √ó 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0                 3.2 #> 2 p05             0.02              8.2 #> 3 q_1             0.09             18.5 #> 4 med             0.38             26.5 #> 5 q_3             1.25             33.8 #> 6 p95            22.0              39.5 #> 7 max           143.               41   #> 8 iqr             1.16             15.3 #> 9 range         143.               37.8  # For in-app purchases in the # `game_revenue` table, check that # median revenue is somewhere # between $8 and $12 game_revenue %>%    dplyr::filter(item_type == \"iap\") %>%   tt_summary_stats() %>%   col_vals_between(     columns = vars(item_revenue),     left = 8, right = 12,     segments = .param. ~ \"med\"   ) #> # A tibble: 9 √ó 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0.4              3.2  #> 2 p05             1.39             5.99 #> 3 q_1             4.49            14.0  #> 4 med            10.5             22.6  #> 5 q_3            20.3             30.6  #> 6 p95            66.0             38.8  #> 7 max           143.              41    #> 8 iqr            15.8             16.7  #> 9 range         143.              37.8   # While performing validations of the # `game_revenue` table with an agent # we can include the same revenue # check by using `tt_summary_stats()` # in the `preconditions` argument (this # will transform the target table for # the validation step); we also need # to get just a segment of that table # (the row with the median values) agent <-    create_agent(     read_fn = ~ game_revenue,     tbl_name = \"game_revenue\",     label = \"An example.\",     actions = action_levels(       warn_at = 0.10,       stop_at = 0.25,       notify_at = 0.35     )   ) %>%   rows_complete() %>%   rows_distinct() %>%   col_vals_between(     columns = vars(item_revenue),     left = 8, right = 12,     preconditions = ~ . %>%       dplyr::filter(item_type == \"iap\") %>%       tt_summary_stats(),     segments = .param. ~ \"med\"   ) %>%   interrogate()  # This should all pass but let's check: all_passed(agent) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_tbl_colnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: get a table's column names ‚Äî tt_tbl_colnames","title":"Table Transformer: get a table's column names ‚Äî tt_tbl_colnames","text":"table object, can produce summary table contains table's column names. output summary table two columns many rows columns input table. first column \".param.\" column, integer-based column containing indices columns input table. second column, \"value\", contains column names input table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_tbl_colnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: get a table's column names ‚Äî tt_tbl_colnames","text":"","code":"tt_tbl_colnames(tbl)"},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_tbl_colnames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: get a table's column names ‚Äî tt_tbl_colnames","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_tbl_colnames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: get a table's column names ‚Äî tt_tbl_colnames","text":"tibble object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_tbl_colnames.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: get a table's column names ‚Äî tt_tbl_colnames","text":"12-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_tbl_colnames.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: get a table's column names ‚Äî tt_tbl_colnames","text":"","code":"# Get the column names of the # `game_revenue` dataset that's # included in the package tt_tbl_colnames(game_revenue) #> # A tibble: 11 √ó 2 #>    .param. value            #>      <int> <chr>            #>  1       1 player_id        #>  2       2 session_id       #>  3       3 session_start    #>  4       4 time             #>  5       5 item_type        #>  6       6 item_name        #>  7       7 item_revenue     #>  8       8 session_duration #>  9       9 start_day        #> 10      10 acquisition      #> 11      11 country           # This output table is useful when # you want to validate the # column names of the table; here, # we check that `game_revenue` has # certain column names present tt_tbl_colnames(game_revenue) %>%   test_col_vals_make_subset(     columns = vars(value),     set = c(\"acquisition\", \"country\")   ) #> [1] TRUE  # We can check to see whether the # column names in the `specifications` # table are all less than 15 # characters in length specifications %>%   tt_tbl_colnames() %>%   tt_string_info() %>%   test_col_vals_lt(     columns = vars(value),     value = 15   ) #> [1] FALSE"},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_tbl_dims.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: get the dimensions of a table ‚Äî tt_tbl_dims","title":"Table Transformer: get the dimensions of a table ‚Äî tt_tbl_dims","text":"table object, can produce summary table contains nothing table's dimensions: number rows number columns. output summary table two columns two rows. first \".param.\" column labels \"rows\" \"columns\"; second column, \"value\", contains row column counts.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_tbl_dims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: get the dimensions of a table ‚Äî tt_tbl_dims","text":"","code":"tt_tbl_dims(tbl)"},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_tbl_dims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: get the dimensions of a table ‚Äî tt_tbl_dims","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_tbl_dims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: get the dimensions of a table ‚Äî tt_tbl_dims","text":"tibble object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_tbl_dims.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: get the dimensions of a table ‚Äî tt_tbl_dims","text":"12-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_tbl_dims.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: get the dimensions of a table ‚Äî tt_tbl_dims","text":"","code":"# Get the dimensions of the # `game_revenue` dataset that's # included in the package tt_tbl_dims(game_revenue) #> # A tibble: 2 √ó 2 #>   .param. value #>   <chr>   <int> #> 1 rows     2000 #> 2 columns    11  # This output table is useful when # you want to validate the # dimensions of the table; here, # we check that `game_revenue` has # at least 1500 rows tt_tbl_dims(game_revenue) %>%   dplyr::filter(.param. == \"rows\") %>%   test_col_vals_gt(     columns = vars(value),     value = 1500   ) #> [1] TRUE  # We can check `small_table` for # an exact number of columns (`8`) tt_tbl_dims(small_table) %>%   dplyr::filter(.param. == \"columns\") %>%   test_col_vals_equal(     columns = vars(value),     value = 8   ) #> [1] TRUE"},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: shift the times of a table ‚Äî tt_time_shift","title":"Table Transformer: shift the times of a table ‚Äî tt_time_shift","text":"table object containing date date-time columns, values can precisely shifted tt_time_shift() specification time shift. can either provide string time shift components shift direction (like \"-4y 10d\") difftime object (can created via lubridate expressions using base::difftime() function).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: shift the times of a table ‚Äî tt_time_shift","text":"","code":"tt_time_shift(tbl, time_shift = \"0y 0m 0d 0H 0M 0S\")"},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: shift the times of a table ‚Äî tt_time_shift","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object. time_shift Either character-based representation specifies time difference time values time-based columns shifted, , difftime object. character string constructed format \"0y 0m 0d 0H 0M 0S\" individual time components can omitted (.e., \"1y 5d\" valid specification shifting time values ahead one year five days). Adding \"-\" beginning string (e.g., \"-2y\") shift time values back.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: shift the times of a table ‚Äî tt_time_shift","text":"data frame, tibble, tbl_dbi object, tbl_spark object depending provided tbl.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_shift.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Table Transformer: shift the times of a table ‚Äî tt_time_shift","text":"time_shift specification higher time granularity least granular time column input table. Put simpler terms, date-based based columns (just single date-based column) time shifting can terms years, months, days. Using time_shift specification \"20d 6H\" presence dates result truncation \"20d\". Similarly, difftime object altered circumstances, however, object resolved exact number days rounding.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_shift.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: shift the times of a table ‚Äî tt_time_shift","text":"12-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_shift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: shift the times of a table ‚Äî tt_time_shift","text":"","code":"# With the `game_revenue` dataset, # which has entries in the first # 21 days of 2015, move all of the # date and date-time values to the # beginning of 2021 tt_time_shift(   tbl = game_revenue,   time_shift = \"6y\" ) #> # A tibble: 2,000 √ó 11 #>    player_id       session_id  session_start       time                item_type #>    <chr>           <chr>       <dttm>              <dttm>              <chr>     #>  1 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 01:31:03 2021-01-01 01:31:27 iap       #>  2 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 01:31:03 2021-01-01 01:36:57 iap       #>  3 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 01:31:03 2021-01-01 01:37:45 iap       #>  4 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 01:31:03 2021-01-01 01:42:33 ad        #>  5 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 11:50:02 2021-01-01 11:55:20 ad        #>  6 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 11:50:02 2021-01-01 12:08:56 ad        #>  7 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 11:50:02 2021-01-01 12:14:08 ad        #>  8 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 11:50:02 2021-01-01 12:21:44 ad        #>  9 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2021-01-01 11:50:02 2021-01-01 12:24:20 ad        #> 10 FXWUORGYNJAE271 FXWUORGYNJ‚Ä¶ 2021-01-01 15:17:18 2021-01-01 15:19:36 ad        #> # ‚Ä¶ with 1,990 more rows, and 6 more variables: item_name <chr>, #> #   item_revenue <dbl>, session_duration <dbl>, start_day <date>, #> #   acquisition <chr>, country <chr>  # Keeping only the `date_time` and # `a`-`f` columns of `small_table`, # shift the times back 2 days and # 12 hours small_table %>%   dplyr::select(-date) %>%   tt_time_shift(\"-2d 12H\") #> # A tibble: 13 √ó 7 #>    date_time               a b             c      d e     f     #>    <dttm>              <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-01 23:00:00     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-01 12:32:00     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-03 01:32:00     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-04 05:23:00     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-07 00:36:00     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-08 18:15:00     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-13 06:46:00     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-14 23:27:00     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-17 16:30:00     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-17 16:30:00     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-24 08:07:00     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-25 14:51:00     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-27 23:23:00     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: slice a table with a slice point on a time column ‚Äî tt_time_slice","title":"Table Transformer: slice a table with a slice point on a time column ‚Äî tt_time_slice","text":"table object containing date, date-time columns, mixture thereof, one columns can used effectively slice data table two slice_point: get choose slices want keep. slice point can defined several ways. One method involves using decimal value 0 1, defines slice point time instant somewhere earliest time value (0) latest time value (1). Another way defining slice point supplying time value, following input types accepted: (1) ISO 8601 formatted time string (date date-time), (2) POSIXct time, (3) Date object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: slice a table with a slice point on a time column ‚Äî tt_time_slice","text":"","code":"tt_time_slice(   tbl,   time_column = NULL,   slice_point = 0,   keep = c(\"left\", \"right\"),   arrange = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: slice a table with a slice point on a time column ‚Äî tt_time_slice","text":"tbl table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object. time_column time-based column used basis slicing. time column provided first one found used. slice_point location time_column slicing occur. can either decimal value 0 1, ISO 8601 formatted time string (date date-time), POSIXct time, Date object. keep slice kept? \"left\" side (default) contains data rows earlier slice_point \"right\" side rows later. arrange slice arranged time_column? may useful input tbl ordered time_column. default, FALSE original ordering retained.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: slice a table with a slice point on a time column ‚Äî tt_time_slice","text":"data frame, tibble, tbl_dbi object, tbl_spark object depending provided tbl.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_slice.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Table Transformer: slice a table with a slice point on a time column ‚Äî tt_time_slice","text":"option arrange table date date-time values time_column. ordering always done ascending manner. NA/NULL values time_column result corresponding rows can removed (matter slice retained).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_slice.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: slice a table with a slice point on a time column ‚Äî tt_time_slice","text":"12-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/tt_time_slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: slice a table with a slice point on a time column ‚Äî tt_time_slice","text":"","code":"# With the `game_revenue` dataset, # which has entries in the first # 21 days of 2015, elect to get all # of the records where the `time` # values are strictly for the first # 15 days of 2015 tt_time_slice(   tbl = game_revenue,   time_column = \"time\",   slice_point = \"2015-01-16\" ) #> # A tibble: 1,208 √ó 11 #>    player_id       session_id  session_start       time                item_type #>    <chr>           <chr>       <dttm>              <dttm>              <chr>     #>  1 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 01:31:03 2015-01-01 01:31:27 iap       #>  2 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 01:31:03 2015-01-01 01:36:57 iap       #>  3 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 01:31:03 2015-01-01 01:37:45 iap       #>  4 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 01:31:03 2015-01-01 01:42:33 ad        #>  5 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 11:50:02 2015-01-01 11:55:20 ad        #>  6 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 11:50:02 2015-01-01 12:08:56 ad        #>  7 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 11:50:02 2015-01-01 12:14:08 ad        #>  8 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 11:50:02 2015-01-01 12:21:44 ad        #>  9 ECPANOIXLZHF896 ECPANOIXLZ‚Ä¶ 2015-01-01 11:50:02 2015-01-01 12:24:20 ad        #> 10 FXWUORGYNJAE271 FXWUORGYNJ‚Ä¶ 2015-01-01 15:17:18 2015-01-01 15:19:36 ad        #> # ‚Ä¶ with 1,198 more rows, and 6 more variables: item_name <chr>, #> #   item_revenue <dbl>, session_duration <dbl>, start_day <date>, #> #   acquisition <chr>, country <chr>  # Omit the first 25% of records # from `small_table` on the basis # of a timeline that begins at  # `2016-01-04 11:00:00` and # ends at `2016-01-30 11:23:00` small_table %>%   tt_time_slice(     slice_point = 0.25,     keep = \"right\"   ) #> # A tibble: 8 √ó 8 #>   date_time           date           a b             c     d e     f     #>   <dttm>              <date>     <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4 3291. TRUE  mid   #> 2 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE  high  #> 3 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2 1036. FALSE low   #> 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high  #> 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high  #> 6 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7  834. TRUE  low   #> 7 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8  108. FALSE low   #> 8 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE  high"},{"path":"https://rich-iannone.github.io/pointblank/reference/validate_rmd.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify pointblank validation testing options within R Markdown documents ‚Äî validate_rmd","title":"Modify pointblank validation testing options within R Markdown documents ‚Äî validate_rmd","text":"Using pointblank R Markdown workflow enabled default pointblank library loaded. framework allows validation testing within specialized validation code chunks validate = TRUE option set. Using pointblank validation functions data marked code chunks flag overall failure stop threshold exceeded anywhere. errors reported validation code chunk rendering document HTML, green red status buttons indicate whether validations succeeded failures occurred. Clicking button reveals otherwise hidden validation statements error messages (). framework testing set default, validate_rmd() function offers opportunity set UI logging options.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/validate_rmd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify pointblank validation testing options within R Markdown documents ‚Äî validate_rmd","text":"","code":"validate_rmd(summary = TRUE, log_to_file = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/validate_rmd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify pointblank validation testing options within R Markdown documents ‚Äî validate_rmd","text":"summary TRUE (default), leading summary validations rendered R Markdown document. FALSE, element shown. log_to_file option log errors text file. default, logging done TRUE write log entries \"validation_errors.log\" working directory. enable logging specify file name, include path log file desired name.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/validate_rmd.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Modify pointblank validation testing options within R Markdown documents ‚Äî validate_rmd","text":"1-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/write_testthat_file.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a pointblank agent to a testthat test file ‚Äî write_testthat_file","title":"Transform a pointblank agent to a testthat test file ‚Äî write_testthat_file","text":"pointblank agent, can write testthat test file opt place testthat/tests available project path (can specify alternate path well). works transforming validation steps series expect_*() calls inside individual testthat::test_that() statements. hard requirement using write_testthat_file() agent presence read_fn, function invoked obtain target table. read_fn statement placed top testthat test file target table available testthat::test_that() statements follow. agent read_fn can added via set_read_fn(). Thresholds obtained applied stop state. can set pointblank agent passing action_levels object actions argument create_agent() argument included validation function. stop thresholds available, threshold value 1 used generated expect_*() statement resulting testthat test file. requirement agent first undergo interrogation interrogate(). However, may useful dry run interactively perform interrogation target data generating testthat test file.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/write_testthat_file.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a pointblank agent to a testthat test file ‚Äî write_testthat_file","text":"","code":"write_testthat_file(   agent,   name = NULL,   path = NULL,   overwrite = FALSE,   skips = NULL,   quiet = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/reference/write_testthat_file.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a pointblank agent to a testthat test file ‚Äî write_testthat_file","text":"agent agent object class ptblank_agent. name optional name testhat test file. name without extension without leading \"test-\" text. nothing supplied, name derived tbl_name agent. present, generic name used. path path can specified attempt place file testthat/tests. overwrite testthat file name overwritten? default, FALSE. skips optional vector test-skipping keywords modeled testthat skip_on_*() functions. following keywords can used include skip_on_*() statements: \"cran\" (testthat::skip_on_cran()), \"travis\" (testthat::skip_on_travis()), \"appveyor\" (testthat::skip_on_appveyor()), \"ci\" (testthat::skip_on_ci()), \"covr\" (testthat::skip_on_covr()), \"bioc\" (testthat::skip_on_bioc()). keywords skipping tests certain operating systems insert specific testthat::skip_on_os() call. \"windows\" (skip_on_os(\"windows\")), \"mac\" (skip_on_os(\"mac\")), \"linux\" (skip_on_os(\"linux\")), \"solaris\" (skip_on_os(\"solaris\")). calls placed top generated testthat test file. quiet function inform file written? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/write_testthat_file.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a pointblank agent to a testthat test file ‚Äî write_testthat_file","text":"Invisibly returns TRUE testthat file written.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/write_testthat_file.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transform a pointblank agent to a testthat test file ‚Äî write_testthat_file","text":"Tests inactive validation steps skipped clear message indicating reason skipping due test active. inactive validation steps can forced active state using activate_steps() agent (opposite possible deactivate_steps() function). testthat package comes series skip_on_*() functions conveniently cause test file skipped entirely certain conditions met. can quickly set number top testthat test file supplying keywords vector skips option write_testthat_file(). instance, setting skips = c(\"cran\", \"windows) add testthat skip_on_cran() skip_on_os(\"windows\") statements, meaning generated test file run CRAN system system OS Windows. example testthat test file output: test-small_table.R generated following set statements:","code":"# Generated by pointblank  tbl <- small_table  test_that(\"column `date_time` exists\", {      expect_col_exists(     tbl,     columns = vars(date_time),     threshold = 1   )  })  test_that(\"values in `c` should be <= `5`\", {      expect_col_vals_lte(     tbl,     columns = vars(c),     value = 5,     threshold = 0.25   )  }) library(pointblank)  agent <-    create_agent(     read_fn = ~ small_table,     actions = action_levels(stop_at = 0.25)   ) %>%   col_exists(vars(date_time)) %>%   col_vals_lte(vars(c), value = 5)    write_testthat_file(   agent = agent,   name = \"small_table\",   path = \".\" )"},{"path":"https://rich-iannone.github.io/pointblank/reference/write_testthat_file.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Transform a pointblank agent to a testthat test file ‚Äî write_testthat_file","text":"8-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/write_testthat_file.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a pointblank agent to a testthat test file ‚Äî write_testthat_file","text":"","code":"if (interactive()) {  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # A pointblank `agent` object is now # created and the `al` object is provided # to the agent; the static thresholds # provided by `al` make reports a bit # more useful after interrogation agent <-    create_agent(     read_fn = ~ small_table,     label = \"An example.\",     actions = al   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5) %>%   interrogate()  # This agent and all of the checks can # be transformed into a testthat file # with `write_testthat_file()`; the `stop` # thresholds will be ported over write_testthat_file(   agent = agent,   name = \"small_table\",   path = \".\" )  # The above code will generate a file with # the name `test-small_table.R`; the path # was specified with `\".\"` but, by default, # the function will place the file in the # `tests/testthat` folder if it's available  # An agent on disk as a YAML file can be # made into a testthat file; the # 'agent-small_table.yml' file is # available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # Writing the testthat file into the # working directory is much the same # as before but we're reading the # agent from disk this time write_testthat_file(   agent = yaml_read_agent(yml_file),   name = \"from_agent_yaml\",   path = \".\" )  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/x_read_disk.html","id":null,"dir":"Reference","previous_headings":"","what":"Read an agent, informant, multiagent, or table scan from disk ‚Äî x_read_disk","title":"Read an agent, informant, multiagent, or table scan from disk ‚Äî x_read_disk","text":"agent, informant, multiagent, table scan written disk (x_write_disk()) can read back memory x_read_disk() function. agent informant object generated way, may data table associated (depending whether keep_tbl option TRUE FALSE writing disk) still able produce reporting (printing agent informant console using get_agent_report()/get_informant_report()). agent return x-list get_agent_x_list() yield available data extracts get_data_extracts(). Furthermore, agent's validation steps still present (along results last interrogation).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/x_read_disk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read an agent, informant, multiagent, or table scan from disk ‚Äî x_read_disk","text":"","code":"x_read_disk(filename, path = NULL, quiet = FALSE)"},{"path":"https://rich-iannone.github.io/pointblank/reference/x_read_disk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read an agent, informant, multiagent, or table scan from disk ‚Äî x_read_disk","text":"filename name file previously written x_write_disk(). path optional path file (combined filename). quiet function inform file read? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/x_read_disk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read an agent, informant, multiagent, or table scan from disk ‚Äî x_read_disk","text":"Either ptblank_agent, ptblank_informant, ptblank_tbl_scan object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/x_read_disk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read an agent, informant, multiagent, or table scan from disk ‚Äî x_read_disk","text":"written--disk agent informant possess table-prep formula (can set time set_read_fn()) specific table (settable set_tbl()) use interrogate() incorporate() function . data quality reporting workflow, useful interrogate() target tables evolve time. validation steps used, can added calling interrogate(). information management workflow informant object, using incorporate() update aspects reporting table dimensions, info snippets/text regenerated.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/x_read_disk.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Read an agent, informant, multiagent, or table scan from disk ‚Äî x_read_disk","text":"9-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/x_read_disk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read an agent, informant, multiagent, or table scan from disk ‚Äî x_read_disk","text":"","code":"if (interactive()) {  # A: Reading an agent from disk   # The process of developing an agent # and writing it to disk with the # `x_write_disk()` function is explained # in that function's documentation; # but suppose we have such a written file # that's named \"agent-small_table.rds\", # we could read that to a new agent # object with `x_read_disk()` agent <-   x_read_disk(\"agent-small_table.rds\")  # B: Reading an informant from disk  # If there is an informant written # to disk via `x_write_disk()` and it's # named \"informant-small_table.rds\", # we could read that to a new informant # object with `x_read_disk()` informant <-   x_read_disk(\"informant-small_table.rds\")  # C: Reading a multiagent from disk   # The process of creating a multiagent # and writing it to disk with the # `x_write_disk()` function is shown # in that function's documentation; # but should we have such a written file # called \"multiagent-small_table.rds\", # we could read that to a new multiagent # object with `x_read_disk()` agent <-   x_read_disk(\"multiagent-small_table.rds\")  # D: Reading a table scan from disk  # If there is a table scan written # to disk via `x_write_disk()` and it's # named \"tbl_scan-storms.rds\", we could # read it back into R with `x_read_disk()` tbl_scan <-   x_read_disk(\"tbl_scan-storms.rds\")  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/x_write_disk.html","id":null,"dir":"Reference","previous_headings":"","what":"Write an agent, informant, multiagent, or table scan to disk ‚Äî x_write_disk","title":"Write an agent, informant, multiagent, or table scan to disk ‚Äî x_write_disk","text":"Writing agent, informant, multiagent, even table scan disk x_write_disk() can useful keeping data validation intel table information close hand later retrieval (x_read_disk()). default, data table agent informant may held committed disk expunged (applicable table scan since never hold table object). behavior can changed setting keep_tbl TRUE works case table tbl_dbi tbl_spark class.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/x_write_disk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write an agent, informant, multiagent, or table scan to disk ‚Äî x_write_disk","text":"","code":"x_write_disk(   x,   filename,   path = NULL,   keep_tbl = FALSE,   keep_extracts = FALSE,   quiet = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/reference/x_write_disk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write an agent, informant, multiagent, or table scan to disk ‚Äî x_write_disk","text":"x agent object class ptblank_agent, informant class ptblank_informant, table scan class ptblank_tbl_scan. filename filename create disk agent, informant, table scan. path optional path file saved (automatically combined filename). keep_tbl option keep data table associated agent informant (case agent, example, created using create_agent(tbl = <data table, ...)). default FALSE data table removed writing disk. database tables class tbl_dbi Spark DataFrames (tbl_spark) table always removed (even keep_tbl set TRUE). keep_extracts option keep collected extract data failing rows. applies agent objects. default, FALSE (.e., extract data removed). quiet function inform file written? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/x_write_disk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write an agent, informant, multiagent, or table scan to disk ‚Äî x_write_disk","text":"Invisibly returns TRUE file written.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/x_write_disk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write an agent, informant, multiagent, or table scan to disk ‚Äî x_write_disk","text":"recommended set table-prep formula agent informant can access refreshed data read disk x_read_disk(). can done initially read_fn argument create_agent()/create_informant() , later, set_read_fn(). Alternatively, can reintroduce agent informant data table set_tbl() function.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/x_write_disk.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Write an agent, informant, multiagent, or table scan to disk ‚Äî x_write_disk","text":"9-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/x_write_disk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write an agent, informant, multiagent, or table scan to disk ‚Äî x_write_disk","text":"","code":"if (interactive()) {  # A: Writing an `agent` to disk   # Let's go through the process of (1) # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # (2) interrogating the agent with the # `interrogate()` function, and (3) writing # the agent and all its intel to a file  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`x_write_disk()`\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want; then, we `interrogate()` agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5) %>%   interrogate()  # The `agent` can be written to a file with # the `x_write_disk()` function x_write_disk(   agent,   filename = \"agent-small_table.rds\" )  # We can read the file back as an agent # with the `x_read_disk()` function and # we'll get all of the intel along with the # restored agent  # If you're consistently writing agent # reports when periodically checking data, # we could make use of the `affix_date()` # or `affix_datetime()` depending on the # granularity you need; here's an example # that writes the file with the format: # 'agent-small_table-YYYY-mm-dd_HH-MM-SS.rds' x_write_disk(   agent,   filename = affix_datetime(     \"agent-small_table.rds\"   ) )  # B: Writing an `informant` to disk  # Let's go through the process of (1) # creating an informant object that # minimally describes the `small_table` # dataset, (2) ensuring that data is # captured from the target table using # the `incorporate()` function, and (3) # writing the informant to a file  # Create a pointblank `informant` # object with `create_informant()` # and the `small_table` dataset; use # `incorporate()` so that info snippets # are integrated into the text informant <-    create_informant(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`x_write_disk()`\"   ) %>%   info_snippet(     snippet_name = \"high_a\",     fn = snip_highest(column = \"a\")   ) %>%   info_snippet(     snippet_name = \"low_a\",     fn = snip_lowest(column = \"a\")   ) %>%   info_columns(     columns = vars(a),     info = \"From {low_a} to {high_a}.\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values.\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`.\"   ) %>%   incorporate()  # The `informant` can be written to a # file with `x_write_disk()`; let's do # this with `affix_date()` so that the # filename has a datestamp x_write_disk(   informant,   filename = affix_date(     \"informant-small_table.rds\"   ) )  # We can read the file back into a # new informant object (in the same # state as when it was saved) by using # `x_read_disk()`  # C: Writing a multiagent to disk  # Let's create one more pointblank # agent object, provide it with some # validation steps, and `interrogate()` agent_b <-   create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"`x_write_disk()`\",     actions = al   ) %>%   col_vals_gt(     vars(b), vars(g), na_pass = TRUE,     label = \"b > g\"   ) %>%   col_is_character(     vars(b, f),     label = \"Verifying character-type columns\"    ) %>%   interrogate()  # Now we can combine the earlier `agent` # object with the newer `agent_b` to  # create a `multiagent` multiagent <-   create_multiagent(agent, agent_b)    # The `multiagent` can be written to # a file with the `x_write_disk()` function x_write_disk(   multiagent,   filename = \"multiagent-small_table.rds\" )  # We can read the file back as a multiagent # with the `x_read_disk()` function and # we'll get all of the constituent agents # and their associated intel back as well  # D: Writing a table scan to disk  # We can get an report that describes all # of the data in the `storms` dataset tbl_scan <- scan_data(tbl = dplyr::storms)  # The table scan object can be written # to a file with `x_write_disk()` x_write_disk(   tbl_scan,   filename = \"tbl_scan-storms.rds\" )  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_interrogate.html","id":null,"dir":"Reference","previous_headings":"","what":"Get an agent from pointblank YAML and interrogate() ‚Äî yaml_agent_interrogate","title":"Get an agent from pointblank YAML and interrogate() ‚Äî yaml_agent_interrogate","text":"yaml_agent_interrogate() function operates much like yaml_read_agent() function (reading pointblank YAML file generating agent validation plan place). key difference function takes things step interrogates target table (defined table-prep formula required YAML file). additional auto-invocation interrogate() uses default options function. yaml_read_agent() agent returned except, time, intel interrogation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_interrogate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get an agent from pointblank YAML and interrogate() ‚Äî yaml_agent_interrogate","text":"","code":"yaml_agent_interrogate(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_interrogate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get an agent from pointblank YAML and interrogate() ‚Äî yaml_agent_interrogate","text":"filename name YAML file contains fields related agent. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_interrogate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get an agent from pointblank YAML and interrogate() ‚Äî yaml_agent_interrogate","text":"ptblank_agent object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_interrogate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get an agent from pointblank YAML and interrogate() ‚Äî yaml_agent_interrogate","text":"11-4","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_interrogate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get an agent from pointblank YAML and interrogate() ‚Äî yaml_agent_interrogate","text":"","code":"if (interactive()) {  # Let's go through the process of # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # and then offloading that validation # plan to a pointblank YAML file; this # will later be read in as a new agent and # the target data will be interrogated # (one step) with `yaml_agent_interrogate()`  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` # (a requirement for writing to YAML) agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" )  # The 'agent-small_table.yml' file is # available in the package through `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # We can view the YAML file in the console # with the `yaml_agent_string()` function yaml_agent_string(filename = yml_file)  # The YAML can also be printed in the console # by supplying the agent as the input yaml_agent_string(agent = agent)  # We can interrogate the data (which # is accessible through the `read_fn`) # through direct use of the YAML file # with `yaml_agent_interrogate()` agent <-    yaml_agent_interrogate(filename = yml_file)  class(agent)  # If it's desired to only create a new # agent with the validation plan in place # (stopping short of interrogating the data), # then the `yaml_read_agent()` function # will be useful agent <-    yaml_read_agent(filename = yml_file) class(agent)  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_show_exprs.html","id":null,"dir":"Reference","previous_headings":"","what":"Display validation expressions using pointblank YAML ‚Äî yaml_agent_show_exprs","title":"Display validation expressions using pointblank YAML ‚Äî yaml_agent_show_exprs","text":"yaml_agent_show_exprs() function follows specifications pointblank YAML file generate show pointblank expressions generating described validation plan. expressions shown console, providing opportunity copy statements extend needed. pointblank YAML file can generated using yaml_write() function pre-existing agent, , can carefully written hand.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_show_exprs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display validation expressions using pointblank YAML ‚Äî yaml_agent_show_exprs","text":"","code":"yaml_agent_show_exprs(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_show_exprs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display validation expressions using pointblank YAML ‚Äî yaml_agent_show_exprs","text":"filename name YAML file contains fields related agent. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_show_exprs.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Display validation expressions using pointblank YAML ‚Äî yaml_agent_show_exprs","text":"11-6","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_show_exprs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display validation expressions using pointblank YAML ‚Äî yaml_agent_show_exprs","text":"","code":"if (interactive()) {  # Let's create a validation plan for the # data quality analysis of the `small_table` # dataset; we need an agent and its # table-prep formula enables retrieval # of the target table agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = action_levels(       warn_at = 0.10,       stop_at = 0.25,       notify_at = 0.35     )   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" )  # The 'agent-small_table.yml' file is # available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # At a later time, the YAML file can # be read into a new agent with the # `yaml_read_agent()` function agent <-    yaml_read_agent(filename = yml_file)  class(agent)  # To get a sense of which expressions are # being used to generate the new agent, we # can use `yaml_agent_show_exprs()` yaml_agent_show_exprs(filename = yml_file)  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_string.html","id":null,"dir":"Reference","previous_headings":"","what":"Display pointblank YAML using an agent or a YAML file ‚Äî yaml_agent_string","title":"Display pointblank YAML using an agent or a YAML file ‚Äî yaml_agent_string","text":"pointblank YAML, can serialize agent's validation plan (yaml_write()), read back later new agent (yaml_read_agent()), perform interrogation target data table directly YAML file (yaml_agent_interrogate()). yaml_agent_string() function allows us inspect YAML generated yaml_write() console, giving us look YAML without needing open file directly. Alternatively, can provide agent yaml_agent_string() view YAML representation validation plan without needing write YAML disk beforehand.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_string.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display pointblank YAML using an agent or a YAML file ‚Äî yaml_agent_string","text":"","code":"yaml_agent_string(agent = NULL, filename = NULL, path = NULL, expanded = FALSE)"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_string.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display pointblank YAML using an agent or a YAML file ‚Äî yaml_agent_string","text":"agent agent object class ptblank_agent. object provided , filename must provided. filename name YAML file contains fields related agent. file name provided , agent object must provided agent. path optional path YAML file (combined filename). expanded written validation expressions agent expanded tidyselect vars() expressions columns evaluated, yielding validation function per column? default, FALSE expressions written retained YAML representation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_string.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Display pointblank YAML using an agent or a YAML file ‚Äî yaml_agent_string","text":"11-5","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_agent_string.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display pointblank YAML using an agent or a YAML file ‚Äî yaml_agent_string","text":"","code":"if (interactive()) {  # Let's create a validation plan for the # data quality analysis of the `small_table` # dataset; we need an agent and its # table-prep formula enables retrieval # of the target table agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = action_levels(       warn_at = 0.10,       stop_at = 0.25,       notify_at = 0.35     )   ) %>%   col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # We can view the YAML file in the console # with the `yaml_agent_string()` function, # providing the `agent` object as the input yaml_agent_string(agent = agent)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" )  # There's a similar file in the package # ('agent-small_table.yml') and it's # accessible with `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # The `yaml_agent_string()` function can # be used with the YAML file as well, # use the `filename` argument instead yaml_agent_string(filename = yml_file)  # At some later time, the YAML file can # be read as a new agent with the # `yaml_read_agent()` function agent <- yaml_read_agent(filename = yml_file) class(agent)  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_exec.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute all agent and informant YAML tasks ‚Äî yaml_exec","title":"Execute all agent and informant YAML tasks ‚Äî yaml_exec","text":"yaml_exec() function takes relevant pointblank YAML files directory executes . Execution involves interrogation agents YAML agents incorporation informants YAML informants. hood, uses yaml_agent_interrogate() yaml_informant_incorporate() x_write_disk() save processed objects output directory. written artifacts can read later time x_read_disk() function read_disk_multiagent() function. useful data target tables changing periodic testing tables part data quality monitoring plan. output RDS files named according object type processed, target table, date-time processing. convenience modularity, setup ideal table store YAML file (typically named \"tbl_store.yml\" produced via tbl_store() yaml_write() workflow) available directory, table-prep formulas accessed name tbl_source(). typical directory files set execution way might following contents: \"tbl_store.yml\" file holding table-prep formulas (created tbl_store() written YAML yaml_write()) one YAML agent files validate tables (ideally using tbl_source()) one YAML informant files provide refreshed metadata tables (, using tbl_source() reference table preparations ideal) output folder (default \"output\") save serialized versions processed agents informants Minimal example files aforementioned types can found pointblank package following system.file() calls: system.file(\"yaml\", \"agent-small_table.yml\", package = \"pointblank\") system.file(\"yaml\", \"informant-small_table.yml\", package = \"pointblank\") system.file(\"yaml\", \"tbl_store.yml\", package = \"pointblank\") directory can accessed using system.file(\"yaml\", package = \"pointblank\").","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_exec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute all agent and informant YAML tasks ‚Äî yaml_exec","text":"","code":"yaml_exec(   path = NULL,   files = NULL,   write_to_disk = TRUE,   output_path = file.path(path, \"output\"),   keep_tbl = FALSE,   keep_extracts = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_exec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute all agent and informant YAML tasks ‚Äî yaml_exec","text":"path path contains YAML files agents informants. files vector YAML files use execution workflow. default, yaml_exec() attempt process every valid YAML file path supplying vector limits scope specified files. write_to_disk execution workflow include step writes output files disk? internally calls x_write_disk() write RDS files uses base filename agent/informant YAML file part output filename, appending date-time basename. output_path output path generated output files. default, subdirectory provided path called \"output\". keep_tbl, keep_extracts agents, table may kept data frame object (databases tables never pulled storage) extracts, collections table rows failed validation step, may also stored. default, options set FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_exec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Execute all agent and informant YAML tasks ‚Äî yaml_exec","text":"Invisibly returns named vector file paths input files processed; file output paths (wherever writing occurred) given names.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_exec.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Execute all agent and informant YAML tasks ‚Äî yaml_exec","text":"11-8","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_exec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Execute all agent and informant YAML tasks ‚Äî yaml_exec","text":"","code":"if (interactive()) {  # The 'yaml' directory that is # accessible in the package through # `system.file()` contains the files # 1. `agent-small_table.yml` # 2. `informant-small_table.yml` # 3. `tbl_store.yml`  # There are references in YAML files # 1 & 2 to the table store YAML file, # so, they all work together cohesively  # Let's process the agent and the # informant YAML files with `yaml_exec()`; # and we'll specify the working directory # as the place where the output RDS files # are written  output_dir <- getwd()  yaml_exec(   path = system.file(     \"yaml\", package = \"pointblank\"   ),   output = output_dir )  # This generates two RDS files in the # working directory: one for the agent # and the other for the informant; each # of them are automatically time-stamped # so that periodic execution can be # safely carried out without risk of # overwriting   }"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_informant_incorporate.html","id":null,"dir":"Reference","previous_headings":"","what":"Get an informant from pointblank YAML and incorporate() ‚Äî yaml_informant_incorporate","title":"Get an informant from pointblank YAML and incorporate() ‚Äî yaml_informant_incorporate","text":"yaml_informant_incorporate() function operates much like yaml_read_informant() function (reading pointblank YAML file generating informant information place). key difference function takes things step incorporates aspects target table (defined table-prep formula required YAML file). additional auto-invocation incorporate() uses default options function. yaml_read_informant() informant returned except, time, updated latest information target table.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_informant_incorporate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get an informant from pointblank YAML and incorporate() ‚Äî yaml_informant_incorporate","text":"","code":"yaml_informant_incorporate(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_informant_incorporate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get an informant from pointblank YAML and incorporate() ‚Äî yaml_informant_incorporate","text":"filename name YAML file contains fields related informant. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_informant_incorporate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get an informant from pointblank YAML and incorporate() ‚Äî yaml_informant_incorporate","text":"ptblank_informant object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_informant_incorporate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get an informant from pointblank YAML and incorporate() ‚Äî yaml_informant_incorporate","text":"11-7","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_informant_incorporate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get an informant from pointblank YAML and incorporate() ‚Äî yaml_informant_incorporate","text":"","code":"if (interactive()) {  # Let's go through the process of # developing an informant with information # about the `small_table` dataset and then # move all that to a pointblank YAML # file; this will later be read in as a # new informant and the target data will # be incorporated into the info text # (in one step) with # `yaml_informant_incorporate()`  # Now create a pointblank `informant` # object; the data will be referenced # in a `read_fn` (a requirement for # writing to YAML) informant <-    create_informant(     read_fn = ~small_table,     label = \"A simple example with the `small_table`.\"   )  # Then, as with any `informant` object, we # can add information by using as many # `info_*()` functions as we want informant <-   informant %>%   info_columns(    columns = vars(a),    info = \"In the range of 1 to 10. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = \"date\",     info = \"The date part of `date_time`. (CALC)\"   ) %>%   info_section(     section_name = \"rows\",     row_count = \"There are {row_count} rows available.\"   ) %>%   info_snippet(     snippet_name = \"row_count\",     fn = ~ . %>% nrow()   ) %>%   incorporate()  # The informant can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   informant = informant,   filename = \"informant-small_table.yml\" )  # The 'informant-small_table.yml' file # is available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"informant-small_table.yml\",     package = \"pointblank\"   )  # We can incorporate the data (which # is accessible through the `read_fn`) # into the info text through direct # use of the YAML file with # `yaml_informant_incorporate()` informant <-    yaml_informant_incorporate(filename = yml_file)  class(informant)  # If it's desired to only create a new # informant with the information in place # (stopping short of processing), then the # `yaml_read_informant()` function will # be useful informant <-    yaml_read_informant(filename = yml_file)  class(informant)  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_read_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a pointblank YAML file to create an agent object ‚Äî yaml_read_agent","title":"Read a pointblank YAML file to create an agent object ‚Äî yaml_read_agent","text":"yaml_read_agent() can read pointblank YAML file describes validation plan carried agent (typically generated yaml_write() function. returned new agent validation plan, ready interrogate target table (using table-prep formula set read_fn argument). agent can given validation steps needed using interrogate() taking part agent ops (e.g., writing disk outputs intact via x_write_disk() pointblank YAML yaml_write()). get picture yaml_read_agent() interpreting validation plan specified pointblank YAML, can use yaml_agent_show_exprs() function. function shows us (console) pointblank expressions generating described validation plan.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_read_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a pointblank YAML file to create an agent object ‚Äî yaml_read_agent","text":"","code":"yaml_read_agent(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_read_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a pointblank YAML file to create an agent object ‚Äî yaml_read_agent","text":"filename name YAML file contains fields related agent. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_read_agent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a pointblank YAML file to create an agent object ‚Äî yaml_read_agent","text":"ptblank_agent object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_read_agent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Read a pointblank YAML file to create an agent object ‚Äî yaml_read_agent","text":"11-2","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_read_agent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read a pointblank YAML file to create an agent object ‚Äî yaml_read_agent","text":"","code":"if (interactive()) {  # Let's go through the process of # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # and then offloading that validation # plan to a pointblank YAML file; this # will be read in with `yaml_read_agent()`  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` # (a requirement for writing to YAML) agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b),     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" )  # The 'agent-small_table.yml' file is # available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # We can view the YAML file in the console # with the `yaml_agent_string()` function yaml_agent_string(filename = yml_file)  # The YAML can also be printed in the console # by supplying the agent as the input yaml_agent_string(agent = agent)  # At some later time, the YAML file can # be read as a new agent with the # `yaml_read_agent()` function agent <- yaml_read_agent(filename = yml_file)  class(agent)  # We can interrogate the data (which # is accessible through the `read_fn`) # with `interrogate()` and get an # agent with intel, or, we can # interrogate directly from the YAML # file with `yaml_agent_interrogate()` agent <-    yaml_agent_interrogate(     filename = yml_file   )  class(agent)  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_read_informant.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a pointblank YAML file to create an informant object ‚Äî yaml_read_informant","title":"Read a pointblank YAML file to create an informant object ‚Äî yaml_read_informant","text":"yaml_read_informant() can read pointblank YAML file describes table information (typically generated yaml_write() function. returned new informant object information intact. informant object can given information use info_*() functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_read_informant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a pointblank YAML file to create an informant object ‚Äî yaml_read_informant","text":"","code":"yaml_read_informant(filename, path = NULL)"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_read_informant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a pointblank YAML file to create an informant object ‚Äî yaml_read_informant","text":"filename name YAML file contains fields related informant. path optional path YAML file (combined filename).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_read_informant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a pointblank YAML file to create an informant object ‚Äî yaml_read_informant","text":"ptblank_informant object.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_read_informant.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Read a pointblank YAML file to create an informant object ‚Äî yaml_read_informant","text":"11-3","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_read_informant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read a pointblank YAML file to create an informant object ‚Äî yaml_read_informant","text":"","code":"if (interactive()) {  # Create a pointblank `informant` # object with `create_informant()` # and the `small_table` dataset informant <- create_informant(small_table)  # An `informant` object can be written # to a YAML file with the `yaml_write()` # function # yaml_write( #   informant = informant, #   filename = \"informant-small_table.yml\" # )  # The `informant-small_table.yml` file # looks like this when written  #> info_label: '[2020-09-06|13:37:38]' #> table: #>   name: small_table #> _columns: 8 #> _rows: 13 #> _type: tbl_df #> columns: #>   date_time: #>     _type: POSIXct, POSIXt #>   date: #>     _type: Date #>   a: #>     _type: integer #>   b: #>     _type: character #>   c: #>     _type: numeric #>   d: #>     _type: numeric #>   e: #>     _type: logical #>   f: #>     _type: character  # We can add keys and values to # add more pertinent information; with # some direct editing of the file we get:  #> info_label: '[2020-09-06|13:37:38]' #> table: #>   name: small_table #>   _columns: 8 #>   _rows: 13 #>   _type: tbl_df #> columns: #>   date_time: #>     _type: POSIXct, POSIXt #>     info: Date-time values. #>   date: #>     _type: Date #>     info: Date values (the date part of `date_time`). #>   a: #>     _type: integer #>     info: Small integer values (no missing values). #>   b: #>     _type: character #>     info: Strings with a common pattern. #>   c: #>     _type: numeric #>     info: Small numeric values (contains missing values). #>   d: #>     _type: numeric #>     info: Large numeric values (much greater than `c`). #>   e: #>     _type: logical #>     info: TRUE and FALSE values. #>   f: #>     _type: character #>     info: Strings of the set `\"low\"`, `\"mid\"`, and `\"high\"`.  # We could also have done the same # with the `informant` object by use of # the `info_columns()` function  # The 'informant-small_table.yml' file # is available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"informant-small_table.yml\",     package = \"pointblank\"   )  # We can read this YAML file back # as an `informant` object by using # `yaml_read_informant()` informant <-    yaml_read_informant(filename = yml_file)  class(informant)  }"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_write.html","id":null,"dir":"Reference","previous_headings":"","what":"Write pointblank objects to YAML files ‚Äî yaml_write","title":"Write pointblank objects to YAML files ‚Äî yaml_write","text":"yaml_write() can take different pointblank objects (ptblank_agent, ptblank_informant, tbl_store) write YAML. agent, example, yaml_write() write everything needed specify agent validation plan YAML file. YAML, can modify YAML markup desired, , use create new agent yaml_read_agent() function. agent validation plan ready interrogate() data. can go step perform interrogation directly YAML file yaml_agent_interrogate() function. returns agent intel (already interrogated target data table). informant object can also written YAML yaml_write(). One requirement writing agent informant YAML need table-prep formula (read_fn) specified (R formula used read target table interrogate() incorporate() called). option can set using create_agent()/create_informant() set_read_fn() (useful existing agent informant object).","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_write.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write pointblank objects to YAML files ‚Äî yaml_write","text":"","code":"yaml_write(   ...,   .list = list2(...),   filename = NULL,   path = NULL,   expanded = FALSE,   quiet = FALSE )"},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_write.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write pointblank objects to YAML files ‚Äî yaml_write","text":"... mix pointblank objects agent (ptblank_agent), informant (ptblank_informant), table store (tbl_store). agent informant can combined single YAML file (objects value read_fn). table store combined either agent informant must undergo conversion alone. .list Allows use list input alternative .... filename name YAML file create disk. recommended either .yaml .yml extension used file. provided default names used (\"tbl_store.yml\") table store objects get default naming effect \"<object>-<tbl_name>.yml\". path optional path YAML file saved (combined filename). expanded written validation expressions agent expanded tidyselect vars() expressions columns evaluated, yielding validation function per column? default, FALSE expressions written retained YAML representation. quiet function inform file written? default FALSE.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_write.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write pointblank objects to YAML files ‚Äî yaml_write","text":"Invisibly returns TRUE YAML file written.","code":""},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_write.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Write pointblank objects to YAML files ‚Äî yaml_write","text":"11-1","code":""},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/reference/yaml_write.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write pointblank objects to YAML files ‚Äî yaml_write","text":"","code":"if (interactive()) {  # Let's go through the process of # developing an agent with a validation # plan (to be used for the data quality # analysis of the `small_table` dataset), # and then offloading that validation # plan to a pointblank YAML file  # Creating an `action_levels` object is a # common workflow step when creating a # pointblank agent; we designate failure # thresholds to the `warn`, `stop`, and # `notify` states using `action_levels()` al <-    action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   )  # Now create a pointblank `agent` object # and give it the `al` object (which # serves as a default for all validation # steps which can be overridden); the # data will be referenced in a `read_fn` # (a requirement for writing to YAML) agent <-    create_agent(     read_fn = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = al   )  # Then, as with any `agent` object, we # can add steps to the validation plan by # using as many validation functions as we # want agent <-   agent %>%    col_exists(vars(date, date_time)) %>%   col_vals_regex(     vars(b), regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(vars(d), value = 100) %>%   col_vals_lte(vars(c), value = 5)  # The agent can be written to a pointblank # YAML file with `yaml_write()` yaml_write(   agent,   filename = \"agent-small_table.yml\" )  # The 'agent-small_table.yml' file is # available in the package through # `system.file()` yml_file <-    system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   )  # We can view the YAML file in the console # with the `yaml_agent_string()` function yaml_agent_string(filename = yml_file)  # The YAML can also be printed in the console # by supplying the agent as the input yaml_agent_string(agent = agent)  # At some later time, the YAML file can # be read as a new agent with the # `yaml_read_agent()` function agent <-    yaml_read_agent(filename = yml_file)  class(agent)  # We can interrogate the data (which # is accessible through the `read_fn`) # with `interrogate()` and get an # agent with intel, or, we can # interrogate directly from the YAML # file with `yaml_agent_interrogate()` agent <-    yaml_agent_interrogate(filename = yml_file)  class(agent)  }"},{"path":[]},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-090","dir":"Changelog","previous_headings":"","what":"pointblank 0.9.0","title":"pointblank 0.9.0","text":"CRAN release: 2021-10-28","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"new-features-0-9-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.9.0","text":"new rows_complete() validation function (along expect_rows_complete() test_rows_complete() expectation test variants) check whether rows contain NA/NULL values (optionally constrained selection specified columns). new function serially() (along expect_serially() test_serially()) allows series tests run sequence either culminating final validation step simply exiting series. construction allows pre-testing may make sense validation step. example, may situations ‚Äôs vital check column type performing validation column. specially()/expect_specially()/test_specially() functions enable custom validations/tests/expectations user-defined function. still preconditions common args available convenience. great thing require UDF return logical vector passing/failing test units (table rightmost column logical), can incorporate results quite easily standard pointblank reporting. info_columns_from_tbl() function super-convenient wrapper info_columns() function. Say ‚Äôre making data dictionary informant already table metadata somewhere table: can use call info_columns() many, many times. Added game_revenue_info dataset contains metadata extant game_revenue dataset. datasets pair nicely together examples create data dictionary create_informant() info_columns_from_tbl(). Added table transformer function tt_tbl_colnames() get table‚Äôs column names validation.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-9-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.9.0","text":"Input data tables label attribute values columns displayed ‚ÄòVariables‚Äô section scan_data() report. useful scanning imported SAS tables (often labeled variables). all_passed() function improved failed validation steps (return evaluation error, perhaps missing column) result FALSE; argument added all_passed() optionally get subset validation steps evaluation. expect_*() functions can handle multiple columns, pointblank now correctly stops first failure provides correct reporting . Passing multiple columns really mean processing multiple steps serial, previously handled incorrectly.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-080","dir":"Changelog","previous_headings":"","what":"pointblank 0.8.0","title":"pointblank 0.8.0","text":"CRAN release: 2021-07-25","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"new-features-0-8-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.8.0","text":"new draft_validation() function create starter validation .R .Rmd file just table input. Uses new ‚Äòcolumn roles‚Äô feature develop starter set validation steps based kind data columns contain (e.g., latitude/longitude values, URLs, email addresses, etc.). validation function col_vals_within_spec() (variants expect_col_vals_within_spec() test_col_vals_within_spec()) test column values specification like phone numbers (\"phone\"), VIN numbers (\"VIN\"), URLs (\"url\"), email addresses (\"email\"), much (\"isbn\", \"postal_code[<country_code>]\", \"credit_card\", \"iban[<country_code>]\", \"swift\", \"ipv4\", \"ipv6\", \"mac\"). large cross section row-based validation functions can now operate segments target table, can run particular validation slices (segments) target table. segmentation made possible use new segments argument, takes expression serves segment target table column values. can given one two ways: (1) single multiple column names containing keys segment , (2) two-sided formula LHS holds column name RHS contains column values segment (allowing subset keys segmentation). default printing multiagent object now stacked display agent reports. wide report (useful comparisons validations targeting table time) available improved get_multiagent_report() function (display_mode = \"wide\"). Exporting reporting now much easier new export_report() function. export objects agent (validations), informant (table metadata), multiagent (series validations), , also objects containing customized reports (scan_data(), get_agent_report(), get_informant_report(), get_multiagent_report()). ‚Äôll always get self-contained HTML file report use export_report(). new family functions added pointblank: Table Transformers! functions can radically transform data table either provide wholly different table (like summary table table properties table) useful filtering single step. can useful preparing target table validation creating temporary tables (preconditions) validation steps (e.g., validating table properties string lengths). nice bonus transformer functions work equally well data frames, database tables, Spark tables. included functions : tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_time_shift(), tt_time_slice(). Two new datasets added: specifications game_revenue. former dataset can used test col_vals_within_spec() validation function. latter dataset (2,000 rows) can used experiment tt_time_shift() tt_time_slice() table transformer functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-8-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.8.0","text":"Added Polish (\"pl\"), Danish (\"da\"), Turkish (\"tr\"), Swedish (\"sv\"), Dutch (\"nl\") translations. scan_data() function now bit performant, testable, better communicating progress generating report. preconditions argument, used modify target table validation step, now improved (1) checking table object returned evaluation, (2) correcting YAML writing preconditions expression ‚Äôs provided function. x_write_disk() x_read_disk() extended allow writing reading ptblank_tbl_scan objects (returned scan_data()). Print methods received love release. Now, scan_data() table scan reports look much better R Markdown. Reporting objects get_agent_report(), get_informant_report(), get_multiagent_report() now print methods work beautifully R Markdown result. incorporate() function, called informant object, now emits styled messages console. using yaml_exec() process arbitrary amount YAML-based agents informants, ‚Äôll given information progress console.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"documentation-0-8-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.8.0","text":"Many help files overhauled (1) things clearer, (2) details provided (things complex), (3) many ready--run examples present. functions improved help release : all_passed(), get_data_extracts(), get_multiagent_report(), get_sundered_data(), has_columns(), write_testthat_file(), x_write_disk(), yaml_exec().","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-070","dir":"Changelog","previous_headings":"","what":"pointblank 0.7.0","title":"pointblank 0.7.0","text":"CRAN release: 2021-03-09","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"new-features-0-7-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.7.0","text":"New functions set-based interrogations: col_vals_make_set() (+ expect_col_vals_make_set() test_col_vals_make_set()) col_vals_make_subset() (+ expect_col_vals_make_subset() test_col_vals_make_subset()); answer following two questions: (1) set values entirely accounted column values?, (2) set values subset column values? New functions order-based interrogations: col_vals_increasing() (+ expect_col_vals_increasing() test_col_vals_increasing()) col_vals_decreasing() (+ expect_col_vals_decreasing() test_col_vals_decreasing()); check column values either increasing decreasing options allow non-moving values backtracking (threshold). Several functions added facilitate multi-agent workflows: create_multiagent(), read_disk_multiagent(), get_multiagent_report(); workflows help track interrogation results across multiple agents reporting scales well several dozens agents. new function write_testthat_file() generates testthat test file puts tests/testthat certain conditions met; converts agent‚Äôs validation plan separate expect_*() statements. New functions tbl_store(), tbl_source(), tbl_get() functions added centrally managing table-prep formulas. Added yaml_exec() function processes relevant pointblank YAML files directory; execution involves interrogation agents (given YAML agents) incorporation informants (given YAML informants), saving processed objects output directory. new functions file_tbl() helper from_github() make easy generate table compatible data file; file form CSV, TSV, RDA, RDS. Several functions added modifying agent‚Äôs validation plan: activate_steps(), deactivate_steps(), remove_steps(). Added snip_stats() function generating -line statistical summary information report. Add sorting options snip_list() can choose sort column items frequency sequentially (alphabetically/numerically). improvements made snip_list() : (1) better default appearance, (2) enable customization, (3) include localization options supported spoken languages. Added several options customizing main reporting heading three reporting objects: agent report, information report, multiagent report. active argument every validation function can now take expression evaluates logical; has_columns() added make easy express active whether one columns present target table (e.g., perform validation step target column available). Added support using Arrow tables target tables informant objects.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"documentation-0-7-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.7.0","text":"Added information YAML representations validation functions several functions make appearance YAML. General improvements function documentation made wide cross section exported functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.7.0","text":"Included method writing informant object disk (x_write_disk()). Many fixes made tests added ensure agents survive YAML roundtrip (agent %>% yaml_write() yaml_read_agent() creates agent object). Updated several internal dplyr::arrange() statements used scan_data() warnings aren‚Äôt issued dbplyr (table scans operating tbl_dbi objects). tidyselect expressions used agents now preserved agent written YAML.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-060","dir":"Changelog","previous_headings":"","what":"pointblank 0.6.0","title":"pointblank 0.6.0","text":"CRAN release: 2020-11-20","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-information-0-6-0","dir":"Changelog","previous_headings":"","what":"Pointblank Information","title":"pointblank 0.6.0","text":"new information management workflow full features help describe tables keep top changes . make work well, new character enters: informant! Added create_informant() function create ptblank_informant object (function similar create_agent()). meant hold information (much want, really) target table, reporting features geared toward communication. Functions facilitating entry info text added need (info_tabular(), info_columns(), info_section()). focused describing columns, table proper, misc. fields. wasn‚Äôt enough, release adds info_snippet() round collection info_*() functions workflow. Oh, hang , ‚Äôs also -important incorporate() function. ? explain, idea methodology acquiring important bits data target table (‚Äôs info_snippet()‚Äôs job) use incorporate() grab morsels data stitch info text (via { }). Added get_informant_report() function printing information report (gt table object!). can also just print informant object show information report thanks print method purpose. informant object can written pointblank YAML using revised yaml_write() (previously agent_yaml_write()) function. can actually write agent informant YAML file useful since objects share target table. Reading done yaml_read_agent() yaml_read_informant() functions. informant can emailed using email_create() function; emailing can done one eight languages stock message text.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"translations-and-locales-0-6-0","dir":"Changelog","previous_headings":"","what":"Translations and Locales","title":"pointblank 0.6.0","text":"text agent report translated now. Improved Spanish (Spain) translation. Added Portuguese (\"pt\", Brazil), Chinese (\"zh\", China mainland), Russian (\"ru\") translations. Added locale option reporting; locale match language (using base locale) unless different locale specified. locale used format numeric values according locale‚Äôs rules. also applies reporting offered scan_data() function. stock email message parts (used emailing agent report information report) translated eight supported languages. language setting respective objects used determine language stock message parts.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"breaking-changes-0-6-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"pointblank 0.6.0","text":"yaml_write() function replaces agent_yaml_write() function. new function works write agent, informant object, , YAML. names YAML functions changed, final roster now consists : yaml_write(), yaml_read_agent(), yaml_read_informant(), yaml_agent_interrogate(), yaml_agent_string(), yaml_agent_show_exprs(). x_write_disk() function replaces agent_write() function. new function works write agent informant object disk. x_read_disk() function replaces agent_read() function. new function works read agent informant objects written disk. email_preview() function renamed email_create().","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"new-features-0-6-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.6.0","text":"new db_tbl() function makes ridiculously easy access database table selection databases pointblank supports validation; accessible supplied keywords \"postgres\" (PostgreSQL), \"mysql\" (MySQL), \"maria\" (MariaDB), \"duckdb\" (DuckDB), \"sqlite\" (SQLite), , driver function ‚Äôd like supply. Added log4r_step() function can used action action_levels() function call (.e., list component fns list). can place call function every condition produce log entry (.e., warn, stop, notify).","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"documentation-0-6-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.6.0","text":"Added several articles explain different validation workflows (six ‚Äôem) articles go Information Management workflow. Improved documentation almost functions package; added useful examples. Added table project README keeps everyone apprised project milestones issues closed upcoming release.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-6-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.6.0","text":"Improved appearance agent report: (1) tooltips, (2) tooltips much improved (animate, larger text, snappier previous ones), (3) SVGs now used symbols validation steps instead blurry PNGs, (4) less confusing glyphs now used TBL column, (5) agent label can expressed Markdown looks nicer report, (6) table type (name, supplied tbl_name) shown header, (7) validation threshold levels also shown table header, (8) interrogation starting/ending timestamps shown (along duration) table footer, (9) table font changed less default-y, (10) adjustments table borders cell shading made better readability. get_agent_report() function now lang locale arguments override values set prior (e.g., create_agent()). allows reporting language changed without need re-run everything scratch. set_tbl(), remove_tbl(), set_read_fn(), remove_read_fn() functions can now also used informant object. get_sundered_data() function clear regard validation steps considered splitting data. Using validation steps preconditions must fulfill rule target table single form across steps. is_exact argument new col_schema_match(), expect_col_schema_match(), test_col_schema_match() functions, allowing types validations less stringent. argument loosens requirement include class names column may multiple. Also, can specify NULL entirely skip checking class/type. can now use combinations validation functions conjointly(). validation functions intrinsically operate single test unit (e.g., col_is_*() functions) now work combination validation functions operate n test units (e.g., col_vals_*() functions). lets us test condition columns certain type individual test units fulfill col_vals_*() requirements. Simplified sections argument scan_data() length-1 character vector containing key characters standing section names. Refactored large portion code produces agent report increase rendering speed. Improved printing errors/warnings (tooltips EVAL column agent report) thanks implementation HTML escaping. small version agent report (perfect emailing) now much improved formatting.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-052","dir":"Changelog","previous_headings":"","what":"pointblank 0.5.2","title":"pointblank 0.5.2","text":"CRAN release: 2020-08-28 Fixes performance issue validations larger tables. Improved formatting value ranges agent report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-051","dir":"Changelog","previous_headings":"","what":"pointblank 0.5.1","title":"pointblank 0.5.1","text":"CRAN release: 2020-08-27 Improved compatibility validations performed SQL Server 2019. Integrated label argument validation functions; label available agent x_list , importantly, displayed agent report (STEP column). Added \"combined\" option get_sundered_data() function (type argument). applies categorical (pass/fail) label (settable new pass_fail argument function) new .pb_combined flag column output table. Made several visual improvements agent report.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-050","dir":"Changelog","previous_headings":"","what":"pointblank 0.5.0","title":"pointblank 0.5.0","text":"CRAN release: 2020-08-12","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"new-features-0-5-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.5.0","text":"agent can now given table-reading function, used reading data interrogation. tbl provided, function invoked. However, tbl read_fn specified, supplied tbl take priority (useful one-shot interrogations table interactive context). two ways specify read_fn: (1) using function (e.g., function() { <table reading code> }) , (2) R formula expression (e.g., ~ { <table reading code> }). Added set functions setting removing agent‚Äôs association data table (set_tbl() remove_tbl()) table-reading function (set_read_fn() remove_read_fn()). validation functions now step_id parameter. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. Supplying step_id optional; pointblank automatically generate step ID value (based step index) ‚Äôs provided. Added new functions reading writing YAML (, called pointblank YAML). pointblank YAML file can generated agent using agent_yaml_write() function. ‚Äôre always free create pointblank YAML hand, , can edit/extend existing pointblank YAML file. agent can created pointblank YAML agent_yaml_read() function. ‚Äôs also possible interrogate target data table right pointblank YAML using agent_yaml_interrogate(). agent_write() agent_read() functions added; allow saving agent disk reading agent back disk. Saved--disk agents still retain validation plans, intel interrogations, reference target table (read_fn value) even entire target table (requested). Reading agent disk agent_read() allows us use post-interrogation functions (e.g., get_agent_x_list(), get_data_extracts(), get_agent_report(), etc.) though interrogation just occurred. pointblank now compatible Spark DataFrames sparklyr package. Simply use tbl_spark object specifying target table create_agent(), set_tbl(), scan_data().","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-5-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.5.0","text":"issue showing agent report table email message body via email_blast() function resolved. Resolved issue using literal character values comparison-based validation functions (e.g., col_vals_between(), col_vals_gt(), etc.). Completely rewrote underlying processes storage retrieval translation text. Much improved translations reporting text Spanish German languages. Thanks @pachamaltese @DavZim valuable contributions! New testthat tests added test pointblank validations mock PostgreSQL MySQL database tables via dittodb package. Thank @pachamaltese implementing tests.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-040","dir":"Changelog","previous_headings":"","what":"pointblank 0.4.0","title":"pointblank 0.4.0","text":"CRAN release: 2020-06-22","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"new-r-markdown-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New R Markdown features","title":"pointblank 0.4.0","text":"New R Markdown validation feature allows validation testing within specialized validation code chunks validate = TRUE option set. Using pointblank validation functions data marked code chunks flag overall failure stop threshold exceeded anywhere. errors reported validation code chunk rendering document HTML, green red status buttons indicate whether validations succeeded failures occurred. Clicking button reveals otherwise hidden validation statements error messages (). Using pointblank R Markdown workflow enabled default pointblank library loaded. framework testing set default, new validate_rmd() function offers opportunity set UI logging options. Added R Markdown template new R Markdown validation feature (Pointblank Validation). new stop_if_not() function works well standalone, replacement stopifnot() also customized use validation checks R Markdown documents pointblank loaded. Using stop_if_not() code chunk validate = TRUE option set yield correct reporting successes failures whereas stopifnot() . knit.print() method added facilitate printing agent report table within R Markdown code chunk.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"breaking-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"pointblank 0.4.0","text":"default behavior using validation step functions (e.g., col_vals_lt()) directly data tables changed. , single test unit failure trigger warning. Now, single test unit failing results error. Going back earlier behavior now requires use actions = warn_on_fail() (new helper function, default warn_at threshold value 1) invocation validation step function. stop_on_fail() helper function also new release, stop_at threshold parameter, also default 1.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.4.0","text":"Added 24 expectation functions (e.g., expect_col_exists(), expect_rows_distinct(), expect_col_schema_match(), etc.) complements 24 validation functions. can used testthat tests tabular data simplified interface exposes easy--use failure threshold (defaulting 1). Added 24 test functions (e.g., test_col_exists(), test_rows_distinct(), test_col_schema_match(), etc.) complement 24 validation functions. functions return logical value: TRUE threshold (default 1) exceeded, FALSE otherwise. test_*() functions use simplified interface expect_*() functions. Added col_vals_expr(), expect_col_vals_expr(), test_col_vals_expr() validation, expectation, test functions, making easier DIY validations. dplyr expr(), case_when(), () functions re-exported easier accessibility since work exceedingly well new functions. col_schema_match() (expect test analogues) gained new arguments: complete in_order. allow relaxation constraints related completeness ordering columns defined col_schema object (created col_schema()). preconditions argument available validation, expectation, test functions now accepts formula function values (previously, formula values accepted). get_agent_report() function now size argument option get agent report table \"standard\" (width: 875px) size \"small\" size (width: 575px); previously option accessible .... appearance agent report improved ‚Äôs gained new features: (1) data extracts failing rows (row-based validation steps) can downloaded CSVs via new buttons appear EXT column, (2) useful tooltips fields table (e.g., hovering items STEP show brief, TBL icons describe whether preconditions applied table prior interrogation, etc.), (3) printing improvements COLUMNS VALUES columns (e.g., table columns distinguished literal values). Improved appearance email message generated email_blast() email_preview(). email message, using stock_msg_body() stock_msg_footer() defaults msg_body msg_footer, embeds \"small\" version agent report provides introductory text nicer formatting .","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"documentation-improvements-0-4-0","dir":"Changelog","previous_headings":"","what":"Documentation improvements","title":"pointblank 0.4.0","text":"functions now revised documentation complete, examples, consistent across many validation, expectation, test functions. package README now contains better graphics, reworked examples, new section package‚Äôs design goals (listing R packages also focus table validation).","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-4-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.4.0","text":"Rewrote internal stock_stoppage() stock_warning() functions generated error warning messages match whether validation functions used directly data expectation functions used. Console status messages performing interrogation now appear interactive session. longer appear R Markdown rendering execution unattended scripts. col_vals_regex() validation function (plus associated expectation test functions) can now used database tables (DB types support regular expressions). tested MySQL PostgreSQL, differing underlying SQL implementations. col_schema() function now allows either uppercase lowercase SQL column types (using .db_col_types = \"sql\"). Previously, supplying SQL columns types uppercase (e.g., ‚ÄúINT‚Äù, ‚ÄúTINYINT‚Äù, etc.) always fail validation SQL column types target table captured lowercase values create_agent() call. Many new tests added cover new functions existing functions. ‚Äôs important validation package testing comprehensive rigorous, , continue focus forthcoming releases. Fixed duration label bug console status messages appear interrogation (now consistently values reported seconds) Added column validity checks inside internal interrogate_*() functions","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-031","dir":"Changelog","previous_headings":"","what":"pointblank 0.3.1","title":"pointblank 0.3.1","text":"Fixed implementation col_vals_between() col_vals_not_between() step functions work tbl_dbi objects. Added scan_data() function, thoroughly scans table data can understand better (giving HTML report). Added get_agent_x_list() function provide easy access agent intel Added get_agent_report() function give fine control agent‚Äôs gt-based reportage; also, agent‚Äôs default print method now report (default appearance options) Added get_sundered_data() function split table data ‚Äòpass‚Äô ‚Äòfail‚Äô pieces interrogation Added col_schema_match() validation step function; works conjunction col_schema object (generated col_schema() function) help determine whether expected schema matches target table. Added multilingual support reports generated agent validations produced new scan_data() function fully integrates gt (tables reports) blastula (email production delivery) packages Numerous fixes ensure compatibility tibble 3.0.0","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-030","dir":"Changelog","previous_headings":"","what":"pointblank 0.3.0","title":"pointblank 0.3.0","text":"CRAN release: 2020-01-10 pointblank package changed significantly previous version favor consistency simplicity, better reporting, increased power. internals extensively refactored API accordingly gone revisions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"breaking-changes-0-3-0","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"pointblank 0.3.0","text":"focus_on() function removed favor directly using data object. means single use create_agent() can now work single table time (create_agent() now tbl argument). Also, input tbl can data.frame, tbl_df, tbl_dbi object. preconditions argument changed can now used temporarily transform table (.e., transforming particular validation step). Previously, option filter input table now ‚Äôs possible useful things like joining table, adding columns, filtering rows, etc. preconditions args now accepts list expressions manipulate table data. action_levels() helper function introduced work actions argument (every validation step function). replaces warn_count, stop_count, notify_count, warn_fraction, stop_fraction, notify_fraction arguments. function allows evaluation functions (given fns argument) reaction exceeding thresholds specified warn_at, stop_at, notify_at. using validation step functions directly data (.e., use create_agent()), data now passed straight validation step. purpose now mode create warnings throw errors warn stop thresholds exceeded. Across pointblank validation step functions, argument stands table columns normalized columns. incl_na argument, implemented validation step functions, renamed na_pass better indicate purpose (consider encountered NA values passing test units), , use expanded relevant functions.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"new-features-0-3-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"pointblank 0.3.0","text":"‚Äôs now possible use vars() certain tidyselect select helpers (e.g., starts_with()) defining columns pointblank validation step functions. conjointly() function new validation step function allows multiple rowwise validation steps performed joint validity testing.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-021","dir":"Changelog","previous_headings":"","what":"pointblank 0.2.1","title":"pointblank 0.2.1","text":"CRAN release: 2019-09-12 Revisions account API changes tidyr 1.0.0. Incorporates corrections related API changes rlang 0.2.0.","code":""},{"path":"https://rich-iannone.github.io/pointblank/news/index.html","id":"pointblank-01","dir":"Changelog","previous_headings":"","what":"pointblank 0.1","title":"pointblank 0.1","text":"CRAN release: 2017-08-22 First release.","code":""}]
