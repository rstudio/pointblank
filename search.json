[{"path":[]},{"path":"https://rstudio.github.io/pointblank/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://rstudio.github.io/pointblank/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://rstudio.github.io/pointblank/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://rstudio.github.io/pointblank/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://rstudio.github.io/pointblank/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement rich@posit.co. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://rstudio.github.io/pointblank/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://rstudio.github.io/pointblank/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://rstudio.github.io/pointblank/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://rstudio.github.io/pointblank/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://rstudio.github.io/pointblank/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://rstudio.github.io/pointblank/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired Mozilla’s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://rstudio.github.io/pointblank/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Information and Guidelines for Contributing to pointblank","title":"Information and Guidelines for Contributing to pointblank","text":"many ways contribute ongoing development pointblank package. contributions can rather easy (e.g., fixing typos, improving documentation, filing issues feature requests problems, etc.) whereas contributions can require time patience (like answering questions submitting pull requests code changes). Just know help provided capacity much appreciated. :)","code":""},{"path":"https://rstudio.github.io/pointblank/CONTRIBUTING.html","id":"filing-issues","dir":"","previous_headings":"","what":"Filing Issues","title":"Information and Guidelines for Contributing to pointblank","text":"believe found bug, create minimal reprex posting pointblank issue tracker. Try include anything unnecessary, just minimal amount code constitutes reproducible bug. try verify bug running code reprex provided. quality reprex reduce amount back--forth communication trying understand execute code systems.","code":""},{"path":"https://rstudio.github.io/pointblank/CONTRIBUTING.html","id":"answering-questions","dir":"","previous_headings":"","what":"Answering questions","title":"Information and Guidelines for Contributing to pointblank","text":"great way help simply answering questions. ’s amazing little conversation lead better insights problem. Don’t quite know answer? ’s okay . ’re together. might answer user questions? forums Q&pointblank include Posit community, Bluesky (good search term pointblank #rstats), Stack Overflow. Good etiquette key interactions: good person ask questions.","code":""},{"path":"https://rstudio.github.io/pointblank/CONTRIBUTING.html","id":"making-pull-requests","dir":"","previous_headings":"Answering questions","what":"Making Pull Requests","title":"Information and Guidelines for Contributing to pointblank","text":"consider making pull request (PR), please file issue first explain problem detail. PR enhancement, detail change make things better package users. Bugfix PRs also requre explanation bug proposed fix remove bug. great way illustrate bug include reprex. upfront work prior preparing PR can time-consuming opens line communication package authors community, perhaps leading better enhancement effective fixes! consensus PR based issue helpful, adhering following process make things proceed quickly: Create separate Git branch PR. Look GitHub Actions build status badges making changes; badges available package README. pointblank package follows tidyverse style guide please adopt style guidelines submitted code best possible. internal documentation uses roxygen2; contribution requires new revised documentation ensure roxygen comments added/modified (modify .Rd files man folder). use testthat code coverage; contributions test cases included helpful easier accept.","code":""},{"path":"https://rstudio.github.io/pointblank/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2017-2025 Posit Software, PBC Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://rstudio.github.io/pointblank/PULL_REQUEST_TEMPLATE.html","id":null,"dir":"","previous_headings":"","what":"Summary","title":"Summary","text":"Thank contributing pointblank! make process easier everyone, please explain context purpose contribution. Also, list changes made existing code documentation.","code":""},{"path":"https://rstudio.github.io/pointblank/PULL_REQUEST_TEMPLATE.html","id":"related-github-issues-and-prs","dir":"","previous_headings":"","what":"Related GitHub Issues and PRs","title":"Summary","text":"Ref: #","code":""},{"path":"https://rstudio.github.io/pointblank/PULL_REQUEST_TEMPLATE.html","id":"checklist","dir":"","previous_headings":"","what":"Checklist","title":"Summary","text":"understand agree Code Conduct. listed major changes NEWS. added testthat unit tests tests/testthat new functionality.","code":""},{"path":"https://rstudio.github.io/pointblank/articles/INFO-1.html","id":"starting-with-a-simple-example","dir":"Articles","previous_headings":"","what":"Starting with a Simple Example","title":"Intro to Information Management","text":"workflow somewhat similar concept usage Data Quality Reporting Workflow (VALID-). Instead agent, use informant get informant create_informant() function. point informant target table can data frame, tibble, database table (tbl_dbi object), Spark DataFrame (tbl_spark object). small_table dataset included pointblank package. ’s small, uninteresting dataset ’s useful simple examples. looks like: Let’s use small_table object see results introducing informant. Printing informant show us automatically-generated information small_table dataset, adding Columns section.  Alternatively can get report get_informant_report() access additional output options, like producing narrower version output.  Either way, get initial reporting basic. done next add information following set info_*() functions: info_tabular(): Add information focuses aspects data table whole info_columns(): Add information focuses aspects data table’s columns info_section(): Add information focuses key aspect data table Let’s try adding information functions look resulting report.  can seen, report bit filled information. TABLE COLUMNS sections prescribed order new section named INFORMATION follows (one subsection called EXAMPLES DOCUMENTATION). Let’s explore three different info_*() functions work.","code":"small_table ## # A tibble: 13 × 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high informant <-    create_informant(     tbl = small_table,     tbl_name = \"small_table\",     label = \"Example No. 1\"   ) informant get_informant_report(informant, size = \"small\") informant <-   create_informant(     tbl = small_table,     tbl_name = \"small_table\",     label = \"Example No. 2\"   ) %>%   info_tabular(     description = \"This table is included in the **pointblank** pkg.\"   ) %>%   info_columns(     columns = date_time,     info = \"This column is full of timestamps.\"   ) %>%   info_section(     section_name = \"further information\",      `examples and documentation` = \"Examples for how to use the `info_*()` functions     (and many more) are available at the      [**pointblank** site](https://rstudio.github.io/pointblank/).\"   )  informant"},{"path":"https://rstudio.github.io/pointblank/articles/INFO-1.html","id":"the-table-section-and-info_tabular","dir":"Articles","previous_headings":"","what":"The TABLE Section and info_tabular()","title":"Intro to Information Management","text":"info_tabular() function adds information TABLE section. use named arguments define subsection names content. previous example info_tabular(description = \"table included **pointblank** pkg.\") used make DESCRIPTION subsection (section titles automatically capitalized), info text Markdown text \"table included **pointblank** pkg.\". can define many subsections TABLE section need, either info_tabular() call across multiple calls. want use complicated subsection names single word, can enclose text back ticks. example, put emoji subsection name? excerpt complete report, showing just report header TABLE section.  TABLE section great place put information table needs front center. Examples useful topics section might include: high-level summary table, stating purpose importance row table represents main users table within organization description table generated information frequency updates","code":"informant %>%    info_tabular(\"🔄 updates\" = \"This table is not regularly updated.\")"},{"path":"https://rstudio.github.io/pointblank/articles/INFO-1.html","id":"the-columns-section-and-info_columns","dir":"Articles","previous_headings":"","what":"The COLUMNS Section and info_columns()","title":"Intro to Information Management","text":"section follows TABLE section COLUMNS. section provides opportunity describe table column much detail necessary. , individual columns serve subsections (automatically generated upon using create_informant()) can subsections within column well. interesting thing information provided via info_columns() information additive. can make multiple calls info_columns() disperse common pieces info text multiple columns append text existing. Let’s take look practice far interesting palmerpenguins::penguins dataset. , fill information column adapting documentation palmerpenguins package.  able provide subsections name ℹ️ , furthermore, use tidyselect functions like ends_with() append info text common subsection exists across multiple columns. useful stating units common across three columns: bill_length_mm, bill_depth_mm, flipper_length_mm. following tidyselect functions available pointblank make process easier: starts_with(): Match columns start prefix. ends_with(): Match columns end suffix. contains(): Match columns contain literal string. matches(): Perform matching regular expression. everything(): Select columns.","code":"informant_pp <-    create_informant(     tbl = palmerpenguins::penguins,     tbl_name = \"penguins\",     label = \"The `penguins` dataset from the **palmerpenguins** 📦.\"   ) %>%    info_columns(     columns = species,     `ℹ️` = \"A factor denoting penguin species (*Adélie*, *Chinstrap*, and *Gentoo*).\"   ) %>%   info_columns(     columns = island,     `ℹ️` = \"A factor denoting island in Palmer Archipelago, Antarctica     (*Biscoe*, *Dream*, or *Torgersen*).\"   ) %>%   info_columns(     columns = bill_length_mm,     `ℹ️` = \"A number denoting bill length\"   ) %>%   info_columns(     columns = bill_depth_mm,     `ℹ️` = \"A number denoting bill depth\"   ) %>%   info_columns(     columns = flipper_length_mm,     `ℹ️` = \"An integer denoting flipper length\"   ) %>%   info_columns(     columns = ends_with(\"mm\"),     `ℹ️` = \"(in units of millimeters).\"   ) %>%   info_columns(     columns = body_mass_g,     `ℹ️` = \"An integer denoting body mass (grams).\"   ) %>%   info_columns(     columns = sex,     `ℹ️` = \"A factor denoting penguin sex (`\\\"female\\\"`, `\\\"male\\\"`).\"   ) %>%   info_columns(     columns = year,     `ℹ️` = \"The study year (e.g., `2007`, `2008`, `2009`).\"   )  informant_pp"},{"path":"https://rstudio.github.io/pointblank/articles/INFO-1.html","id":"extra-sections-and-info_section","dir":"Articles","previous_headings":"","what":"Extra Sections and info_section()","title":"Intro to Information Management","text":"information can’t don’t want put TABLE COLUMNS sections, can place extra sections (subsections) info_section() function. sections go aforementioned sections order creation. Let’s put together extra sections describe palmerpenguins::penguins dataset. excerpt complete report, showing just SOURCE section footer.  types information go well separate sections? ideas : info related source data table (e.g., references, background, etc.) definitions/explanations terms used persons responsible data table, perhaps contact information details table produced important issues table notes upcoming changes links information artifacts pertain table information report (meta!); might include things like update history, persons responsible, instructions contribute, etc. Really, sky limit ! can incorporate great deal useful information use process generate reports important tables within organization. ’s can done. go next phase (Advanced Information Management article). go way now, total transformation. think ’re ready?","code":"informant_pp <-    informant_pp %>%   info_section(     section_name = \"source\",     \"References\" = c( \"- Adélie penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural  size measurements and isotopic signatures of foraging among adult male and female  Adélie penguins (Pygoscelis adeliae) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental Data Initiative <https://doi.org/10.6073/pasta/98b16d7d563f265cb52372c8ca99e60f>\",  \"- Gentoo penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural size measurements and isotopic signatures of foraging among adult male and female Gentoo penguin (Pygoscelis papua) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental Data Initiative <https://doi.org/10.6073/pasta/7fca67fb28d56ee2ffa3d9370ebda689>\",  \"- Chinstrap penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. Structural size measurements and isotopic signatures of foraging among adult male and female Chinstrap penguin (Pygoscelis antarcticus) nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 6. Environmental Data Initiative <https://doi.org/10.6073/pasta/c14dfcfada8ea13a17536e73eb6fbe9e> \"     ),     \"Note\" = \" Originally published in: Gorman KB, Williams TD, Fraser WR (2014) Ecological Sexual Dimorphism and Environmental Variability within a Community of Antarctic Penguins (Genus Pygoscelis). PLoS ONE 9(3): e90081. doi:10.1371/journal.pone.0090081 \" )  informant_pp"},{"path":"https://rstudio.github.io/pointblank/articles/INFO-2.html","id":"getting-snippets-of-useful-text-with-the-info_snippet-function","dir":"Articles","previous_headings":"","what":"Getting Snippets of Useful Text With the info_snippet() Function","title":"Advanced Information Management","text":"great source information table can table . Suppose want show categorical values particular column. Maybe ’d like display range values important numeric column. Perhaps show KPI values can calculated using data table? can done info_snippet() function. give snippet name give function call. Let’s small_table dataset available pointblank. table looks like: wanted mean value data column d rounded one decimal place, one way expression: Inside info_snippet() call, used creating informant object, expression look like : small_table dataset associated informant target table, , ’s represented leading . functional sequence given fn inside info_snippet(). ’s important note ’s leading ~, making expression RHS formula (.e., don’t want execute anything , time). Lastly, snippet given name \"mean_d\". know snippet produce value 2304.7 can ? put value info text use snippet_name key. works similarly glue package text interpolation, ’s continuation example: Within text, ’s use curly braces name snippet ({mean_d}). ’s 2304.7 value inserted. methodology inserting computed values snippets can performed wherever info text provided (either info_tabular(), info_columns(), info_section() functions). Let’s take look report printing informant object  Hmm. \"... {mean_d} ...\" text report replaced mean value column d. gives? Well, ’s one finalizing step needs done always done wrap Information Management workflow use incorporate() function. Let’s write whole thing finish call incorporate().  time, sweet success. value appears overall formatting looks great! useful thing, long remember use incorporate() function make happen (next section).","code":"small_table ## # A tibble: 13 × 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high small_table %>% .$d %>% mean() %>% round(1) ## [1] 2304.7 informant <-    create_informant(     tbl = small_table,     tbl_name = \"small_table\",     label = \"Example No. 2\"   ) %>%   info_snippet(     snippet_name = \"mean_d\",     fn = ~ . %>% .$d %>% mean() %>% round(1)   ) informant <-    informant %>%   info_columns(     columns = d,     info = \"This column contains fairly large numbers (much larger than     those numbers in column `a`. The mean value is {mean_d}, which is     far greater than any number in that other column.\"   ) informant informant <-    create_informant(     tbl = small_table,     tbl_name = \"small_table\",     label = \"Example No. 2\"   ) %>%   info_snippet(     snippet_name = \"mean_d\",     fn = ~ . %>% .$d %>% mean() %>% round(1)   ) %>%     info_columns(     columns = d,     info = \"This column contains fairly large numbers (much larger than     those numbers in column `a`. The mean value is {mean_d}, which is     far greater than any number in that other column.\"   ) %>%   incorporate()  informant"},{"path":"https://rstudio.github.io/pointblank/articles/INFO-2.html","id":"ensuring-that-snippets-and-other-table-metadata-element-are-up-to-date","dir":"Articles","previous_headings":"","what":"Ensuring That Snippets (and Other Table Metadata Element) Are Up-to-Date","title":"Advanced Information Management","text":"Tables can change time. Whether data source public dataset, organization’s data table, continually-updated Excel file (😱), ready change. previous example, used incorporate() function finalize report. Without , snippet didn’t work. two major things incorporate() Information Management workflow. Evaluation text snippets info_snippet() calls, , insertion snippets info text within \"{<snippet_name>}\". Updating table row column counts header report. really incorporating aspects table report incorporate() might also think regenerating, refreshing, renewing table. gives pointblank license access table way interrogate() VALID-validation workflow. first use incorporate(), text snippets put places; subsequent uses incorporate() replace appropriate text necessary. Every use incorporate() update row column counts header. ’s short demo header changing, ’s pretty instructive. Let’s use small_table object target_table. dim() can totally sure table dimensions. Let’s allow informant access target_table tbl argument , case, expression ~ target_table (simply gets table global workspace). using incorporate() printing informant_tt object, let’s just examine header. excerpt complete report, showing just header.  number rows columns reported header checks : 13 rows 8 columns. Now, let’s manually enlarge target_table print new row column counts. ’ve got informant object, let’s see incorporate() keeps pace change. excerpt complete report, showing just header.  Great! Using incorporate() accurately updated reporting row column counts header. ’s also much worth noting use tbl = ~ target_table rather tbl = target_table important . latter used create_informant(), table bound informant initial state (13 rows 8 columns) updates table wouldn’t reflected reporting upon using incorporate(). table-prep formula used meant re-obtaining table every time table needed. short, unless uses info_snippet() table isn’t expected change, ’s recommended use incorporate() final call workflow.","code":"target_table <- small_table  dim(target_table) ## [1] 13  8 informant_tt <-    create_informant(     tbl = ~ target_table,     tbl_name = \"target_table\",     label = \"Example No. 3\"   ) %>%   incorporate()  informant_tt target_table <-    dplyr::bind_rows(small_table, small_table) %>%   dplyr::mutate(g = a + c)  dim(target_table) ## [1] 26  9 informant_tt %>% incorporate()"},{"path":"https://rstudio.github.io/pointblank/articles/INFO-2.html","id":"helpful-pointblank-functions-that-work-exceedingly-well-with-info_snippet","dir":"Articles","previous_headings":"","what":"Helpful pointblank Functions that Work Exceedingly Well with info_snippet()","title":"Advanced Information Management","text":"functions available pointblank make much easier get commonly-used text snippets. begin snip_ prefix : snip_list(): Gets list column categories snip_lowest(): Gets lowest value column snip_highest(): Gets highest value column functions can used directly fn value don’t specify table since assumed target table ’ll snipping data . Let’s look action.","code":""},{"path":"https://rstudio.github.io/pointblank/articles/INFO-2.html","id":"the-snip_list-function","dir":"Articles","previous_headings":"Helpful pointblank Functions that Work Exceedingly Well with info_snippet()","what":"The snip_list() Function","title":"Advanced Information Management","text":"describing aspect target table, may want extract values column include piece info text. ’d want values nicely formatted list (commas) ’d probably prefer constrained certain size (potentially generate massive amounts text). can efficiently done snip_list(). Let’s experiment combination snip_list() info_snippet(), extending palmerpenguins example Intro Information Management article. excerpt complete report, showing just header part COLUMNS section.  seemed work quite well. need determining strings hardcoding info text, snip_list() work . also works numeric values. Let’s use snip_list() provide text snippet based values year column (integer column): excerpt complete report, showing just bottom COLUMNS section footer.  , issues formatting display values. got info text \"study year (\"2007\", \"2008\", \"2009\" ).\" efforts saved us determine , plus, data updated new year values, reflected info text upon using incorporate(). Refreshed info text really provides huge benefits, especially data changes lot (e.g., database tables).","code":"informant_pp <-    create_informant(     tbl = ~ palmerpenguins::penguins,     tbl_name = \"penguins\",     label = \"The `penguins` dataset from the **palmerpenguins** 📦.\"   ) %>%    info_columns(     columns = species,     `ℹ️` = \"A factor denoting penguin species ({species_snippet}).\"   ) %>%   info_columns(     columns = island,     `ℹ️` = \"A factor denoting island in Palmer Archipelago, Antarctica     ({island_snippet}).\"   ) %>%   info_snippet(     snippet_name = \"species_snippet\",     fn = snip_list(column = \"species\")   ) %>%   info_snippet(     snippet_name = \"island_snippet\",     fn = snip_list(column = \"island\")   ) %>%   incorporate()  informant_pp informant_pp <-   informant_pp %>%   info_columns(     columns = year,     `ℹ️` = \"The study year ({year_snippet}).\"   ) %>%   info_snippet(     snippet_name = \"year_snippet\",     fn = snip_list(column = \"year\")   ) %>%   incorporate()  informant_pp"},{"path":"https://rstudio.github.io/pointblank/articles/INFO-2.html","id":"the-snip_lowest-and-snip_highest-functions","dir":"Articles","previous_headings":"Helpful pointblank Functions that Work Exceedingly Well with info_snippet()","what":"The snip_lowest() and snip_highest() Functions","title":"Advanced Information Management","text":"can get lowest highest values column inject formatted values info_text. Let’s measured values penguins dataset snip_lowest() snip_highest().  can see report output can creatively use lowest highest values obtained snip_lowest() snip_highest() specify range simply show maximum value. ordering info_columns() calls example affects overall layout text (text appending behavior), placement info_snippet() calls matter. , , must use incorporate() update text snippets render appropriate locations (inside {<snippet_name>}).","code":"informant_pp <-   informant_pp %>%   info_columns(     columns = bill_length_mm,     `ℹ️` = \"A number denoting bill length\"   ) %>%   info_columns(     columns = bill_depth_mm,     `ℹ️` = \"A number denoting bill depth (in the range of     {min_depth} to {max_depth} millimeters).\"   ) %>%   info_columns(     columns = flipper_length_mm,     `ℹ️` = \"An integer denoting flipper length\"   ) %>%   info_columns(     columns = matches(\"length\"),     `ℹ️` = \"(in units of millimeters).\"   ) %>%   info_columns(     columns = flipper_length_mm,     `ℹ️` = \"Largest observed is {largest_flipper_length} mm.\"   ) %>%   info_snippet(     snippet_name = \"min_depth\",     fn = snip_lowest(column = \"bill_depth_mm\")   ) %>%   info_snippet(     snippet_name = \"max_depth\",     fn = snip_highest(column = \"bill_depth_mm\")   ) %>%   info_snippet(     snippet_name = \"largest_flipper_length\",     fn = snip_highest(column = \"flipper_length_mm\")   ) %>%   incorporate()  informant_pp"},{"path":"https://rstudio.github.io/pointblank/articles/INFO-2.html","id":"text-tricks","dir":"Articles","previous_headings":"","what":"Text Tricks","title":"Advanced Information Management","text":"info text can jazzed Markdown, extra tricks make authoring text bit pleasurable. know text tricks ’ll able express information many interesting ways.","code":""},{"path":"https://rstudio.github.io/pointblank/articles/INFO-2.html","id":"links-and-dates","dir":"Articles","previous_headings":"Text Tricks","what":"Links and Dates","title":"Advanced Information Management","text":"links text, pointblank try identify style nicely. amounts using pleasing, light-blue color underlines appear hover. doesn’t take much style links require something. , Markdown links written < link url > [ link text ]( link url ) get transformation treatment. Sometimes want dates stand text. Try enclosing date expressed ISO-8601 standard parentheses, like : (2004-12-01). happen date set monospaced variation reporting font, , underlined striking shade purple. ’s might use features otherwise adding information palmerpenguins reporting: excerpt complete report, showing just TABLE section header.","code":"informant_pp <-   informant_pp %>%   info_tabular(     `R dataset` = \"The goal of `palmerpenguins` is to provide a great dataset     for data exploration & visualization, as an alternative to `iris`. The     latest CRAN release was published on (2020-07-25).\",     `data collection` = \"Data were collected and made available by Dr. Kristen     Gorman and the [Palmer Station, Antarctica LTER](https://pal.lternet.edu),     a member of the [Long Term Ecological Research Network](https://lternet.edu).\",     citation = \"Horst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer      Archipelago (Antarctica) penguin data. R package version 0.1.0.     <https://allisonhorst.github.io/palmerpenguins/>.      doi: 10.5281/zenodo.3960218.\"   ) %>%   incorporate()  informant_pp"},{"path":"https://rstudio.github.io/pointblank/articles/INFO-2.html","id":"labels","dir":"Articles","previous_headings":"Text Tricks","what":"Labels","title":"Advanced Information Management","text":"can take portions text present labels. help call important attributes short form may eliminate need oft-repeated statements. might apply labels signify priority, category, information find useful. two options, Use double parentheses around text capture rectangular label: ((label text)) Use triple parentheses capture text rounded-rectangular label: (((label text))) excerpt complete report, showing just COLUMNS ADDITIONAL NOTES sections.","code":"informant_pp <-   informant_pp %>%   info_columns(     columns = body_mass_g,      `ℹ️` = \"An integer denoting body mass.\"   ) %>%   info_columns(     columns = c(ends_with(\"mm\"), ends_with(\"g\")),     `ℹ️` = \"((measured))\"       ) %>%   info_section(     section_name = \"additional notes\",     `data types` = \"(((factor))) (((numeric))) (((integer)))\"   ) %>%   incorporate()  informant_pp"},{"path":"https://rstudio.github.io/pointblank/articles/INFO-2.html","id":"get-stylin","dir":"Articles","previous_headings":"Text Tricks","what":"Get Stylin’","title":"Advanced Information Management","text":"want use CSS styles spans info text, ’s possible following construction: [[ info text ]]<< CSS style rules >> ’s important ensure CSS rule concluded ; character syntax. Styling word factor inside piece info text might look like : [[factor]]<<color: red; font-weight: 300;>> value. result looks something like :  many CSS style rules can used. ’s sample useful ones: color: <color value>; (text color) background-color: <color value>; (text’s background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); Continuing palmerpenguins reporting, ’ll add info text take opportunity add CSS style rules using [[ ]]<< >> syntax. excerpt complete report, showing just bottom COLUMNS section, ADDITIONAL NOTES section, footer.  info_columns() info_section() function calls, able style single word (underline) even style labels (changing border background colors). syntax somewhat forgiving, allowing put line breaks ]] << style rules lines markup don’t overly long. , think text tricks? got admit can spice proceedings. inevitably added development pointblank proceeds. ’s now. Don’t think ’ve enough?","code":"informant_pp <-   informant_pp %>%   info_columns(     columns = sex,      `ℹ️` = \"A [[factor]]<<text-decoration: underline;>>      denoting penguin sex (female or male).\"   ) %>%   info_section(     section_name = \"additional notes\",     keywords = \"     [[((penguins))]]<<border-color: platinum; background-color: #F0F8FF;>>      [[((Antarctica))]]<<border-color: #800080; background-color: #F2F2F2;>>      [[((measurements))]]<<border-color: #FFB3B3; background-color: #FFFEF4;>>     \"   ) %>%   incorporate()  informant_pp"},{"path":"https://rstudio.github.io/pointblank/articles/VALID-I.html","id":"the-elements-of-this-workflow-an-agent-validation-functions-and-interrogate","dir":"Articles","previous_headings":"","what":"The Elements of this Workflow: an agent, validation functions, and interrogate()","title":"Introduction to the Data Quality Reporting Workflow (VALID-I)","text":"agent need workflow created create_agent() function. agent can handle one target table given time tbl argument target specified. can supply input table directly agent giving tbl table object. Alternatively, can make table read interrogation-time. useful situations might deploy agent YAML file. ‘lazy reading’ target table can accomplished two ways: (1) using ‘table-prep formula’, one-sided R formula expression (e.g., ~ <table reading code>), (2) providing function (e.g., function() { <table reading code> }). agent needs directives table, , provide validation functions. check existence type column (col_exists() group col_is_*() functions). Others check cell column satisfying specific condition (col_vals_*() functions). can use many necessary satisfactory validation testing table question. certainly quite , ’s list validation functions questioning phrase function’s purpose: col_vals_lt(): column data less specified value? col_vals_lte(): column data less equal specified value? col_vals_equal(): column data equal specified value? col_vals_not_equal(): column data equal specified value? col_vals_gte(): column data greater equal specified value? col_vals_gt(): column data greater specified value? col_vals_between(): column data two specified values? col_vals_not_between(): column data two specified values? col_vals_in_set(): column data part specified set values? col_vals_not_in_set(): data part specified set values? col_vals_make_set(): set values entirely accounted column values? col_vals_make_subset(): set values subset column values? col_vals_increasing(): column data increasing row? col_vals_decreasing(): column data decreasing row? col_vals_null(): column data NULL/NA? col_vals_not_null(): column data NULL/NA? col_vals_regex(): strings column data match regex pattern? col_vals_within_spec(): values column data fit within specification? col_vals_expr(): column data agree predicate expression? rows_distinct(): row data distinct? rows_complete(): row data complete? col_is_character(): columns contain character/string data? col_is_numeric(): columns contain numeric values? col_is_integer(): columns contain integer values? col_is_logical(): columns contain logical values? col_is_date(): columns contain R Date objects? col_is_posix(): columns contain POSIXct dates? col_is_factor(): columns contain R factor objects? col_exists(): one columns actually exist? col_schema_match(): columns table (types) match predefined schema? row_count_match(): row count match different table? col_count_match(): column count match different table? tbl_match(): target table match comparison table? conjointly(): multiple rowwise validations result joint validity? serially(): Run several tests final validation serial manner specially(): Perform specialized validation user-defined function final function needs called interrogate() function. validation functions, called agent object, don’t act target table interrogate() used. fact, interrogation, usage validation functions serves instructions (building interrogation plan). interrogation phase (.e., calling interrogate()) instructions turn actions, agent carrying validation steps interrogation plan.","code":""},{"path":"https://rstudio.github.io/pointblank/articles/VALID-I.html","id":"a-simple-example-with-the-basics","dir":"Articles","previous_headings":"","what":"A Simple Example with the Basics","title":"Introduction to the Data Quality Reporting Workflow (VALID-I)","text":"examples going forward, ’ll use small_table dataset. ’s included pointblank package. isn’t large, makes great simple examples. entirety: follows simple validation plan. test : date_time column indeed date-time column column f values \"low\", \"mid\", \"high\" values column less 10 strings column b fit particular regex pattern (\"^[0-9]-[-z]{3}-[0-9]{3}$\") column d values range 0 5000 (entirely true!) validation plan written interrogated. carried interactively, ’ll get status messages describe interrogation going. five OK messages means individual validations five validation steps passed within failure threshold levels. Since failure thresholds actually weren’t set, steps always display OK unless evaluation error occurred (e.g., attempting interrogate column isn’t present target table). Printing agent object gives step--step breakdown interrogation process.  Let’s look interpret report. bright green color strips left validation step indicates test units passed validation. lighter green color final step means least one failing unit. STEP column provides name validation function used basis validation step. COLUMNS shows us target column validation step. VALUES column lists values required validation step. TBL? indicates whether table mutated just interrogation validation step (via preconditions argument, available every validation function). right-facing arrows indicate table didn’t undergo transformation, working identity table every step. EVAL lets us know whether issues evaluating table (catching R errors warnings); checkmarks column show us issues interrogation. total number test units provided next ... column, absolute number fraction passing test units (PASS) failing test units (FAIL). W, S, N indicators tell us whether entered either WARN, STOP, NOTIFY states validation steps. didn’t set threshold levels states (can done actions argument, later), irrelevant report. Finally, EXT column provides opportunity download data extract rows CSV. rows represent rows failed test units. step 5, col_vals_between() validation step, data extract available (1 row). can either download CSV report examine extract R get_data_extracts() function: Recall validation step 5 asserted values column d 0 5000, however, extract small_table shows column d value 10000 lies outside specified range.","code":"small_table ## # A tibble: 13 × 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high agent <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"VALID-I Example No. 1\"   ) %>%   col_is_posix(date_time) %>%   col_vals_in_set(f, set = c(\"low\", \"mid\", \"high\")) %>%   col_vals_lt(a, value = 10) %>%   col_vals_regex(b, regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\") %>%   col_vals_between(d, left = 0, right = 5000) %>%   interrogate() ── Interrogation Started - there are 5 steps ────────────────────────────────── ✓ Step 1: OK. ✓ Step 2: OK. ✓ Step 3: OK. ✓ Step 4: OK. ✓ Step 5: OK.  ── Interrogation Completed ───────────────────────────────────────────────── agent get_data_extracts(agent, i = 5) ## # A tibble: 1 × 8 ##   date_time           date           a b             c      d e     f     ##   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ## 1 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low"},{"path":"https://rstudio.github.io/pointblank/articles/VALID-I.html","id":"using-threshold-levels-and-actions","dir":"Articles","previous_headings":"","what":"Using Threshold Levels and Actions","title":"Introduction to the Data Quality Reporting Workflow (VALID-I)","text":"can useful gauge data quality setting failure thresholds validation steps. example, may acceptable point time tolerate 5% failing test units given validation. , several levels data quality might useful instructive, failing test units across validations grouped 0-5%, 5-10%, 10%- bands. can specify failure threshold levels action_levels() function. Using function generates action_levels object can passed actions argument create_agent() (thereby creating default every validation step). following, use relative values (real numbers 0 1) define thresholds WARN STOP conditions. Printing al object gives us summary settings. Let’s use action_levels object new validation. ’s similar last one parameters validation functions result failing test units. ’ll see interrogation messages show mention STOP WARNING conditions met. Printing agent provide different agent report seen previously, one ’s rife yellow red color strips left matching colors far right columns.  ’s possible invoke function particular failure condition met can set action_levels() function made part action_levels object. One example function can used included log4r_step() function logging failure conditions across validation steps. Let’s make new action_levels object include logging function WARN STOP failure conditions. Note function calls must written one-sided R formulas. Printing new al object show us failure threshold settings associated actions failure conditions. Using new al object validation workflow result failures certain validation steps logged. default, file named \"pb_log_file\" working directory log4r_step() function flexible allowing log4r appender used. Running following data validation code show us messages R console file \"pb_log_file\" can looked readLines(), showing us four entries (one validation step least WARN condition). log4r_step() function bit special provides severe condition given validation step, long function call present multiple conditions list() given action_levels()’s fns argument. ’s possible provide custom-made function generates side effect way log4r_step() used. Just like log4r_step(), custom function can take advantage x variable, x-list validation step. Let’s take look step 2 (col_vals_in_set validation step) using get_agent_x_list() function: message console shows us ’s available x, indication output types. wanted know number test units, fraction failed, whether STOP condition entered, can access even put character string (along info x-list). great way test function use validation step ‘action’ invoked undergo evaluation environment contains x (structure).","code":"al <- action_levels(warn_at = 0.1, stop_at = 0.2) al ## -- The `action_levels` settings ## WARN failure threshold of 0.1 of all test units. ## STOP failure threshold of 0.2 of all test units. ## ---- agent <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"VALID-I Example No. 2\",     actions = al   ) %>%   col_is_posix(date_time) %>%   col_vals_in_set(f, set = c(\"low\", \"mid\")) %>%   col_vals_lt(a, value = 7) %>%   col_vals_regex(b, regex = \"^[0-9]-[a-w]{3}-[2-9]{3}$\") %>%   col_vals_between(d, left = 0, right = 4000) %>%   interrogate() ── Interrogation Started - there are 5 steps ────────────────────────────────── ✓ Step 1: OK. x Step 2: STOP condition met. ! Step 3: WARNING condition met. x Step 4: STOP condition met. ! Step 5: WARNING condition met.  ── Interrogation Completed ───────────────────────────────────────────────── agent al <-    action_levels(     warn_at = 0.1,     stop_at = 0.2,     fns = list(       warn = ~ log4r_step(x),       stop = ~ log4r_step(x)     )   ) al ## -- The `action_levels` settings ## WARN failure threshold of 0.1 of all test units. ## \\fns\\ ~ log4r_step(x) ## STOP failure threshold of 0.2 of all test units. ## \\fns\\ ~ log4r_step(x) ## ---- agent <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"VALID-I Example No. 3\",     actions = al   ) %>%   col_is_posix(date_time) %>%   col_vals_in_set(f, set = c(\"low\", \"mid\")) %>%   col_vals_lt(a, value = 7) %>%   col_vals_regex(b, regex = \"^[0-9]-[a-w]{3}-[2-9]{3}$\") %>%   col_vals_between(d, left = 0, right = 4000) %>%   interrogate() ── Interrogation Started - there are 5 steps ────────────────────────────────── ✓ Step 1: OK. x Step 2: STOP condition met. ! Step 3: WARNING condition met. x Step 4: STOP condition met. ! Step 5: WARNING condition met.  ── Interrogation Completed ───────────────────────────────────────────────── readLines(\"pb_log_file\") [1] \"ERROR [2020-11-06 01:26:07] Step 2 exceeded the STOP failure threshold (f_failed = 0.46154) ['col_vals_in_set']\"  [2] \"WARN  [2020-11-06 01:26:07] Step 3 exceeded the WARN failure threshold (f_failed = 0.15385) ['col_vals_lt']\"      [3] \"ERROR [2020-11-06 01:26:07] Step 4 exceeded the STOP failure threshold (f_failed = 0.53846) ['col_vals_regex']\"   [4] \"WARN  [2020-11-06 01:26:07] Step 5 exceeded the WARN failure threshold (f_failed = 0.07692) ['col_vals_between']\" x <- get_agent_x_list(agent, i = 2) x ── The x-list for STEP 2 ──────────────────────────────────────────── $time_start $time_end (POSIXct [1]) $label $tbl_name $tbl_src $tbl_src_details (chr [1]) $tbl (spec_tbl_df, tbl_df, tbl, and data.frame) $col_names $col_types (chr [8]) $i $type $columns $values $label $briefs (mixed [1]) $eval_error $eval_warning (lgl [1]) $capture_stack (list [1]) $n $n_passed $n_failed $f_passed $f_failed (num [1]) $warn $stop $notify (lgl [1]) $lang (chr [1]) ───────────────────────────────────────────────────────────────── glue::glue(   \"In Step {x$i}, there were {x$n} test units and {x$f_failed * 100}% \\\\   failed. STOP condition met: {tolower(x$stop)}.\" ) In Step 2, there were 13 test units and 46.154% failed. STOP condition met: true."},{"path":"https://rstudio.github.io/pointblank/articles/VALID-II.html","id":"an-example-of-this-workflow","dir":"Articles","previous_headings":"","what":"An Example of This Workflow","title":"Introduction to the Pipeline Data Validation Workflow (VALID-II)","text":"Let’s adapt example used VALID-: Data Quality Reporting Workflow article pipeline data validation workflow: terms expressions used pipeline, might notice create_agent() interrogate() functions absent. due secondary role validation functions, can operate directly immediately data, acting sort filter. validations pipeline pass (.e., failing test units validation steps), small_table data returned. Otherwise, ’s currently written, stoppage occur failure. turns , validation pipeline result error. stringent default threshold setting stops evaluation pipeline point failure (one test units failing). , turn, stops running script (key consideration script deployed automatically running sort schedule). type workflow don’t need define functions, pointblank automatically sensible thing stopping evaluation providing stock message. , first instance stoppage due validation failing, R scripts stop point R Markdown documents correspondingly cease render.","code":"small_table %>%   col_is_posix(date_time) %>%   col_vals_in_set(f, set = c(\"low\", \"mid\", \"high\")) %>%   col_vals_lt(a, value = 10) %>%   col_vals_regex(b, regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\") %>%   col_vals_between(d, left = 0, right = 5000) ## Error: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. ## The `col_vals_between()` validation failed beyond the absolute threshold level (1). ## * failure level (1) >= failure threshold (1)"},{"path":"https://rstudio.github.io/pointblank/articles/VALID-II.html","id":"modifying-the-behavior-of-validation-failures","dir":"Articles","previous_headings":"","what":"Modifying the Behavior of Validation Failures","title":"Introduction to the Pipeline Data Validation Workflow (VALID-II)","text":"ways counteract stopping behavior seen previous example. R Markdown document, set chunk option error = TRUE might expect error occur due validation failure (allowing execution continue matter happens). ’s done small_table example document, giving us error message printed input. Another way disable evaluation step level use active = FALSE option every validation function shouldn’t evaluated. works R scripts R Markdown documents quite different since can’t determine whether validation passed failed since doesn’t actually perform check (simply skips ). useful, however, want enable staged checks use data validations sort ‘debug mode’ since global variables logical can passed active argument specific validation functions. Another strategy stop() instead warn().","code":""},{"path":"https://rstudio.github.io/pointblank/articles/VALID-II.html","id":"using-warn_on_fail-and-stop_on_fail-functions-to-generate-simple-action_levels","dir":"Articles","previous_headings":"Modifying the Behavior of Validation Failures","what":"Using warn_on_fail() and stop_on_fail() functions to generate simple action_levels","title":"Introduction to the Pipeline Data Validation Workflow (VALID-II)","text":"two helper functions convenient workflow: warn_on_fail() stop_on_fail(). functions return action_levels object either warns stops, informative warning error messages. default failure threshold set 1: one fail unit means threshold WARN FAIL condition met. stop_on_fail() helper (behind scenes) applied default using validation functions VALID-II workflow. , previous example exactly expanded form: want instead issue warnings, perhaps less stringent failure thresholds certain steps, warn_on_fail() function provides simple way express . warn_on_fail() stop_on_fail() handy ways generate action_levels objects actions argument every validation function, doesn’t provide way specify actions. , ’ll need use action_levels() function directly.","code":"small_table %>%   col_is_posix(     date_time,     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_in_set(     f, set = c(\"low\", \"mid\", \"high\"),     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_lt(     a, value = 10,     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_regex(     b, regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\",     actions = stop_on_fail(stop_at = 1)   ) %>%   col_vals_between(     d, left = 0, right = 5000,     actions = stop_on_fail(stop_at = 1)   ) ## Error: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. ## The `col_vals_between()` validation failed beyond the absolute threshold level (1). ## * failure level (1) >= failure threshold (1) small_table %>%   col_is_posix(     date_time,     actions = warn_on_fail()   ) %>%   col_vals_in_set(     f, set = c(\"low\", \"mid\", \"high\"),     actions = warn_on_fail(warn_at = 0.2)   ) %>%   col_vals_lt(     a, value = 10,     actions = warn_on_fail(warn_at = 3)   ) %>%   col_vals_regex(     b, regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\",     actions = warn_on_fail(warn_at = 0.2)   ) %>%   col_vals_between(     d, left = 0, right = 5000,     actions = warn_on_fail(warn_at = 1)   ) ## Warning: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. ## The `col_vals_between()` validation failed beyond the absolute threshold level (1). ## * failure level (1) >= failure threshold (1) ## # A tibble: 13 × 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/articles/VALID-II.html","id":"using-action_levels-for-more-control","dir":"Articles","previous_headings":"Modifying the Behavior of Validation Failures","what":"Using action_levels() for More Control","title":"Introduction to the Pipeline Data Validation Workflow (VALID-II)","text":"action_levels() function can useful VALID-workflow agent. function creates action_levels object can two roles: (1) specification threshold failure levels entering certain conditions (WARN, STOP, NOTIFY), (2) setting actions (.e., function calls invoke) entering specific condition. fns argument action_levels() allows us define custom functions evaluated upon entering three states (acts ‘step’ level, per validation function). Compared VALID-workflow, deals reporting, actions triggered failures VALID-II workflow probably useful important. can imagine situation R script deployed data validation interspersed throughout. Depending deployment, may desire hard stop (affecting downstream components), , may want softer approach warning logging. Let’s try hybrid approach three available conditions failure threshold levels set associated function invoke. functions invoke condition can whatever makes sense workflow (.e., don’t issue warnings WARN condition want something else). , use warning() WARN, stop() STOP, logging function (log4r_step()) NOTIFY. ’s might create action_levels object action_levels(): assigned action_levels object (case, al) can print get summary settings. Finally, apply object every validation function call expression (changed slightly result test units failing). addition error warning, log4r_step() function used NOTIFY condition generates, case, new \"pb_log_file\" text file logs. can examine readLines(); single entry relates Step 1 (col_vals_in_set() step): log4r_step() function offered pointblank shown examples explained detail VALID-: Data Quality Reporting Workflow article.","code":"al <-    action_levels(     warn_at = 0.1,     stop_at = 0.2,     notify_at = 0.3,     fns = list(       warn = ~ warning(\"WARN threshold exceeded.\"),       stop = ~ stop(\"STOP threshold exceeded.\"),       notify = ~ log4r_step(x)     )   ) al ## -- The `action_levels` settings ## WARN failure threshold of 0.1 of all test units. ## \\fns\\ ~ warning(\"WARN threshold exceeded.\") ## STOP failure threshold of 0.2 of all test units. ## \\fns\\ ~ stop(\"STOP threshold exceeded.\") ## NOTIFY failure threshold of 0.3 of all test units. ## \\fns\\ ~ log4r_step(x) ## ---- small_table %>%   col_is_posix(date_time, actions = al) %>%   col_vals_in_set(f, set = c(\"low\", \"mid\"), actions = al) %>%   col_vals_lt(a, value = 7, actions = al) %>%   col_vals_regex(b, regex = \"^[0-9]-[a-w]{3}-[2-9]{3}$\", actions = al) %>%   col_vals_between(d, left = 0, right = 4000, actions = al) ## Warning in rlang::eval_tidy(.): WARN threshold exceeded. ## Error in rlang::eval_tidy(.): STOP threshold exceeded. readLines(\"pb_log_file\") FATAL [2020-11-09 00:23:48] Step 1 exceeded the NOTIFY failure threshold (f_failed = 0.46154) ['col_vals_in_set']"},{"path":"https://rstudio.github.io/pointblank/articles/VALID-III.html","id":"using-expect_-functions-in-the-testthat-way","dir":"Articles","previous_headings":"","what":"Using expect_*() Functions in the testthat Way","title":"Introduction to the Expectations in Unit Tests Workflow (VALID-III)","text":"testthat package collection functions begin expect_. ’s coincidence pointblank VALID-III workflow adopts naming convention. idea use functions interchangeably testthat standard testthat workflow (test-<name>.R file, inside tests/testthat folder). big difference instead testing function outputs, testing data tables. However, tables may returned function calls expect_*() functions offered pointblank might offer flexibility testing data. instance expect_col_vals_between() allows us write expectation fine control boundary values (whether inclusive bounds), whether NA values ignored, can even set failure threshold makes sense expectation. ’s example generate tests data testthat also pointblank. small_table dataset, let’s write expectations show non-NA values column c 2 9. testthat function tests values two values. original strategy use testthat::expect_gte() testthat::lte() small_table$c object , however, doesn’t work results logical vector greater length 1. Also, allowance NA values skipped. best . pointblank version task makes succinct understandable expectation expression: arguments expect_col_vals_between() give us everything need check tabular data without subsetting perform transformations. added benefits. data come data source local data frame, SQL expressions handled internally tested extensively across supported database types Spark DataFrames well.","code":"testthat::expect_true(all(na.omit(small_table$c) >= 2)) testthat::expect_true(all(na.omit(small_table$c) <= 9)) expect_col_vals_between(small_table, c, 2, 9, na_pass = TRUE)"},{"path":"https://rstudio.github.io/pointblank/articles/VALID-III.html","id":"these-expect_-functions-are-simpler-than-their-counterparts","dir":"Articles","previous_headings":"","what":"These expect_*() Functions Are Simpler Than Their Counterparts","title":"Introduction to the Expectations in Unit Tests Workflow (VALID-III)","text":"expect_*() functions leading arguments validation function counterparts omit following arguments end signatures: actions step_id label brief active lose actions argument, get place threshold argument. simple failure threshold value use expectation (expect_*) test (test_*) functions. default, threshold set 1 means single test unit failing result overall failure (.e., expectation fail). thresholds set action_levels() functions (shortcut functions warn_on_fail() stop_on_fail()), whole numbers beyond 1 indicate failing units absolute threshold value result succeeding expectation. Likewise, fractional values (0 1) act proportional failure threshold, 0.25 means 25% failing test units results failed expectation. preconditions argument can used transform input data evaluation expectation. useful cases might need summarize input data table, mutate columns, perform filtering, even perform table joins beforehand.","code":""},{"path":"https://rstudio.github.io/pointblank/articles/VALID-IV.html","id":"exactly-like-the-expect_-functions-except-you-get-a-true-or-false","dir":"Articles","previous_headings":"","what":"Exactly Like the expect_*() Functions Except You Get a TRUE or FALSE","title":"Introduction to the Data Tests for Conditionals Workflow (VALID-IV)","text":"interface test_*() function exact match expect_*() counterpart. haven’t used either used standard validation functions, ’s quick rundown. following arguments validation functions (e.g., col_vals_in_set() many ) removed corresponding test_*() functions: actions step_id label brief active Instead actions get threshold argument simplified replacement. ’s supplied single failure threshold value. default set 1 meaning single test fails result overall failure return FALSE (otherwise, TRUE). rules threshold setting (action_levels(), warn_on_fail(), stop_on_fail()) explained detail . Whole numbers beyond 1 indicate failing units absolute threshold value result TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.25 means 25% failing test units results FALSE. can use preconditions argument cases ’d like transform input data evaluation test. like things input table like summarize , perform filtering, mutate one columns, perform table joins, etc., good way go .","code":""},{"path":"https://rstudio.github.io/pointblank/articles/VALID-IV.html","id":"heres-several-examples-quick-snap","dir":"Articles","previous_headings":"","what":"Here’s Several Examples Quick Snap","title":"Introduction to the Data Tests for Conditionals Workflow (VALID-IV)","text":"Let’s examples leaving article. use small_table: ’d like test pointblank validation skill, guess whether TRUE FALSE hovering line code. . nice set examples revealing truthy/falsy nature ::closer inspection.","code":"small_table ## # A tibble: 13 × 8 ##    date_time           date           a b             c      d e     f     ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/articles/VALID-V.html","id":"an-example-with-the-palmer-penguins-dataset","dir":"Articles","previous_headings":"","what":"An Example with the Palmer Penguins Dataset","title":"Introduction to the Table Scan Workflow (VALID-V)","text":"output HTML report appear RStudio Viewer can also integrated R Markdown HTML output. ’s example uses penguins_raw dataset palmerpenguins package. scan_data() call, option deactivate display navigation bar taken navbar = FALSE, makes sense integrating type output larger document. seen, first two sections lot additional information tucked behind detail views (Toggle details buttons) within tab sets. amount information little overwhelming, option disable one sections. scan_data()’s sections argument, can specify just sections needed specific scan. default value sections string \"OVICMS\" letter stands following sections default order: \"O\": \"overview\" \"V\": \"variables\" \"\": \"interactions\" \"C\": \"correlations\" \"M\": \"missing\" \"S\": \"sample\". string can contain less key characters order can changed suit desired layout report. example, just need Overview, Sample, description Variables target table, string use sections \"OSV\". Just workflows, tbl supplied data frame, tibble, tbl_dbi object, tbl_spark object. However, one limitation scan_data(): tbl_dbi tbl_spark objects, Interactions Correlations sections currently excluded.","code":"scan_data(palmerpenguins::penguins_raw, navbar = FALSE)"},{"path":"https://rstudio.github.io/pointblank/articles/VALID-V.html","id":"languages-and-locales","dir":"Articles","previous_headings":"","what":"Languages and Locales","title":"Introduction to the Table Scan Workflow (VALID-V)","text":"reporting generated scan_data() can presented one eight spoken languages: English (\"en\", default), French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese, (\"pt\"), Chinese (\"zh\"), Russian (\"ru\"). two-letter language codes can used argument lang argument. applied, label text non-data elements set language choice. checked translations native speakers respective languages find error corrected, please file issue. Along translations, numerical values generated part reporting (e.g., table dimensions, summary statistics, etc.) automatically formatted locale language (given lang). can overridden locale argument accepts locale ID. Examples include \"en_US\" English (United States) \"fr_FR\" French (France). simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). 700 locales currently accepted.","code":""},{"path":"https://rstudio.github.io/pointblank/articles/VALID-VI.html","id":"how-it-works","dir":"Articles","previous_headings":"","what":"How It Works","title":"Introduction to the R Markdown Document Validation Workflow (VALID-VI)","text":"Using pointblank VALID-VI workflow enabled default pointblank library loaded (best done setup chunk). framework allows validation testing within specialized validation code chunks validate = TRUE option set. Using pointblank validation functions data (VALID-II workflow) marked code chunks flag overall failure stop threshold exceeded anywhere. errors shown rendering document HTML. Green status buttons indicate validations succeeded, red buttons indicate one validation failures occurred. Clicking button reveals otherwise hidden validation statements associated messaging. ’s much better demonstrate workflow works series examples, resulting output interactive varies quite bit depending input. following examples, code chunk shown rendered result subsequently placed. result typically button can pressed reveal validation result code chunk hidden upon rendering (’s need use include = FALSE chunk option). start things , ’s example uses expression takes small_table dataset pipes two validation functions: col_is_date() col_vals_in_set(). col_is_date() validation passes whereas col_vals_in_set() validation fails (set values column f also \"high\" value.  Clicking 1 validation failed. button reveal expression failed validation validation function failing within . break , really one validation step chain passed (first one) one failed (second). additional validation steps otherwise pass, ’d still get result output failing step ends execution. workflow meant stop expression executing first validation function fails, ’s advisable break validations single steps. way, expression single validation either passes fails reported accordingly. Let’s rewrite example two expressions, one per validation.  still says 1 validation failed. (workflow focuses negatives) pressing button reveals first one passed second failed. much clearer don’t run risk evaluating validations validation failed earlier pipeline. ’s example validations individual expressions pass, showing us green status button.  ’s worth reminding point failed validations stop execution R Markdown rendering. Otherwise wouldn’t see document failing validations, , wouldn’t know failed validations occurred. expectation workflow add relevant validation expressions key junctures failures occur, one can fix underlying issues (enough) validations pass.","code":""},{"path":"https://rstudio.github.io/pointblank/articles/VALID-VI.html","id":"the-pointblank-stop_if_not-function","dir":"Articles","previous_headings":"","what":"The pointblank stop_if_not() Function","title":"Introduction to the R Markdown Document Validation Workflow (VALID-VI)","text":"may want use set validation functions everything. Perhaps using stopifnot() sufficient validations. case, consider using pointblank variation : stop_if_not(). works well enough standalone, replacement stopifnot() advantage stop_if_not() customized use VALID-VI workflow (situation ’re using R Markdown render HTML, pointblank loaded via library()). Ultimately, using stop_if_not() code chunk validate = TRUE option set yield correct reporting successes failures whereas stopifnot() . ’s code chunk uses stop_if_not() twice check two different assertions small_table object. first one passes whereas second one fails.  Keep mind stop_if_not() (like stopifnot()) can used type assertion. ’s limited checking tables like functions pointblank focused .","code":""},{"path":"https://rstudio.github.io/pointblank/articles/VALID-VI.html","id":"including-data-quality-reporting-from-the-valid-i-workflow","dir":"Articles","previous_headings":"The pointblank stop_if_not() Function","what":"Including Data Quality Reporting from the VALID-I Workflow","title":"Introduction to the R Markdown Document Validation Workflow (VALID-VI)","text":"Code chunks can include data quality reporting expressions (.e., agent-based VALID-workflow) ’s important ensure two things. ’s interesting thing : can opt use validate = TRUE chunk option omit entirely, choice different effect. ’d like hide validation output (Agent Report) behind button (case, light blue one) validate = TRUE used. ’s example data quality validation workflow executed single code chunk.  code chunk exclude validate = TRUE option, output appear output normally (input appears output report table). just want output reporting table shown without input expressions, use include = FALSE chunk option . final note , ’s important use expressions result output, just stick typical create_agent() → <validation functions> → interrogate() pattern. words, dedicate code chunk just agent put validation expressions elsewhere document.","code":""},{"path":"https://rstudio.github.io/pointblank/articles/VALID-VI.html","id":"setting-up-options-with-the-validate_rmd-function","dir":"Articles","previous_headings":"","what":"Setting Up Options with the validate_rmd() Function","title":"Introduction to the R Markdown Document Validation Workflow (VALID-VI)","text":"can modify pointblank validation testing options within R Markdown documents validate_rmd() function. framework testing set default, using validate_rmd() offers opportunity set UI logging options. summary argument, TRUE (default), leading summary validations rendered R Markdown document. FALSE, element shown. document, validate_rmd(summary = FALSE) placed setup chunk (right library(pointblank) statement) resulted suppressing display overall summary validation results. log_to_file argument, ’s option log errors text file. default, logging done setting log_to_file == TRUE write log entries \"validation_errors.log\" file working directory (generated non-existent, appended available). enable logging specify name file, include path log file (desired name) log_to_file.","code":""},{"path":"https://rstudio.github.io/pointblank/articles/pointblank.html","id":"the-basic-building-block-validation-rules","dir":"Articles","previous_headings":"","what":"The Basic Building Block: Validation Rules","title":"pointblank","text":"use small_table example. expect values column less 10. can specify validation rule via col_vals_lt(). table fulfills validation rule, just return input table - can directly pass validation rules. One fails! Now know data quality table wasn’t expecting. assessing data quality make sure poor data fed data processing pipeline model, error may need stop process.","code":"data(small_table)  small_table %>%   col_vals_lt(a, value = 10) #> # A tibble: 13 × 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high small_table %>%   col_vals_lt(a, value = 10) %>%   col_vals_between(d, left = 0, right = 5000) %>%    col_vals_in_set(f, set = c(\"low\", \"mid\", \"high\")) %>%   col_vals_regex(b, regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\") #> Error: Exceedance of failed test units where values in `d` should have been between `0` and `5000`. #> The `col_vals_between()` validation failed beyond the absolute threshold level (1). #> * failure level (1) >= failure threshold (1)"},{"path":"https://rstudio.github.io/pointblank/articles/pointblank.html","id":"a-simple-validation-table","dir":"Articles","previous_headings":"","what":"A Simple Validation Table","title":"pointblank","text":"building report state data quality can capture fine-graned information validation table. validation report table produced validation small_table: &marker;10 &marker;d [0, 5,000] &marker;f low, mid, high &marker;b ^[0-9]-[-z]{3}-[0-9]{3}&dollar; row reporting table constitutes single validation step. Roughly, left-hand side outlines validation rules right-hand side provides results validation step. simple principle, ’s lot useful information packed validation table. ’s diagram describes important parts validation table:  three things noted : Validation steps: step separate test table, focused certain aspect table. Validation rules: validation type provided along key constraints. Validation results: interrogation results provided , breakdown test units (total, passing, failing), threshold flags, . intent provide key information one place, interpretable data stakeholders.","code":""},{"path":"https://rstudio.github.io/pointblank/articles/pointblank.html","id":"example-code-step-by-step","dir":"Articles","previous_headings":"","what":"Example Code, Step-by-Step","title":"pointblank","text":"’s code performs validation data frame. Note three key pieces code: create_agent() function takes data frame database table want validate. functions starting col_* specify validation steps run specific columns. interrogate() function executes validation plan target table returns validation table. common pattern used validation workflow, create_agent() interrogate() bookend validation plan generated calling validation methods. ’s data validation pointblank nutshell! next section ’ll go bit understanding can measure data quality test units failure thresholds.","code":"agent <- small_table %>%   create_agent() %>%    col_vals_lt(a, value = 10) %>%   col_vals_between(d, left = 0, right = 5000) %>%    col_vals_in_set(f, set = c(\"low\", \"mid\", \"high\")) %>%   col_vals_regex(b, regex = \"^[0-9]-[a-z]{3}-[0-9]{3}$\")     agent %>%    interrogate()"},{"path":"https://rstudio.github.io/pointblank/articles/pointblank.html","id":"understanding-test-units","dir":"Articles","previous_headings":"","what":"Understanding Test Units","title":"pointblank","text":"validation step execute type validation test target table. example, col_vals_lt() validation step can test value column less specified number. key finding ’s reported result test number test units pass fail. Test units dependent test run. collection col_vals_* validation methods test every value particular column, value test unit (number test units number rows target table). validation methods like col_exists() row_count_match() single test unit since aren’t testing individual values rather single condition true false.","code":""},{"path":"https://rstudio.github.io/pointblank/articles/pointblank.html","id":"using-action-levels","dir":"Articles","previous_headings":"","what":"Using Action Levels","title":"pointblank","text":"Knowing numbers test units across validation methods matters option set action levels (can signal ‘warn_at’, ‘stop_at’, ‘notify_at’ flags) based either relative proportion absolute number failing test units. set threshold 2 failed units warning 4 error. can set action levels individual validation rules via actions argument. set creating agent, applies rules validation plan. &marker;7 look validation report table, can see: FAIL column shows 2 tests units failed. W column (short ‘warning’) shows filled yellow circle indicating failing test units reached threshold value. S column (short ‘stop’) shows open red circle indicating number failing test units threshold. one final action level, N (‘notify’), wasn’t set appears validation table long dash. Setting thresholds important since might want sort signal discovery errors data. set particular threshold levels highly dependent tolerance data failures.","code":"al <- action_levels(warn_at = 2, stop_at = 4)  small_table %>%   col_vals_lt(a, value = 7, actions = al) #> Warning: Exceedance of failed test units where values in `a` should have been < `7`. #> The `col_vals_lt()` validation failed beyond the absolute threshold level (2). #> * failure level (2) >= failure threshold (2) #> # A tibble: 13 × 8 #>    date_time           date           a b             c      d e     f     #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high  #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low   #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high  #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid   #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low   #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid   #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high  #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low   #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high  #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low   #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low   #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high small_table %>%   create_agent(actions = al) %>%    col_vals_lt(a, value = 7) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Richard Iannone. Author, maintainer. Mauricio Vargas. Author. June Choe. Author. Olivier Roy. Contributor.","code":""},{"path":"https://rstudio.github.io/pointblank/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Iannone R, Vargas M, Choe J (2025). pointblank: Data Validation Organization Metadata Local Remote Tables. R package version 0.12.2.9000, https://rstudio.github.io/pointblank/.","code":"@Manual{,   title = {pointblank: Data Validation and Organization of Metadata for Local and Remote Tables},   author = {Richard Iannone and Mauricio Vargas and June Choe},   year = {2025},   note = {R package version 0.12.2.9000},   url = {https://rstudio.github.io/pointblank/}, }"},{"path":"https://rstudio.github.io/pointblank/index.html","id":"table-validations-with-an-agent-and-data-quality-reporting","dir":"","previous_headings":"","what":"TABLE VALIDATIONS WITH AN AGENT AND DATA QUALITY REPORTING","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Data validation can carried Data Quality Reporting workflow, ultimately resulting production data quality analysis report. useful non-interactive mode data quality database tables -disk data files must periodically checked. pointblank agent given collection validation functions define validation steps. can get extracts data rows failed validation, set custom functions invoked exceeding set threshold failure rates, etc. Want email report regularly (, certain conditions met)? Yep, can . example use pointblank validate local table agent. reporting’s pretty sweet. can get gt-based report printing agent.  pointblank package designed straightforward yet powerful. fast! Local data frames don’t take long validate extensively validation checks remote tables done entirely -database. can add dozens even hundreds validation steps without long waits reporting. want perform validation checks database Spark tables, provide tbl_dbi tbl_spark object create_agent(). pointblank package currently supports PostgreSQL. MySQL, MariaDB, Microsoft SQL Server, Google BigQuery, DuckDB, SQLite, Spark DataFrames (sparklyr package). validation reports considerably larger intendo::intendo_revenue table.        ","code":"# Generate a simple `action_levels` object to # set the `warn` state if a validation step # has a single 'fail' test unit al <- action_levels(warn_at = 1)  # Create a pointblank `agent` object, with the # tibble as the target table. Use three validation # functions, then, `interrogate()`. The agent will # then have some useful intel. agent <-    dplyr::tibble(     a = c(5, 7, 6, 5, NA, 7),     b = c(6, 1, 0, 6,  0, 7)   ) %>%   create_agent(     label = \"A very *simple* example.\",     actions = al   ) %>%   col_vals_between(     columns = a,     left = 1,     right = 9,     na_pass = TRUE   ) %>%   col_vals_lt(     columns = c, 12,     preconditions = ~ . %>% dplyr::mutate(c = a + b)   ) %>%   col_is_numeric(columns = c(a, b)) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/index.html","id":"validations-directly-on-data","dir":"","previous_headings":"","what":"VALIDATIONS DIRECTLY ON DATA","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Pipeline Data Validation workflow uses collection validation functions without need agent. useful ETL process want periodically check data trigger warnings, raise errors, write logs exceeding specified failure thresholds. ’s cinch perform checks import data key points transformation process, perhaps stopping data flow things unacceptable regard data quality. following example uses three validation functions , time, use directly data. validation functions act filter, passing data unless execution stopped failing validations beyond set threshold. workflow, default, error occur single ‘fail’ test unit validation step: can downgrade error warning warn_on_fail() helper function (assigning actions). way, data always returned, warnings appear. need fine-grained thresholds resultant actions, action_levels() function can used specify multiple failure thresholds side effects failure state. However, warn_on_fail() stop_on_fail() (applied default, stop_at = 1), good enough options validation workflow.","code":"dplyr::tibble(     a = c(5, 7, 6, 5, NA, 7),     b = c(6, 1, 0, 6,  0, 7)   ) %>%   col_vals_between(     columns = a,     left = 1,     right = 9,     na_pass = TRUE   ) %>%   col_vals_lt(     columns = c,     value = 12,     preconditions = ~ . %>% dplyr::mutate(c = a + b)   ) %>%   col_is_numeric(columns = c(a, b)) Error: Exceedance of failed test units where values in `c` should have been < `12`. The `col_vals_lt()` validation failed beyond the absolute threshold level (1). * failure level (2) >= failure threshold (1) # The `warn_on_fail()` function is a nice # shortcut for `action_levels(warn_at = 1)`; # it works great in this data checking workflow # (and the threshold can still be adjusted) dplyr::tibble(     a = c(5, 7, 6, 5, NA, 7),     b = c(6, 1, 0, 6,  0, 7)   ) %>%   col_vals_between(     columns = a,     left = 1,     right = 9,     na_pass = TRUE,     actions = warn_on_fail()   ) %>%   col_vals_lt(     columns = c,     value = 12,     preconditions = ~ . %>% dplyr::mutate(c = a + b),     actions = warn_on_fail()   ) %>%   col_is_numeric(     columns = c(a, b),     actions = warn_on_fail()   ) #> # A tibble: 6 x 2 #>       a     b #>   <dbl> <dbl> #> 1     5     6 #> 2     7     1 #> 3     6     0 #> 4     5     6 #> 5    NA     0 #> 6     7     7  Warning message: Exceedance of failed test units where values in `c` should have been < `12`. The `col_vals_lt()` validation failed beyond the absolute threshold level (1). * failure level (2) >= failure threshold (1)"},{"path":"https://rstudio.github.io/pointblank/index.html","id":"table-information","dir":"","previous_headings":"","what":"TABLE INFORMATION","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Table information can synthesized information management workflow, giving us snapshot data table care collect information . pointblank informant fed series info_*() functions define bits information table. info text can pertain individual columns, table whole, whatever additional information makes sense organization. can even glean little snippets information (like column stats sample values) target table info_snippet() snip_*() functions mix data dictionary wherever ’re needed. example use pointblank incorporate pieces info text informant object. printing informant get table information report.  link hosted information report intendo::intendo_revenue table:","code":"# Create a pointblank `informant` object, with the # tibble as the target table. Use a few information # functions and end with `incorporate()`. The informant # will then show you information about the tibble. informant <-    dplyr::tibble(     a = c(5, 7, 6, 5, NA, 7),     b = c(6, 1, 0, 6,  0, 7)   ) %>%   create_informant(     label = \"A very *simple* example.\",     tbl_name = \"example_tbl\"   ) %>%   info_tabular(     description = \"This two-column table is nothing all that     interesting, but, it's fine for examples on **GitHub**     `README` pages. Column names are `a` and `b`. ((Cool stuff))\"   ) %>%   info_columns(     columns = a,     info = \"This column has an `NA` value. [[Watch out!]]<<color: red;>>\"   ) %>%   info_columns(     columns = a,     info = \"Mean value is `{a_mean}`.\"   ) %>%   info_columns(     columns = b,     info = \"Like column `a`. The lowest value is `{b_lowest}`.\"   ) %>%   info_columns(     columns = b,     info = \"The highest value is `{b_highest}`.\"   ) %>%   info_snippet(     snippet_name = \"a_mean\",     fn = ~ . %>% .$a %>% mean(na.rm = TRUE) %>% round(2)   ) %>%   info_snippet(snippet_name = \"b_lowest\", fn = snip_lowest(\"b\")) %>%   info_snippet(snippet_name = \"b_highest\", fn = snip_highest(\"b\")) %>%   info_section(     section_name = \"further information\",      `examples and documentation` = \"Examples for how to use the     `info_*()` functions (and many more) are available at the     [**pointblank** site](https://rstudio.github.io/pointblank/).\"   ) %>%   incorporate()"},{"path":"https://rstudio.github.io/pointblank/index.html","id":"table-scans","dir":"","previous_headings":"","what":"TABLE SCANS","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"can use scan_data() function generate comprehensive summary tabular dataset. allows us quickly understand ’s dataset helps us determine peculiarities within data. Scanning dplyr::storms dataset scan_data(tbl = dplyr::storms) gives us interactive HTML report. , published RPubs:   Database tables can used scan_data() well. two examples using (1) full_region table Rfam database (hosted publicly mysql-rfam-public.ebi.ac.uk) (2) assembly table Ensembl database (hosted publicly ensembldb.ensembl.org).","code":""},{"path":"https://rstudio.github.io/pointblank/index.html","id":"overview-of-package-functions","dir":"","previous_headings":"","what":"OVERVIEW OF PACKAGE FUNCTIONS","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"many functions available pointblank understanding data quality creating data documentation. overview , grouped family. much information , visit documentation website take Test Drive Posit Cloud project.","code":""},{"path":"https://rstudio.github.io/pointblank/index.html","id":"installation","dir":"","previous_headings":"","what":"INSTALLATION","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Want try ? pointblank package available CRAN: can also install development version pointblank GitHub:","code":"install.packages(\"pointblank\") # install.packages(\"pak\") pak::pak(\"rstudio/pointblank\")"},{"path":"https://rstudio.github.io/pointblank/index.html","id":"getting-in-touch","dir":"","previous_headings":"","what":"Getting in Touch","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"encounter bug, usage questions, want share ideas make package better, feel free file issue. Wanna talk data validation relaxed setting? Join Discord server! great option asking development pointblank, pitching ideas may become features, just sharing ideas!","code":""},{"path":"https://rstudio.github.io/pointblank/index.html","id":"pointblank-for-python","dir":"","previous_headings":"","what":"Pointblank for Python","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"’s also version pointblank Python, project got ground late 2024 gaining traction Python community. can find https://github.com/posit-dev/pointblank.","code":""},{"path":"https://rstudio.github.io/pointblank/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"Please note gt project released contributor code conduct.participating project agree abide terms.","code":""},{"path":"https://rstudio.github.io/pointblank/index.html","id":"id_-license","dir":"","previous_headings":"","what":"📄 License","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"pointblank licensed MIT license. See LICENSE.md file details. © Posit Software, PBC.","code":""},{"path":"https://rstudio.github.io/pointblank/index.html","id":"id_️-governance","dir":"","previous_headings":"","what":"🏛️ Governance","title":"Data Validation and Organization of Metadata for Local and Remote Tables","text":"project primarily maintained Rich Iannone. authors may occasionally assist duties.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/action_levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Set action levels: failure thresholds and functions to invoke — action_levels","title":"Set action levels: failure thresholds and functions to invoke — action_levels","text":"action_levels() function works actions argument present create_agent() function every validation step function (also actions argument). , can provide threshold failure values combination warn, stop, notify failure states. can react entering state supplying corresponding functions fns argument. undergo evaluation time matching state entered. provided create_agent() policies applied every validation step, acting default validation whole. Calls action_levels() also applied directly validation step act override set also create_agent(). Usage action_levels() required useful side effects (.e., warnings, throwing errors) case validation functions operating directly data (e.g., mtcars %>% col_vals_lt(\"mpg\", 35)). two helper functions convenient using validation functions directly data (agent-less workflow): warn_on_fail() stop_on_fail(). helpers either warn stop (default failure threshold set 1), , informative warning error messages. stop_on_fail() helper applied default using validation functions directly data (information provided Details).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/action_levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set action levels: failure thresholds and functions to invoke — action_levels","text":"","code":"action_levels(warn_at = NULL, stop_at = NULL, notify_at = NULL, fns = NULL)  warn_on_fail(warn_at = 1)  stop_on_fail(stop_at = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/action_levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set action levels: failure thresholds and functions to invoke — action_levels","text":"warn_at Threshold value 'warn' failure state scalar<integer|numeric>(val>=0) // default: NULL (optional) Either threshold number threshold fraction failing test units result entering warn failure state. stop_at Threshold value 'stop' failure state scalar<integer|numeric>(val>=0) // default: NULL (optional) Either threshold number threshold fraction failing test units result entering stop failure state. notify_at Threshold value 'notify' failure state scalar<integer|numeric>(val>=0) // default: NULL (optional) Either threshold number threshold fraction failing test units result entering notify failure state. fns Functions execute entering failure states list // default: NULL (optional) named list functions paired appropriate failure states. syntax list involves using failure state names set warn, stop, notify. functions corresponding failure states provided formulas (e.g., list(warn = ~ warning(\"many failures.\")). series expressions named state can used enclosing set statements { }.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/action_levels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set action levels: failure thresholds and functions to invoke — action_levels","text":"action_levels object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/action_levels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set action levels: failure thresholds and functions to invoke — action_levels","text":"output action_levels() call actions interpreted slightly differently using agent using validation functions directly data table. convenience, working directly data, values supplied warn_at stop_at automatically given stock warning() stop() function. example using small_table %>% col_is_integer(\"date\") provide detailed stop message default, indicating reason failure. supply fns stop warn manually stock functions overridden. Furthermore, actions NULL workflow (default), pointblank use stop_at value 1 (providing detailed, context-specific error message failing units). can absolutely suppress automatic stopping behavior validation step setting active = FALSE. interactive data case, stock function given notify_at. notify failure state less commonly used workflow agent-based one. using agent, often opt use functions fns warn, stop, notify failure states reported using create_agent_report() (, usually sufficient). Instead, using end_fns argument better choice since scheme provides useful data entire interrogation, allowing finer control side effects reducing potential duplicating side effects.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/action_levels.html","id":"defining-threshold-values","dir":"Reference","previous_headings":"","what":"Defining threshold values","title":"Set action levels: failure thresholds and functions to invoke — action_levels","text":"threshold values supplied warn_at, stop_at, notify_at arguments correspond warn, stop, notify failure states, respectively. threshold value can either relates absolute number test units fraction--total test units failing. Exceeding threshold means entering one warn, stop, notify failure states. threshold value decimal value 0 1 proportional failure threshold (e.g., 0.15 indicates 15 percent test units found failing, designated failure state entered). Absolute values starting 1 can used instead, constitutes absolute failure threshold (e.g., 10 means 10 test units found failing, failure state entered).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/action_levels.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set action levels: failure thresholds and functions to invoke — action_levels","text":"examples, use included small_table dataset.   Create action_levels object fractional values warn, stop, notify states.   summary settings al object shown printing . Create pointblank agent apply al object actions. Add two validation steps interrogate small_table.   report agent show warn state entered first validation step second one. can confirm console inspecting warn component agent's x-list.     Applying action_levels object agent means validation steps inherit settings can override applying another object validation step instead (time using warn_on_fail() shorthand).   case, first validation step less stringent failure threshold warn state high enough condition entered. can confirmed console inspection x-list warn component.     context using validation functions directly data (.e., involvement agent) want trigger warnings raise errors. following yield warning executed (returning small_table data).   pipeline, supplying anything actions (NULL default) effect using stop_on_fail(stop_at = 1).     equivalent set statements:     stop_on_fail() call auto-injected default case (operating data) convenience. Behind scenes 'secret agent' uses 'covert actions': can type less.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high al <-   action_levels(     warn_at = 0.2,     stop_at = 0.8,     notify_at = 0.5   ) agent_1 <-   create_agent(     tbl = small_table,     actions = al   ) %>%   col_vals_gt(     columns = a, value = 2   ) %>%   col_vals_lt(     columns = d, value = 20000   ) %>%   interrogate() x_list <- get_agent_x_list(agent = agent_1)  x_list$warn ## [1]  TRUE FALSE agent_2 <-   create_agent(     tbl = small_table,     actions = al   ) %>%   col_vals_gt(     columns = a, value = 2,     actions = warn_on_fail(warn_at = 0.5)   ) %>%   col_vals_lt(     columns = d, value = 20000   ) %>%   interrogate() x_list <- get_agent_x_list(agent = agent_2)  x_list$warn ## [1] FALSE FALSE small_table %>%   col_vals_gt(     columns = a, value = 2,     actions = warn_on_fail(warn_at = 2)   ) ## # A tibble: 13 × 8 ##    date_time           date           a b           c      d e ##    <dttm>              <date>     <int> <chr>   <dbl>  <dbl> <lgl> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-…     3  3423. TRUE ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-…     8 10000. TRUE ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-…     3  2343. TRUE ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-…    NA  3892. FALSE ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-…     7   284. TRUE ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-…     4  3291. TRUE ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-…     3   843. TRUE ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-…     2  1036. FALSE ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-…     7   834. TRUE ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-…     8   108. FALSE ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-…    NA  2230. TRUE ## # … with 1 more variable: f <chr> ## Warning message: ## Exceedance of failed test units where values in `a` should have been > ## `2`. ## The `col_vals_gt()` validation failed beyond the absolute threshold ## level (2). ## * failure level (4) >= failure threshold (2) small_table %>%   col_vals_gt(columns = a, value = 2) ## Error: Exceedance of failed test units where values in `a` should have ## been > `2`. ## The `col_vals_gt()` validation failed beyond the absolute threshold ## level (1). ## * failure level (4) >= failure threshold (1) small_table %>%   col_vals_gt(     columns = a, value = 2,     actions = stop_on_fail(stop_at = 1)   ) ## Error: Exceedance of failed test units where values in `a` should have ## been > `2`. ## The `col_vals_gt()` validation failed beyond the absolute threshold ## level (1). ## * failure level (4) >= failure threshold (1)"},{"path":"https://rstudio.github.io/pointblank/reference/action_levels.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Set action levels: failure thresholds and functions to invoke — action_levels","text":"1-5","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/activate_steps.html","id":null,"dir":"Reference","previous_headings":"","what":"Activate one or more of an agent's validation steps — activate_steps","title":"Activate one or more of an agent's validation steps — activate_steps","text":"certain validation steps need activated creation validation plan agent, use activate_steps() function. equivalent using active = TRUE selected validation steps (active argument validation functions). replace function may defined active argument creation targeted validation steps.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/activate_steps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Activate one or more of an agent's validation steps — activate_steps","text":"","code":"activate_steps(agent, i = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/activate_steps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Activate one or more of an agent's validation steps — activate_steps","text":"agent pointblank agent object obj:<ptblank_agent> // required pointblank agent object commonly created use create_agent() function. validation step number scalar<integer> // default: NULL (optional) validation step number, assigned validation step order definition. NULL (default) step activation occur index.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/activate_steps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Activate one or more of an agent's validation steps — activate_steps","text":"ptblank_agent object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/activate_steps.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Activate one or more of an agent's validation steps — activate_steps","text":"9-5","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/activate_steps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Activate one or more of an agent's validation steps — activate_steps","text":"","code":"# Create an agent that has the # `small_table` object as the # target table, add a few inactive # validation steps, and then use # `interrogate()` agent_1 <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%   col_exists(     columns = date,     active = FALSE   ) %>%   col_vals_regex(     columns = b,     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     active = FALSE   ) %>%   interrogate()  # In the above, the data is # not actually interrogated # because the `active` setting # was `FALSE` in all steps; we # can selectively change this # with `activate_steps()` agent_2 <-   agent_1 %>%   activate_steps(i = 1) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/affix_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Put the current date into a file name — affix_date","title":"Put the current date into a file name — affix_date","text":"function helps affix current date filename. useful writing agent /informant objects disk part continuous process. date can terms UTC time local system time. date can affixed either end filename (file extension) beginning customizable delimiter. x_write_disk(), yaml_write() functions allow writing pointblank objects disk. Furthermore log4r_step() function append_to argument accepts filenames, , reasonable series log files differentiated date component naming scheme. modification filename string takes effect immediately time writing file disk. cases, especially using affix_date() aforementioned file-writing functions, file timestamps approximate time components affixed filenames.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/affix_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Put the current date into a file name — affix_date","text":"","code":"affix_date(   filename,   position = c(\"end\", \"start\"),   format = \"%Y-%m-%d\",   delimiter = \"_\",   utc_time = TRUE )"},{"path":"https://rstudio.github.io/pointblank/reference/affix_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Put the current date into a file name — affix_date","text":"filename filename modify. position place formatted date. either \"end\" filename (default) \"start\". format base::strptime() format string formatting date. default, \"%Y-%m-%d\" expresses date according ISO 8601 standard (YYYY-MM-DD). Refer documentation base::strptime() conversion specifications planning use different format string. delimiter delimiter characters use separating date string original file name. utc_time option whether use current UTC time establish date (default, TRUE), , use system's local time (FALSE).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/affix_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Put the current date into a file name — affix_date","text":"character vector.","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/affix_date.html","id":"the-basics-of-creating-a-filename-with-the-current-date","dir":"Reference","previous_headings":"","what":"The basics of creating a filename with the current date","title":"Put the current date into a file name — affix_date","text":"Taking generic \"pb_file\" name file, add current date suffix.     File extensions get way:     date can used prefix.     date pattern can changed can delimiter.","code":"affix_date(filename = \"pb_file\") ## [1] \"pb_file_2022-04-01\" affix_date(filename = \"pb_file.rds\") ## [1] \"pb_file_2022-04-01.rds\" affix_date(   filename = \"pb_file\",   position = \"start\" ) ## [1] \"2022-04-01_pb_file\" affix_date(   filename = \"pb_file.yml\",   format = \"%Y%m%d\",   delimiter = \"-\" ) ## [1] \"pb_file-20220401.yml\""},{"path":"https://rstudio.github.io/pointblank/reference/affix_date.html","id":"using-a-date-based-filename-in-a-pointblank-workflow","dir":"Reference","previous_headings":"","what":"Using a date-based filename in a pointblank workflow","title":"Put the current date into a file name — affix_date","text":"can use file-naming convention involving dates writing output files immediately interrogating. just one example (workflow involving filename argument applicable). really advantageous use date-based filenames interrogating directly YAML scheduled process.   , used written--disk agent (\"agent-small_table.yml\" YAML file) interrogation via yaml_agent_interrogate(). , results written disk RDS file. filename argument x_write_disk(), affix_date() function used ensure daily run produce file whose name indicates day execution.","code":"yaml_agent_interrogate(   filename = system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) ) %>%   x_write_disk(     filename = affix_date(       filename = \"small_table_agent.rds\",       delimiter = \"-\"     ),     keep_tbl = TRUE,     keep_extracts = TRUE   )"},{"path":"https://rstudio.github.io/pointblank/reference/affix_date.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Put the current date into a file name — affix_date","text":"13-3","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/affix_datetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Put the current datetime into a file name — affix_datetime","title":"Put the current datetime into a file name — affix_datetime","text":"function helps affix current datetime filename. useful writing agent /informant objects disk part continuous process. datetime string can based current UTC time local system time. datetime can affixed either end filename (file extension) beginning customizable delimiter. Optionally, time zone information can included. datetime based local system time, user system time zone shown format <time>(+/-)hhmm. using UTC time, <time>Z format adopted. x_write_disk(), yaml_write() functions allow writing pointblank objects disk. modification filename string takes effect immediately time writing file disk. cases, especially using affix_datetime() aforementioned file-writing functions, file timestamps approximate time components affixed filenames.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/affix_datetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Put the current datetime into a file name — affix_datetime","text":"","code":"affix_datetime(   filename,   position = c(\"end\", \"start\"),   format = \"%Y-%m-%d_%H-%M-%S\",   delimiter = \"_\",   utc_time = TRUE,   add_tz = FALSE )"},{"path":"https://rstudio.github.io/pointblank/reference/affix_datetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Put the current datetime into a file name — affix_datetime","text":"filename filename modify. position place formatted datetime. either \"end\" filename (default) \"start\". format base::strptime() format string formatting datetime. default, \"%Y-%m-%dT%H:%M:%S\" expresses date according ISO 8601 standard. example, current datetime 2020-12-04 13:11:23, formatted string become \"2020-12-04T13:11:23\". Refer documentation base::strptime() conversion specifications planning use different format string. delimiter delimiter characters use separating datetime string original file name. utc_time option whether use current UTC time establish datetime (default, TRUE), , use system's local time (FALSE). add_tz time zone (offset UTC) provided? TRUE UTC offset either provided <time>Z (utc_time = TRUE) <time>(+/-)hhmm. default, FALSE.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/affix_datetime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Put the current datetime into a file name — affix_datetime","text":"character vector.","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/affix_datetime.html","id":"the-basics-of-creating-a-filename-with-the-current-date-and-time","dir":"Reference","previous_headings":"","what":"The basics of creating a filename with the current date and time","title":"Put the current datetime into a file name — affix_datetime","text":"Taking generic \"pb_file\" name file, add current datetime suffix.     File extensions get way:     datetime can used prefix.     datetime pattern can changed can delimiter.     Time zone information can included. default, datetimes given UTC time zone.     can use system's local time zone utc_time = FALSE.","code":"affix_datetime(filename = \"pb_file\") ## [1] \"pb_file_2022-04-01_00-32-53\" affix_datetime(filename = \"pb_file.rds\") ## [1] \"pb_file_2022-04-01_00-32-53.rds\" affix_datetime(   filename = \"pb_file\",   position = \"start\" ) ## [1] \"2022-04-01_00-32-53_pb_file\" affix_datetime(   filename = \"pb_file.yml\",   format = \"%Y%m%d_%H%M%S\",   delimiter = \"-\" ) ## [1] \"pb_file-20220401_003253.yml\" affix_datetime(   filename = \"pb_file.yml\",   add_tz = TRUE ) ## [1] \"pb_file_2022-04-01_00-32-53Z.yml\" affix_datetime(   filename = \"pb_file.yml\",   utc_time = FALSE,   add_tz = TRUE ) ## [1] \"pb_file_2022-03-31_20-32-53-0400.yml\""},{"path":"https://rstudio.github.io/pointblank/reference/affix_datetime.html","id":"using-a-datetime-based-filename-in-a-pointblank-workflow","dir":"Reference","previous_headings":"","what":"Using a datetime-based filename in a pointblank workflow","title":"Put the current datetime into a file name — affix_datetime","text":"can use file-naming convention involving datetimes writing output files immediately interrogating. just one example (workflow involving filename argument applicable). really advantageous use datetime-based filenames interrogating directly YAML scheduled process, especially multiple validation runs per day executed target table.   , used written--disk agent (\"agent-small_table.yml\" YAML file) interrogation via yaml_agent_interrogate(). , results written disk RDS file. filename argument x_write_disk(), affix_datetime() function used ensure frequent runs produce files whose names indicate day time execution.","code":"yaml_agent_interrogate(   filename = system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) ) %>%   x_write_disk(     filename = affix_datetime(       filename = \"small_table_agent.rds\",       delimiter = \"-\"     ),     keep_tbl = TRUE,     keep_extracts = TRUE   )"},{"path":"https://rstudio.github.io/pointblank/reference/affix_datetime.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Put the current datetime into a file name — affix_datetime","text":"13-4","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/all_passed.html","id":null,"dir":"Reference","previous_headings":"","what":"Did all of the validations fully pass? — all_passed","title":"Did all of the validations fully pass? — all_passed","text":"Given agent's validation plan undergone interrogation via interrogate(), every single validation step result zero failing test units? Using all_passed() function let us know whether TRUE .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/all_passed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Did all of the validations fully pass? — all_passed","text":"","code":"all_passed(agent, i = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/all_passed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Did all of the validations fully pass? — all_passed","text":"agent pointblank agent object obj:<ptblank_agent> // required pointblank agent object commonly created use create_agent() function. Validation step numbers vector<integer> // default: NULL (optional) vector validation step numbers. values assigned validation step pointblank order definition. NULL (default), validation steps used evaluation complete passing.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/all_passed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Did all of the validations fully pass? — all_passed","text":"logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/all_passed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Did all of the validations fully pass? — all_passed","text":"all_passed() function provides single logical value based interrogation performed agent-based workflow. large-scale validation (data quality known issue, perhaps something tamed time) function likely less useful since quite stringent (test units must pass across validation steps). requirement logical values produced validation, flexible alternative using test (test_*()) variants validation functions. produce single logical value threshold option failure levels. Another option utilize post-interrogation objects within agent's x-list (obtained using get_agent_x_list() function). allows many possibilities producing single logical value interrogation.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/all_passed.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Did all of the validations fully pass? — all_passed","text":"Create simple table column numerical values.   Validate values column always greater 4.   Determine column validations passed using all_passed() ().","code":"tbl <- dplyr::tibble(a = c(4, 5, 7, 8))  tbl #> # A tibble: 4 x 1 #>       a #>   <dbl> #> 1     4 #> 2     5 #> 3     7 #> 4     8 agent <-   create_agent(tbl = tbl) %>%   col_vals_gt(columns = a, value = 3) %>%   col_vals_lte(columns = a, value = 10) %>%   col_vals_increasing(columns = a) %>%   interrogate() all_passed(agent = agent) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/all_passed.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Did all of the validations fully pass? — all_passed","text":"8-4","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Does the column count match that of a different table? — col_count_match","title":"Does the column count match that of a different table? — col_count_match","text":"col_count_match() validation function, expect_col_count_match() expectation function, test_col_count_match() test function check whether column count target table matches comparison table. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation, single test unit hinges whether column counts two tables (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does the column count match that of a different table? — col_count_match","text":"","code":"col_count_match(   x,   count,   preconditions = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_count_match(object, count, preconditions = NULL, threshold = 1)  test_col_count_match(object, count, preconditions = NULL, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does the column count match that of a different table? — col_count_match","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). count count comparison scalar<numeric|integer>|obj:<tbl_*> // required Either literal value number columns, , table compare target table terms column count values. supplying comparison table, can either table object data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, table-prep formula (~ <tbl reading code>) function ( function() <tbl reading code>) can used lazily read comparison table interrogation time. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Does the column count match that of a different table? — col_count_match","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Does the column count match that of a different table? — col_count_match","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Does the column count match that of a different table? — col_count_match","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires operation target table column count comparison takes place. Using preconditions can useful times since since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed. Alternatively, function instead supplied.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Does the column count match that of a different table? — col_count_match","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. Using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Does the column count match that of a different table? — col_count_match","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Does the column count match that of a different table? — col_count_match","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Does the column count match that of a different table? — col_count_match","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_count_match() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_count_match() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_count_match(     count = ~ file_tbl(       file = from_github(         file = \"sj_all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       ),     preconditions = ~ . %>% dplyr::filter(a < 10),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_count_match()` step.\",     active = FALSE   ) steps: - col_count_match:     count: ~ file_tbl(       file = from_github(         file = \"sj_all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       )     preconditions: ~. %>% dplyr::filter(a < 10)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_count_match()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Does the column count match that of a different table? — col_count_match","text":"Create simple table three columns three rows values:   Create second table quite different number columns tbl.   use tables different function variants.","code":"tbl <-   dplyr::tibble(     a = c(5, 7, 6),     b = c(7, 1, 0),     c = c(1, 1, 1)   )  tbl #> # A tibble: 3 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     7     1 #> 2     7     1     1 #> 3     6     0     1 tbl_2 <-   dplyr::tibble(     e = c(\"a\", NA, \"a\", \"c\"),     f = c(2.6, 1.2, 0, NA),     g = c(\"f\", \"g\", \"h\", \"i\")   )  tbl_2 #> # A tibble: 4 x 3 #>   e         f g #>   <chr> <dbl> <chr> #> 1 a       2.6 f #> 2 <NA>    1.2 g #> 3 a       0   h #> 4 c      NA   i"},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Does the column count match that of a different table? — col_count_match","text":"Validate count columns target table (tbl) matches comparison table (tbl_2).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_count_match(count = tbl_2) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Does the column count match that of a different table? — col_count_match","text":"way using validation functions acts data filter: data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>% col_count_match(count = tbl_2) #> # A tibble: 3 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     7     1 #> 2     7     1     1 #> 3     6     0     1"},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Does the column count match that of a different table? — col_count_match","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_count_match(tbl, count = tbl_2)"},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Does the column count match that of a different table? — col_count_match","text":"test_*() form, get single logical value returned us.","code":"tbl %>% test_col_count_match(count = 3) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_count_match.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Does the column count match that of a different table? — col_count_match","text":"2-32","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":null,"dir":"Reference","previous_headings":"","what":"Do one or more columns actually exist? — col_exists","title":"Do one or more columns actually exist? — col_exists","text":"col_exists() validation function, expect_col_exists() expectation function, test_col_exists() test function check whether one columns exist target table. requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate single test unit, whether column exists .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do one or more columns actually exist? — col_exists","text":"","code":"col_exists(   x,   columns = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_exists(object, columns, threshold = 1)  test_col_exists(object, columns, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do one or more columns actually exist? — col_exists","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do one or more columns actually exist? — col_exists","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do one or more columns actually exist? — col_exists","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do one or more columns actually exist? — col_exists","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do one or more columns actually exist? — col_exists","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. Using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do one or more columns actually exist? — col_exists","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do one or more columns actually exist? — col_exists","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do one or more columns actually exist? — col_exists","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_exists() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_exists() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_exists(     columns = a,     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_exists()` step.\",     active = FALSE   ) steps: - col_exists:     columns: c(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_exists()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do one or more columns actually exist? — col_exists","text":"examples , use simple table two columns: b.   use table different function variants.","code":"tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 0, 3)   )  tbl #> # A tibble: 6 x 2 #>       a     b #>   <dbl> <dbl> #> 1     5     7 #> 2     7     1 #> 3     6     0 #> 4     5     0 #> 5     8     0 #> 6     7     3"},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do one or more columns actually exist? — col_exists","text":"Validate column exists tbl table col_exists().   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_exists(columns = a) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do one or more columns actually exist? — col_exists","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>% col_exists(columns = a) #> # A tibble: 6 x 2 #>       a     b #>   <dbl> <dbl> #> 1     5     7 #> 2     7     1 #> 3     6     0 #> 4     5     0 #> 5     8     0 #> 6     7     3"},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do one or more columns actually exist? — col_exists","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_exists(tbl, columns = a)"},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do one or more columns actually exist? — col_exists","text":"test_*() form, get single logical value returned us.","code":"tbl %>% test_col_exists(columns = a) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_exists.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do one or more columns actually exist? — col_exists","text":"2-29","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain character/string data? — col_is_character","title":"Do the columns contain character/string data? — col_is_character","text":"col_is_character() validation function, expect_col_is_character() expectation function, test_col_is_character() test function check whether one columns table character type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate single test unit, whether column character-type column .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain character/string data? — col_is_character","text":"","code":"col_is_character(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_character(object, columns, threshold = 1)  test_col_is_character(object, columns, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain character/string data? — col_is_character","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain character/string data? — col_is_character","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do the columns contain character/string data? — col_is_character","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain character/string data? — col_is_character","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain character/string data? — col_is_character","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do the columns contain character/string data? — col_is_character","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain character/string data? — col_is_character","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain character/string data? — col_is_character","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_character() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_character() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_is_character(     columns = a,     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_character()` step.\",     active = FALSE   ) steps: - col_is_character:     columns: c(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_character()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain character/string data? — col_is_character","text":"examples , use simple table numeric column () character column (b).   use table different function variants.","code":"tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = LETTERS[1:6]   )  tbl #> # A tibble: 6 x 2 #>       a b #>   <dbl> <chr> #> 1     5 A #> 2     7 B #> 3     6 C #> 4     5 D #> 5     8 E #> 6     7 F"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do the columns contain character/string data? — col_is_character","text":"Validate column b character class.   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_is_character(columns = b) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do the columns contain character/string data? — col_is_character","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   col_is_character(columns = b) %>%   dplyr::slice(1:5) #> # A tibble: 5 x 2 #>       a b #>   <dbl> <chr> #> 1     5 A #> 2     7 B #> 3     6 C #> 4     5 D #> 5     8 E"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do the columns contain character/string data? — col_is_character","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_is_character(tbl, columns = b)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do the columns contain character/string data? — col_is_character","text":"test_*() form, get single logical value returned us.","code":"tbl %>% test_col_is_character(columns = b) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_character.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain character/string data? — col_is_character","text":"2-22","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain R Date objects? — col_is_date","title":"Do the columns contain R Date objects? — col_is_date","text":"col_is_date() validation function, expect_col_is_date() expectation function, test_col_is_date() test function check whether one columns table R Date type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate single test unit, whether column Date-type column .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain R Date objects? — col_is_date","text":"","code":"col_is_date(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_date(object, columns, threshold = 1)  test_col_is_date(object, columns, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain R Date objects? — col_is_date","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain R Date objects? — col_is_date","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do the columns contain R Date objects? — col_is_date","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain R Date objects? — col_is_date","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain R Date objects? — col_is_date","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do the columns contain R Date objects? — col_is_date","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain R Date objects? — col_is_date","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain R Date objects? — col_is_date","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_date() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_date() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_is_date(     columns = a,     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_date()` step.\",     active = FALSE   ) steps: - col_is_date:     columns: c(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_date()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain R Date objects? — col_is_date","text":"small_table dataset package date column. following examples validate column Date class.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do the columns contain R Date objects? — col_is_date","text":"Validate column date Date class.   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = small_table) %>%   col_is_date(columns = date) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do the columns contain R Date objects? — col_is_date","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"small_table %>%   col_is_date(columns = date) %>%   dplyr::slice(1:5) #> # A tibble: 5 x 8 #>   date_time           date           a b             c      d e     f #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do the columns contain R Date objects? — col_is_date","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_is_date(small_table, columns = date)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do the columns contain R Date objects? — col_is_date","text":"test_*() form, get single logical value returned us.","code":"small_table %>% test_col_is_date(columns = date) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_date.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain R Date objects? — col_is_date","text":"2-26","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain R factor objects? — col_is_factor","title":"Do the columns contain R factor objects? — col_is_factor","text":"col_is_factor() validation function, expect_col_is_factor() expectation function, test_col_is_factor() test function check whether one columns table factor type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate single test unit, whether column factor-type column .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain R factor objects? — col_is_factor","text":"","code":"col_is_factor(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_factor(object, columns, threshold = 1)  test_col_is_factor(object, columns, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain R factor objects? — col_is_factor","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain R factor objects? — col_is_factor","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do the columns contain R factor objects? — col_is_factor","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain R factor objects? — col_is_factor","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain R factor objects? — col_is_factor","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do the columns contain R factor objects? — col_is_factor","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain R factor objects? — col_is_factor","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain R factor objects? — col_is_factor","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_factor() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_factor() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_is_factor(     columns = a,     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_factor()` step.\",     active = FALSE   ) steps: - col_is_factor:     columns: c(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_factor()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain R factor objects? — col_is_factor","text":"modify f column small_table dataset values factors instead character class. following examples validate f column successfully mutated now consists factors.","code":"tbl <-   small_table %>%   dplyr::mutate(f = factor(f))  tbl #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <fct> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do the columns contain R factor objects? — col_is_factor","text":"Validate column f tbl object factor class.   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_is_factor(columns = f) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do the columns contain R factor objects? — col_is_factor","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   col_is_factor(columns = f) %>%   dplyr::slice(1:5) #> # A tibble: 5 x 8 #>   date_time           date           a b             c      d e     f #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <fct> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do the columns contain R factor objects? — col_is_factor","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_is_factor(tbl, f)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do the columns contain R factor objects? — col_is_factor","text":"test_*() form, get single logical value returned us.","code":"tbl %>% test_col_is_factor(columns = f) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_factor.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain R factor objects? — col_is_factor","text":"2-28","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain integer values? — col_is_integer","title":"Do the columns contain integer values? — col_is_integer","text":"col_is_integer() validation function, expect_col_is_integer() expectation function, test_col_is_integer() test function check whether one columns table integer type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate single test unit, whether column integer-type column .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain integer values? — col_is_integer","text":"","code":"col_is_integer(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_integer(object, columns, threshold = 1)  test_col_is_integer(object, columns, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain integer values? — col_is_integer","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain integer values? — col_is_integer","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do the columns contain integer values? — col_is_integer","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain integer values? — col_is_integer","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain integer values? — col_is_integer","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do the columns contain integer values? — col_is_integer","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain integer values? — col_is_integer","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain integer values? — col_is_integer","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_integer() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_integer() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_is_integer(     columns = a,     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_integer()` step.\",     active = FALSE   ) steps: - col_is_integer:     columns: c(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_integer()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain integer values? — col_is_integer","text":"examples , use simple table character column () integer column (b).","code":"tbl <-   dplyr::tibble(     a = letters[1:6],     b = 2:7   )  tbl #> # A tibble: 6 x 2 #>   a         b #>   <chr> <int> #> 1 a         2 #> 2 b         3 #> 3 c         4 #> 4 d         5 #> 5 e         6 #> 6 f         7"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do the columns contain integer values? — col_is_integer","text":"Validate column b integer class.   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_is_integer(columns = b) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do the columns contain integer values? — col_is_integer","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>% col_is_integer(columns = b) #> # A tibble: 6 x 2 #>   a         b #>   <chr> <int> #> 1 a         2 #> 2 b         3 #> 3 c         4 #> 4 d         5 #> 5 e         6 #> 6 f         7"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do the columns contain integer values? — col_is_integer","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_is_integer(tbl, columns = b)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do the columns contain integer values? — col_is_integer","text":"test_*() form, get single logical value returned us.","code":"tbl %>% test_col_is_integer(columns = b) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_integer.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain integer values? — col_is_integer","text":"2-24","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain logical values? — col_is_logical","title":"Do the columns contain logical values? — col_is_logical","text":"col_is_logical() validation function, expect_col_is_logical() expectation function, test_col_is_logical() test function check whether one columns table logical (TRUE/FALSE) type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate single test unit, whether column logical-type column .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain logical values? — col_is_logical","text":"","code":"col_is_logical(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_logical(object, columns, threshold = 1)  test_col_is_logical(object, columns, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain logical values? — col_is_logical","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain logical values? — col_is_logical","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do the columns contain logical values? — col_is_logical","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain logical values? — col_is_logical","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain logical values? — col_is_logical","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do the columns contain logical values? — col_is_logical","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain logical values? — col_is_logical","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain logical values? — col_is_logical","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_logical() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_logical() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_is_logical(     columns = a,     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_logical()` step.\",     active = FALSE   ) steps: - col_is_logical:     columns: c(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_logical()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain logical values? — col_is_logical","text":"small_table dataset package e column logical values. following examples validate column logical class.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do the columns contain logical values? — col_is_logical","text":"Validate column e logical class.   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = small_table) %>%   col_is_logical(columns = e) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do the columns contain logical values? — col_is_logical","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"small_table %>%   col_is_logical(columns = e) %>%   dplyr::slice(1:5) #> # A tibble: 5 x 8 #>   date_time           date           a b             c      d e     f #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do the columns contain logical values? — col_is_logical","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_is_logical(small_table, columns = e)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do the columns contain logical values? — col_is_logical","text":"test_*() form, get single logical value returned us.","code":"small_table %>% test_col_is_logical(columns = e) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_logical.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain logical values? — col_is_logical","text":"2-25","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain numeric values? — col_is_numeric","title":"Do the columns contain numeric values? — col_is_numeric","text":"col_is_numeric() validation function, expect_col_is_numeric() expectation function, test_col_is_numeric() test function check whether one columns table numeric type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate single test unit, whether column numeric-type column .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain numeric values? — col_is_numeric","text":"","code":"col_is_numeric(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_numeric(object, columns, threshold = 1)  test_col_is_numeric(object, columns, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain numeric values? — col_is_numeric","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain numeric values? — col_is_numeric","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do the columns contain numeric values? — col_is_numeric","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain numeric values? — col_is_numeric","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain numeric values? — col_is_numeric","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do the columns contain numeric values? — col_is_numeric","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain numeric values? — col_is_numeric","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain numeric values? — col_is_numeric","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_numeric() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_numeric() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_is_numeric(     columns = a,     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_numeric()` step.\",     active = FALSE   ) steps: - col_is_numeric:     columns: c(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_numeric()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain numeric values? — col_is_numeric","text":"small_table dataset package d column known numeric. following examples validate column indeed numeric class.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do the columns contain numeric values? — col_is_numeric","text":"Validate column d numeric class.   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = small_table) %>%   col_is_numeric(columns = d) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do the columns contain numeric values? — col_is_numeric","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"small_table %>%   col_is_numeric(columns = d) %>%   dplyr::slice(1:5) #> # A tibble: 5 x 8 #>   date_time           date           a b             c      d e     f #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do the columns contain numeric values? — col_is_numeric","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_is_numeric(small_table, columns = d)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do the columns contain numeric values? — col_is_numeric","text":"test_*() form, get single logical value returned us.","code":"small_table %>% test_col_is_numeric(columns = d) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_numeric.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain numeric values? — col_is_numeric","text":"2-23","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":null,"dir":"Reference","previous_headings":"","what":"Do the columns contain POSIXct dates? — col_is_posix","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"col_is_posix() validation function, expect_col_is_posix() expectation function, test_col_is_posix() test function check whether one columns table R POSIXct date-time type. Like many col_is_*()-type functions pointblank, requirement specification column names. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate single test unit, whether column POSIXct-type column .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"","code":"col_is_posix(   x,   columns,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_is_posix(object, columns, threshold = 1)  test_col_is_posix(object, columns, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_is_*()-type functions, using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_is_posix() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_is_posix() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_is_posix(     columns = a,     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_is_posix()` step.\",     active = FALSE   ) steps: - col_is_posix:     columns: c(a)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_is_posix()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"small_table dataset package date_time column. following examples validate column POSIXct POSIXt classes.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"Validate column date_time indeed date-time column.   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = small_table) %>%   col_is_posix(columns = date_time) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"small_table %>%   col_is_posix(columns = date_time) %>%   dplyr::slice(1:5) #> # A tibble: 5 x 8 #>   date_time           date           a b             c      d e     f #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_is_posix(small_table, columns = date_time)"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"test_*() form, get single logical value returned us.","code":"small_table %>% test_col_is_posix(columns = date_time) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_is_posix.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do the columns contain POSIXct dates? — col_is_posix","text":"2-27","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a table column schema manually or with a reference table — col_schema","title":"Generate a table column schema manually or with a reference table — col_schema","text":"table column schema object, can created col_schema(), necessary using col_schema_match() validation function (checks whether table object study matches known column schema). col_schema object can made carefully supplying column names types set named arguments, , provide table object, data.frame, tbl_df, tbl_dbi, tbl_spark varieties. additional option, just validating schema tbl_dbi tbl_spark object: can validate schema based R column types (e.g., \"numeric\", \"character\", etc.), SQL column types (e.g., \"double\", \"varchar\", etc.), Spark SQL column types (\"DoubleType\", \"StringType\", etc.). great want validate table column schemas server side tabular data collected loaded R.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a table column schema manually or with a reference table — col_schema","text":"","code":"col_schema(..., .tbl = NULL, .db_col_types = c(\"r\", \"sql\"))"},{"path":"https://rstudio.github.io/pointblank/reference/col_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a table column schema manually or with a reference table — col_schema","text":"... Column--column schema definition <multiple expressions> // required (, use .tbl) set named arguments names refer column names values one column types. .tbl data table defining schema obj:<tbl_*> // optional option use table object define schema. provided values provided ... ignored. can either table object, table-prep formula.can table object data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, table-prep formula (~ <tbl reading code>) function (function() <tbl reading code>) can used lazily read table interrogation time. .db_col_types Use R column types database column types? singl-kw:[r|sql] // default: \"r\" Determines whether column types refer R column types (\"r\") SQL column types (\"sql\").","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_schema.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a table column schema manually or with a reference table — col_schema","text":"Create simple table two columns: one integer character.   Create column schema object describes columns types (expected order).   Validate schema object schema_obj exactly defines column names column types tbl table.   Determine validation step passed using all_passed().     can alternatively create column schema object tbl_df object.   provide interrogation results previous example.","code":"tbl <-   dplyr::tibble(     a = 1:5,     b = letters[1:5]   )  tbl #> # A tibble: 5 x 2 #>       a b #>   <int> <chr> #> 1     1 a #> 2     2 b #> 3     3 c #> 4     4 d #> 5     5 e schema_obj <-   col_schema(     a = \"integer\",     b = \"character\"   )  schema_obj #> $a #> [1] \"integer\" #> #> $b #> [1] \"character\" #> #> attr(,\"class\") #> [1] \"r_type\"     \"col_schema\" agent <-   create_agent(tbl = tbl) %>%   col_schema_match(schema_obj) %>%   interrogate() all_passed(agent) ## [1] TRUE schema_obj <-   col_schema(     .tbl = dplyr::tibble(       a = integer(0),       b = character(0)     )   ) create_agent(tbl = tbl) %>%   col_schema_match(schema_obj) %>%   interrogate() %>%   all_passed() ## [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_schema.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Generate a table column schema manually or with a reference table — col_schema","text":"13-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"col_schema_match() validation function, expect_col_schema_match() expectation function, test_col_schema_match() test function work conjunction col_schema object (generated col_schema() function) determine whether expected schema matches target table. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operates single test unit, whether schema matches table (within constraints enforced complete, in_order, is_exact options). target table tbl_dbi tbl_spark object, can choose validate column schema based R column types (e.g., \"numeric\", \"character\", etc.), SQL column types (e.g., \"double\", \"varchar\", etc.), Spark SQL types (e.g,. \"DoubleType\", \"StringType\", etc.). option defined col_schema() function (.db_col_types argument). options make schema checking less stringent (default, validation operates highest level strictness). complete option set FALSE, can supply col_schema object partial inclusion columns. Using in_order set FALSE means requirement columns defined schema object order target table. Finally, is_exact option set FALSE means column classes/types provided particular column. can even NULL, skipping check column type.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"","code":"col_schema_match(   x,   schema,   complete = TRUE,   in_order = TRUE,   is_exact = TRUE,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_schema_match(   object,   schema,   complete = TRUE,   in_order = TRUE,   is_exact = TRUE,   threshold = 1 )  test_col_schema_match(   object,   schema,   complete = TRUE,   in_order = TRUE,   is_exact = TRUE,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). schema table schema obj:<col_schema> // required table schema type col_schema can generated using col_schema() function. complete Requirement columns specified exist scalar<logical> // default: TRUE requirement account table columns provided schema. default, TRUE column names target table must present schema object. restriction can relaxed using FALSE, can provide subset table columns schema. in_order Requirement columns specific order scalar<logical> // default: TRUE stringent requirement enforcing order columns provided schema. default, TRUE order columns schema target table must match. setting FALSE, strict order requirement removed. is_exact Requirement column types exactly specified scalar<logical> // default: TRUE Determines whether check column types exact even performed . example, columns R data frames may multiple classes (e.g., date-time column can \"POSIXct\" \"POSIXt\" classes). using is_exact == FALSE, column type user-defined schema date-time value can set either \"POSIXct\" \"POSIXt\" pass validation (column, least). can taken step using NULL column type user-defined schema skip validation check column type. default, is_exact set TRUE. actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. Using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_schema_match() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_schema_match() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter schema argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_schema_match(     schema = col_schema(       a = \"integer\",       b = \"character\"     ),     complete = FALSE,     in_order = FALSE,     is_exact = FALSE,     actions = action_levels(stop_at = 1),     label = \"The `col_schema_match()` step.\",     active = FALSE   ) steps: - col_schema_match:     schema:       a: integer       b: character     complete: false     in_order: false     is_exact: false     actions:       stop_count: 1.0     label: The `col_schema_match()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"examples , use simple table two columns: one integer () character (b). following examples validate table columns abides match schema object created col_schema().   Create column schema object helper function col_schema() describes columns types (expected order).","code":"tbl <-   dplyr::tibble(     a = 1:5,     b = letters[1:5]   )  tbl #> # A tibble: 5 x 2 #>       a b #>   <int> <chr> #> 1     1 a #> 2     2 b #> 3     3 c #> 4     4 d #> 5     5 e schema_obj <-   col_schema(     a = \"integer\",     b = \"character\"   )  schema_obj #> $a #> [1] \"integer\" #> #> $b #> [1] \"character\" #> #> attr(,\"class\") #> [1] \"r_type\"     \"col_schema\""},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"Validate schema object schema_obj exactly defines column names column types. determine validation failing test unit (single test unit governed whether match).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_schema_match(schema = schema_obj) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>% col_schema_match(schema = schema_obj) #> # A tibble: 5 x 2 #>       a b #>   <int> <chr> #> 1     1 a #> 2     2 b #> 3     3 c #> 4     4 d #> 5     5 e"},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_schema_match(tbl, scheam = schema_obj)"},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"test_*() form, get single logical value returned us.","code":"tbl %>% test_col_schema_match(schema = schema_obj) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_schema_match.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do columns in the table (and their types) match a predefined schema? — col_schema_match","text":"2-30","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":null,"dir":"Reference","previous_headings":"","what":"Do column data lie between two specified values or data in other columns? — col_vals_between","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"col_vals_between() validation function, expect_col_vals_between() expectation function, test_col_vals_between() test function check whether column values table fall within range. range specified three arguments: left, right, inclusive. left right values specify lower upper bounds. bounds can specified single, literal values column names given vars(). inclusive argument, vector two logical values relating left right, states whether bound inclusive . default c(TRUE, TRUE), endpoints inclusive (.e., [left, right]). partially-unbounded versions function, can use col_vals_lt(), col_vals_lte(), col_vals_gt(), col_vals_gte() validation functions. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"","code":"col_vals_between(   x,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. left Definition left bound <value expression> // required lower bound range. validation includes bound value (first element inclusive TRUE) addition values greater left. can single value compatible column given vars(). right Definition right bound <value expression> // required upper bound range. validation includes bound value (second element inclusive TRUE) addition values lower right. can single value compatible column given vars(). inclusive Inclusiveness bounds vector<logical> // default: c(TRUE, TRUE) two-element logical value indicates whether left right bounds inclusive. default, bounds inclusive. na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_between() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_between() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns, left, right arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_between(     columns = a,     left = 1,     right = 2,     inclusive = c(TRUE, FALSE),     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_between()` step.\",     active = FALSE   ) steps: - col_vals_between:     columns: c(a)     left: 1.0     right: 2.0     inclusive:     - true     - false     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_between()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"small_table dataset package column numeric values c (NAs column). following examples validate values numeric column.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"Validate values column c 1 9. NA values, choose let pass validation setting na_pass = TRUE.   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = small_table) %>%   col_vals_between(     columns = c,     left = 1, right = 9,     na_pass = TRUE   ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"small_table %>%   col_vals_between(     columns = c,     left = 1, right = 9,     na_pass = TRUE   ) %>%   dplyr::pull(c) #>  [1]  3  8  3 NA  7  4  3  2  9  9  7  8 NA"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_between(   small_table, columns = c,   left = 1, right = 9,   na_pass = TRUE )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"test_*() form, get single logical value returned us.   additional note bounds function: inclusive default (.e., values exactly 1 9 pass). can modify inclusiveness upper lower bounds inclusive option, length-2 logical vector. Testing upper bound non-inclusive, get FALSE since two values 9 now fall outside upper (right) bound.","code":"small_table %>%   test_col_vals_between(     columns = c,     left = 1, right = 9,     na_pass = TRUE   ) #> [1] TRUE small_table %>%   test_col_vals_between(     columns = c, left = 1, right = 9,     inclusive = c(TRUE, FALSE),     na_pass = TRUE   ) #> [1] FALSE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_between.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do column data lie between two specified values or data in other columns? — col_vals_between","text":"2-7","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data decreasing by row? — col_vals_decreasing","title":"Are column data decreasing by row? — col_vals_decreasing","text":"col_vals_decreasing() validation function, expect_col_vals_decreasing() expectation function, test_col_vals_decreasing() test function check whether column values table decreasing moving table. options allowing NA values target column, allowing stationary phases (consecutive values change), even allowing increasing movements certain threshold. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data decreasing by row? — col_vals_decreasing","text":"","code":"col_vals_decreasing(   x,   columns,   allow_stationary = FALSE,   increasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_decreasing(   object,   columns,   allow_stationary = FALSE,   increasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_decreasing(   object,   columns,   allow_stationary = FALSE,   increasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data decreasing by row? — col_vals_decreasing","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. allow_stationary Allowance stationary pauses values scalar<logical> // default: FALSE option allow pauses decreasing values. example values test units [85, 82, 82, 80, 77] third unit (82, appearing second time) marked fail allow_stationary FALSE. Using allow_stationary = TRUE result test units [85, 82, 82, 80, 77] marked pass. increasing_tol Optional tolerance threshold backtracking scalar<numeric>(val>=0) // default: NULL (optional) optional threshold value allows movement numerical values positive direction. default NULL using numerical value set absolute threshold positive travel allowed across numerical test units. Note setting value also effect setting allow_stationary TRUE. na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data decreasing by row? — col_vals_decreasing","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are column data decreasing by row? — col_vals_decreasing","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data decreasing by row? — col_vals_decreasing","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data decreasing by row? — col_vals_decreasing","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data decreasing by row? — col_vals_decreasing","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data decreasing by row? — col_vals_decreasing","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data decreasing by row? — col_vals_decreasing","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are column data decreasing by row? — col_vals_decreasing","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data decreasing by row? — col_vals_decreasing","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data decreasing by row? — col_vals_decreasing","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_decreasing() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_decreasing() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_decreasing(     columns = a,     allow_stationary = TRUE,     increasing_tol = 0.5,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_decreasing()` step.\",     active = FALSE   ) steps: - col_vals_decreasing:     columns: c(a)     allow_stationary: true     increasing_tol: 0.5     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_decreasing()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data decreasing by row? — col_vals_decreasing","text":"game_revenue dataset package column session_start, contains date-time values. create column difftime values (time_left) describes time remaining month relative session start.   ensure \"difftime\" values new time_left column values decreasing top bottom.","code":"game_revenue_2 <-   game_revenue %>%   dplyr::mutate(     time_left =       lubridate::ymd_hms(         \"2015-02-01 00:00:00\"       ) - session_start   )  game_revenue_2 #> # A tibble: 2,000 x 12 #>    player_id       session_id  session_start       time                item_type #>    <chr>           <chr>       <dttm>              <dttm>              <chr> #>  1 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:31:27 iap #>  2 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:36:57 iap #>  3 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:37:45 iap #>  4 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:42:33 ad #>  5 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 11:55:20 ad #>  6 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:08:56 ad #>  7 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:14:08 ad #>  8 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:21:44 ad #>  9 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:24:20 ad #> 10 FXWUORGYNJAE271 FXWUORGYNJ~ 2015-01-01 15:17:18 2015-01-01 15:19:36 ad #> # i 1,990 more rows #> # i 7 more variables: item_name <chr>, item_revenue <dbl>, #> #   session_duration <dbl>, start_day <date>, acquisition <chr>, country <chr>, #> #   time_left <drtn>"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are column data decreasing by row? — col_vals_decreasing","text":"Validate \"difftime\" values column time_left decreasing, , allow repeating values (allow_stationary set TRUE).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = game_revenue_2) %>%   col_vals_decreasing(     columns = time_left,     allow_stationary = TRUE   ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are column data decreasing by row? — col_vals_decreasing","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"game_revenue_2 %>%   col_vals_decreasing(     columns = time_left,     allow_stationary = TRUE   ) %>%   dplyr::select(time_left) %>%   dplyr::distinct() %>%   dplyr::count() #> # A tibble: 1 x 1 #>       n #>   <int> #> 1   618"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are column data decreasing by row? — col_vals_decreasing","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_decreasing(   game_revenue_2,   columns = time_left,   allow_stationary = TRUE )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are column data decreasing by row? — col_vals_decreasing","text":"test_*() form, get single logical value returned us.","code":"game_revenue_2 %>%   test_col_vals_decreasing(     columns = time_left,     allow_stationary = TRUE   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_decreasing.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data decreasing by row? — col_vals_decreasing","text":"2-14","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data equal to a fixed value or data in another column? — col_vals_equal","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"col_vals_equal() validation function, expect_col_vals_equal() expectation function, test_col_vals_equal() test function check whether column values table equal specified value. value can specified single, literal value column name given vars(). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"","code":"col_vals_equal(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. value Value comparison <value expression> // required value used test equality. can single value compatible column given vars(). column values equal specified pass validation. na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_equal() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_equal() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_equal(     columns = a,     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_equal()` step.\",     active = FALSE   ) steps: - col_vals_equal:     columns: c(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_equal()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"examples , use simple table three numeric columns (, b, c) three character columns (d, e, f).","code":"tbl <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 2, 2),     d = LETTERS[c(1:3, 5:7)],     e = LETTERS[c(1:6)],     f = LETTERS[c(1:6)]   )  tbl #> # A tibble: 6 x 6 #>       a     b     c d     e     f #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 A     A     A #> 2     5     1     1 B     B     B #> 3     5     1     1 C     C     C #> 4     5     2     2 E     D     D #> 5     5     2     2 F     E     E #> 6     5     2     2 G     F     F"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"Validate values column equal value 5. determine validation failing test units (6 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_vals_equal(columns = a, value = 5) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   col_vals_equal(columns = a, value = 5) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_equal(tbl, columns = a, value = 5)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"test_*() form, get single logical value returned us.","code":"test_col_vals_equal(tbl, columns = a, value = 5) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_equal.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data equal to a fixed value or data in another column? — col_vals_equal","text":"2-3","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"Do column data agree with a predicate expression? — col_vals_expr","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"col_vals_expr() validation function, expect_col_vals_expr() expectation function, test_col_vals_expr() test function check whether column values table agree user-defined predicate expression. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"","code":"col_vals_expr(   x,   expr,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_expr(   object,   expr,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_expr(   object,   expr,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). expr Predicate expression <predicate expression> // required predicate expression use validation. can either form call made expr() function one-sided R formula (using leading ~). na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_expr() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_expr() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter expr argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_expr(     expr = ~ a %% 1 == 0,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_expr()` step.\",     active = FALSE   ) steps: - col_vals_expr:     expr: ~a%%1 == 0     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_expr()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"examples , use simple table three numeric columns (, b, c) three character columns (d, e, f).","code":"tbl <-   dplyr::tibble(     a = c(1, 2, 1, 7, 8, 6),     b = c(0, 0, 0, 1, 1, 1),     c = c(0.5, 0.3, 0.8, 1.4, 1.9, 1.2),   )  tbl #> # A tibble: 6 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     1     0   0.5 #> 2     2     0   0.3 #> 3     1     0   0.8 #> 4     7     1   1.4 #> 5     8     1   1.9 #> 6     6     1   1.2"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"Validate values column integer-like using R modulo operator expecting 0. determine validation failing test units (6 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_vals_expr(expr = expr(a %% 1 == 0)) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   col_vals_expr(expr = expr(a %% 1 == 0)) %>%   dplyr::pull(a) #> [1] 1 2 1 7 8 6"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_expr(tbl, expr = ~ a %% 1 == 0)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"test_*() form, get single logical value returned us.","code":"test_col_vals_expr(tbl, expr = ~ a %% 1 == 0) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"variations","dir":"Reference","previous_headings":"","what":"Variations","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"can complex things taking advantage case_when() () functions (available use pointblank package).   want test subset rows, case_when() statement need exhaustive. rows fall cases pruned (giving us less test units overall).","code":"tbl %>%   test_col_vals_expr(expr = ~ case_when(     b == 0 ~ a %>% between(0, 5) & c < 1,     b == 1 ~ a > 5 & c >= 1   )) #> [1] TRUE tbl %>%   test_col_vals_expr(expr = ~ case_when(     b == 1 ~ a > 5 & c >= 1   )) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_expr.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do column data agree with a predicate expression? — col_vals_expr","text":"2-19","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data greater than a fixed value or data in another column? — col_vals_gt","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"col_vals_gt() validation function, expect_col_vals_gt() expectation function, test_col_vals_gt() test function check whether column values table greater specified value (exact comparison used function col_val > value). value can specified single, literal value column name given vars(). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"","code":"col_vals_gt(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_gt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_gt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. value Value comparison <value expression> // required value used comparison. can single value compatible column given vars(). column values greater specified pass validation. na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_gt() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_gt() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_gt(     columns = a,     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_gt()` step.\",     active = FALSE   ) steps: - col_vals_gt:     columns: c(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_gt()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"examples , use simple table three numeric columns (, b, c) three character columns (d, e, f).","code":"tbl <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 3, 4),     d = LETTERS[a],     e = LETTERS[b],     f = LETTERS[c]   )  tbl #> # A tibble: 6 x 6 #>       a     b     c d     e     f #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A #> 2     5     1     1 E     A     A #> 3     5     1     1 E     A     A #> 4     5     2     2 E     B     B #> 5     5     2     3 E     B     C #> 6     5     2     4 E     B     D"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"Validate values column greater value 4. determine validation failing test units (6 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_vals_gt(columns = a, value = 4) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>% col_vals_gt(columns = a, value = 4) #> # A tibble: 6 x 6 #>       a     b     c d     e     f #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A #> 2     5     1     1 E     A     A #> 3     5     1     1 E     A     A #> 4     5     2     2 E     B     B #> 5     5     2     3 E     B     C #> 6     5     2     4 E     B     D"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_gt(tbl, columns = a, value = 4)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"test_*() form, get single logical value returned us.","code":"test_col_vals_gt(tbl, columns = a, value = 4) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gt.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data greater than a fixed value or data in another column? — col_vals_gt","text":"2-6","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"col_vals_gte() validation function, expect_col_vals_gte() expectation function, test_col_vals_gte() test function check whether column values table greater equal specified value (exact comparison used function col_val >= value). value can specified single, literal value column name given vars(). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"","code":"col_vals_gte(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_gte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_gte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. value Value comparison <value expression> // required value used comparison. can single value compatible column given vars(). column values greater equal specified pass validation. na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_gte() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_gte() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_gte(     columns = a,     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_gte()` step.\",     active = FALSE   ) steps: - col_vals_gte:     columns: c(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_gte()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"examples , use simple table three numeric columns (, b, c) three character columns (d, e, f).","code":"tbl <-   dplyr::tibble(       a = c(5, 5, 5, 5, 5, 5),       b = c(1, 1, 1, 2, 2, 2),       c = c(1, 1, 1, 2, 3, 4),       d = LETTERS[a],       e = LETTERS[b],       f = LETTERS[c]   )  tbl #> # A tibble: 6 x 6 #>       a     b     c d     e     f #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A #> 2     5     1     1 E     A     A #> 3     5     1     1 E     A     A #> 4     5     2     2 E     B     B #> 5     5     2     3 E     B     C #> 6     5     2     4 E     B     D"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"Validate values column greater equal value 5. determine validation failing test units (6 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_vals_gte(columns = a, value = 5) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>% col_vals_gte(columns = a, value = 5) #> # A tibble: 6 x 6 #>       a     b     c d     e     f #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A #> 2     5     1     1 E     A     A #> 3     5     1     1 E     A     A #> 4     5     2     2 E     B     B #> 5     5     2     3 E     B     C #> 6     5     2     4 E     B     D"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_gte(tbl, columns = a, value = 5)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"test_*() form, get single logical value returned us.","code":"test_col_vals_gte(tbl, columns = a, value = 5) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_gte.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data greater than or equal to a fixed value or data in another column? — col_vals_gte","text":"2-5","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data part of a specified set of values? — col_vals_in_set","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"col_vals_in_set() validation function, expect_col_vals_in_set() expectation function, test_col_vals_in_set() test function check whether column values table part specified set values. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"","code":"col_vals_in_set(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_in_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_in_set(object, columns, set, preconditions = NULL, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. set Set values vector<integer|numeric|character> // required vector numeric string-based elements, column values found within set considered passing. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_in_set() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_in_set() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_in_set(     columns = a,     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_in_set()` step.\",     active = FALSE   ) steps: - col_vals_in_set:    columns: c(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: The `col_vals_in_set()` step.    active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"small_table dataset package used validate column values part given set.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"Validate values column f part set values containing low, mid, high. determine validation failing test units (13 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = small_table) %>%   col_vals_in_set(     columns = f, set = c(\"low\", \"mid\", \"high\")   ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"small_table %>%   col_vals_in_set(     columns = f, set = c(\"low\", \"mid\", \"high\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_in_set(   small_table,   columns = f, set = c(\"low\", \"mid\", \"high\") )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"test_*() form, get single logical value returned us.","code":"small_table %>%   test_col_vals_in_set(     columns = f, set = c(\"low\", \"mid\", \"high\")   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_in_set.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data part of a specified set of values? — col_vals_in_set","text":"2-9","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data increasing by row? — col_vals_increasing","title":"Are column data increasing by row? — col_vals_increasing","text":"col_vals_increasing() validation function, expect_col_vals_increasing() expectation function, test_col_vals_increasing() test function check whether column values table increasing moving table. options allowing NA values target column, allowing stationary phases (consecutive values change), even allowing decreasing movements certain threshold. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data increasing by row? — col_vals_increasing","text":"","code":"col_vals_increasing(   x,   columns,   allow_stationary = FALSE,   decreasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_increasing(   object,   columns,   allow_stationary = FALSE,   decreasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_increasing(   object,   columns,   allow_stationary = FALSE,   decreasing_tol = NULL,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data increasing by row? — col_vals_increasing","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. allow_stationary Allowance stationary pauses values scalar<logical> // default: FALSE option allow pauses decreasing values. example values test units [80, 82, 82, 85, 88] third unit (82, appearing second time) marked fail allow_stationary FALSE. Using allow_stationary = TRUE result test units [80, 82, 82, 85, 88] marked pass. decreasing_tol Optional tolerance threshold backtracking scalar<numeric>(val>=0) // default: NULL (optional) optional threshold value allows movement numerical values negative direction. default NULL using numerical value set absolute threshold negative travel allowed across numerical test units. Note setting value also effect setting allow_stationary TRUE. na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data increasing by row? — col_vals_increasing","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are column data increasing by row? — col_vals_increasing","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data increasing by row? — col_vals_increasing","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data increasing by row? — col_vals_increasing","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data increasing by row? — col_vals_increasing","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data increasing by row? — col_vals_increasing","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data increasing by row? — col_vals_increasing","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are column data increasing by row? — col_vals_increasing","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data increasing by row? — col_vals_increasing","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data increasing by row? — col_vals_increasing","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_increasing() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_increasing() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_increasing(     columns = a,     allow_stationary = TRUE,     decreasing_tol = 0.5,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_increasing()` step.\",     active = FALSE   ) steps: - col_vals_increasing:     columns: c(a)     allow_stationary: true     decreasing_tol: 0.5     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_increasing()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data increasing by row? — col_vals_increasing","text":"game_revenue dataset package column session_start, contains date-time values. ensure column values increasing top bottom.","code":"game_revenue #> # A tibble: 2,000 x 11 #>    player_id       session_id  session_start       time                item_type #>    <chr>           <chr>       <dttm>              <dttm>              <chr> #>  1 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:31:27 iap #>  2 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:36:57 iap #>  3 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:37:45 iap #>  4 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:42:33 ad #>  5 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 11:55:20 ad #>  6 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:08:56 ad #>  7 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:14:08 ad #>  8 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:21:44 ad #>  9 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:24:20 ad #> 10 FXWUORGYNJAE271 FXWUORGYNJ~ 2015-01-01 15:17:18 2015-01-01 15:19:36 ad #> # i 1,990 more rows #> # i 6 more variables: item_name <chr>, item_revenue <dbl>, #> #   session_duration <dbl>, start_day <date>, acquisition <chr>, country <chr>"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are column data increasing by row? — col_vals_increasing","text":"Validate date-time values column session_start increasing, , allow repeating values (allow_stationary set TRUE). determine validation failing test units (2000 test units).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = game_revenue) %>%   col_vals_increasing(     columns = session_start,     allow_stationary = TRUE   ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are column data increasing by row? — col_vals_increasing","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"game_revenue %>%   col_vals_increasing(     columns = session_start,     allow_stationary = TRUE   ) %>%   dplyr::select(session_start) %>%   dplyr::distinct() %>%   dplyr::count() #> # A tibble: 1 x 1 #>       n #>   <int> #> 1   618"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are column data increasing by row? — col_vals_increasing","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_increasing(   game_revenue,   columns = session_start,   allow_stationary = TRUE )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are column data increasing by row? — col_vals_increasing","text":"test_*() form, get single logical value returned us.","code":"game_revenue %>%   test_col_vals_increasing(     columns = session_start,     allow_stationary = TRUE   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_increasing.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data increasing by row? — col_vals_increasing","text":"2-13","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data less than a fixed value or data in another column? — col_vals_lt","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"col_vals_lt() validation function, expect_col_vals_lt() expectation function, test_col_vals_lt() test function check whether column values table less specified value (exact comparison used function col_val < value). value can specified single, literal value column name given vars(). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"","code":"col_vals_lt(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_lt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_lt(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. value Value comparison <value expression> // required value used comparison. can single value compatible column given vars(). column values less specified pass validation. na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_lt() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_lt() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_lt(     columns = a,     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_lt()` step.\",     active = FALSE   ) steps: - col_vals_lt:     columns: c(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_lt()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"examples , use simple table three numeric columns (, b, c) three character columns (d, e, f).","code":"tbl <-   dplyr::tibble(       a = c(5, 5, 5, 5, 5, 5),       b = c(1, 1, 1, 2, 2, 2),       c = c(1, 1, 1, 2, 3, 4),       d = LETTERS[a],       e = LETTERS[b],       f = LETTERS[c]   )  tbl #> # A tibble: 6 x 6 #>       a     b     c d     e     f #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A #> 2     5     1     1 E     A     A #> 3     5     1     1 E     A     A #> 4     5     2     2 E     B     B #> 5     5     2     3 E     B     C #> 6     5     2     4 E     B     D"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"Validate values column c less value 5. determine validation failing test units (6 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_vals_lt(columns = c, value = 5) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   col_vals_lt(columns = c, value = 5) %>%   dplyr::pull(c) #> [1] 1 1 1 2 3 4"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_lt(tbl, columns = c, value = 5)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"test_*() form, get single logical value returned us.","code":"test_col_vals_lt(tbl, columns = c, value = 5) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lt.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data less than a fixed value or data in another column? — col_vals_lt","text":"2-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"col_vals_lte() validation function, expect_col_vals_lte() expectation function, test_col_vals_lte() test function check whether column values table less equal specified value (exact comparison used function col_val <= value). value can specified single, literal value column name given vars(). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"","code":"col_vals_lte(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_lte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_lte(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. value Value comparison <value expression> // required value used comparison. can single value compatible column given vars(). column values less equal specified pass validation. na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_lte() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_lte() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_lte(     columns = a,     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_lte()` step.\",     active = FALSE   ) steps: - col_vals_lte:     columns: c(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_lte()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"examples , use simple table three numeric columns (, b, c) three character columns (d, e, f).","code":"tbl <-   dplyr::tibble(       a = c(5, 5, 5, 5, 5, 5),       b = c(1, 1, 1, 2, 2, 2),       c = c(1, 1, 1, 2, 3, 4),       d = LETTERS[a],       e = LETTERS[b],       f = LETTERS[c]   )  tbl #> # A tibble: 6 x 6 #>       a     b     c d     e     f #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A #> 2     5     1     1 E     A     A #> 3     5     1     1 E     A     A #> 4     5     2     2 E     B     B #> 5     5     2     3 E     B     C #> 6     5     2     4 E     B     D"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"Validate values column c less equal value 4. determine validation failing test units (6 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_vals_lte(columns = c, value = 4) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   col_vals_lte(columns = c, value = 4) %>%   dplyr::pull(c) #> [1] 1 1 1 2 3 4"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_lte(tbl, columns = c, value = 4)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"test_*() form, get single logical value returned us.","code":"test_col_vals_lte(tbl, columns = c, value = 4) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_lte.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data less than or equal to a fixed value or data in another column? — col_vals_lte","text":"2-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"col_vals_make_set() validation function, expect_col_vals_make_set() expectation function, test_col_vals_make_set() test function check whether set values seen least table column. necessary criterion additional values (outside definied set) seen (requirement relaxed col_vals_make_subset() validation function expectation test variants). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number elements set plus test unit reserved detecting column values outside set (outside value seen make additional test unit fail).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"","code":"col_vals_make_set(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_make_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_make_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. set Set values vector<integer|numeric|character> // required vector elements expected equal set unique values target column. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_make_set() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_make_set() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_make_set(     columns = a,     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_make_set()` step.\",     active = FALSE   ) steps: - col_vals_make_set:    columns: c(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: The `col_vals_make_set()` step.    active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"small_table dataset package used validate column values part given set.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"Validate values column f comprise values low, mid, high, , values. determine validation failing test units (4 test units).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = small_table) %>%   col_vals_make_set(     columns = f, set = c(\"low\", \"mid\", \"high\")   ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"small_table %>%   col_vals_make_set(     columns = f, set = c(\"low\", \"mid\", \"high\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_make_set(   small_table,   columns = f, set = c(\"low\", \"mid\", \"high\") )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"test_*() form, get single logical value returned us.","code":"small_table %>%   test_col_vals_make_set(     columns = f, set = c(\"low\", \"mid\", \"high\")   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_set.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Is a set of values entirely accounted for in a column of values? — col_vals_make_set","text":"2-11","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Is a set of values a subset of a column of values? — col_vals_make_subset","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"col_vals_make_subset() validation function, expect_col_vals_make_subset() expectation function, test_col_vals_make_subset() test function check whether set values seen least table column. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number elements set.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"","code":"col_vals_make_subset(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_make_subset(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_make_subset(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. set Set values vector<integer|numeric|character> // required vector elements expected subset unique values target column. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_make_subset() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_make_subset() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_make_subset(     columns = a,     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_make_subset()` step.\",     active = FALSE   ) steps: - col_vals_make_subset:    columns: c(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: The `col_vals_make_subset()` step.    active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"small_table dataset package used validate column values part given set.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"Validate distinct set values column f contains least subset defined low high (column actually mid values). determine validation failing test units (2 test units, one per element set).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = small_table) %>%   col_vals_make_subset(     columns = f, set = c(\"low\", \"high\")   ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"small_table %>%   col_vals_make_subset(     columns = f, set = c(\"low\", \"high\")   ) %>%   dplyr::pull(f) %>%   unique() #> [1] \"high\" \"low\"  \"mid\""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_make_subset(   small_table,   columns = f, set = c(\"low\", \"high\") )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"test_*() form, get single logical value returned us.","code":"small_table %>%   test_col_vals_make_subset(     columns = f, set = c(\"low\", \"high\")   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_make_subset.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Is a set of values a subset of a column of values? — col_vals_make_subset","text":"2-12","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":null,"dir":"Reference","previous_headings":"","what":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"col_vals_not_between() validation function, expect_col_vals_not_between() expectation function, test_col_vals_not_between() test function check whether column values table fall within range. range specified three arguments: left, right, inclusive. left right values specify lower upper bounds. bounds can specified single, literal values column names given vars(). inclusive argument, vector two logical values relating left right, states whether bound inclusive . default c(TRUE, TRUE), endpoints inclusive (.e., [left, right]). partially-unbounded versions function, can use col_vals_lt(), col_vals_lte(), col_vals_gt(), col_vals_gte() validation functions. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"","code":"col_vals_not_between(   x,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_not_between(   object,   columns,   left,   right,   inclusive = c(TRUE, TRUE),   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. left Definition left bound <value expression> // required lower bound range. validation includes bound value (first element inclusive TRUE) addition values greater left. can single value compatible column given vars(). right Definition right bound <value expression> // required upper bound range. validation includes bound value (second element inclusive TRUE) addition values lower right. can single value compatible column given vars(). inclusive Inclusiveness bounds vector<logical> // default: c(TRUE, TRUE) two-element logical value indicates whether left right bounds inclusive. default, bounds inclusive. na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_not_between() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_not_between() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns, left, right arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_not_between(     columns = a,     left = 1,     right = 2,     inclusive = c(TRUE, FALSE),     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_not_between()` step.\",     active = FALSE   ) steps: - col_vals_not_between:     columns: c(a)     left: 1.0     right: 2.0     inclusive:     - true     - false     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_not_between()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"small_table dataset package column numeric values c (NAs column). following examples validate values numeric column.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"Validate values column c 10 20. NA values, choose let pass validation setting na_pass = TRUE. determine validation failing test units (13 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = small_table) %>%   col_vals_not_between(     columns = c,     left = 10, right = 20,     na_pass = TRUE   ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"small_table %>%   col_vals_not_between(     columns = c,     left = 10, right = 20,     na_pass = TRUE   ) %>%   dplyr::pull(c) #>  [1]  3  8  3 NA  7  4  3  2  9  9  7  8 NA"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_not_between(   small_table, columns = c,   left = 10, right = 20,   na_pass = TRUE )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"test_*() form, get single logical value returned us.   additional note bounds function: inclusive default. can modify inclusiveness upper lower bounds inclusive option, length-2 logical vector. changing lower bound 9 making non-inclusive, get TRUE since although two values 9 fall outside lower (left) bound (values '' count passing test units).","code":"small_table %>%   test_col_vals_not_between(     columns = c,     left = 10, right = 20,     na_pass = TRUE   ) #> [1] TRUE small_table %>%   test_col_vals_not_between(     columns = c,     left = 9, right = 20,     inclusive = c(FALSE, TRUE),     na_pass = TRUE   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_between.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do column data lie outside of two specified values or data in other columns? — col_vals_not_between","text":"2-8","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"col_vals_not_equal() validation function, expect_col_vals_not_equal() expectation function, test_col_vals_not_equal() test function check whether column values table equal specified value. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"","code":"col_vals_not_equal(   x,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_not_equal(   object,   columns,   value,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. value Value comparison <value expression> // required value used test inequality. can single value compatible column given vars(). column values equal specified pass validation. na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_not_equal() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_not_equal() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns value arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_not_equal(     columns = a,     value = 1,     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_not_equal()` step.\",     active = FALSE   ) steps: - col_vals_not_equal:     columns: c(a)     value: 1.0     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_not_equal()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"examples , use simple table three numeric columns (, b, c) three character columns (d, e, f).","code":"tbl <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 2, 2),     d = LETTERS[c(1:3, 5:7)],     e = LETTERS[c(1:6)],     f = LETTERS[c(1:6)]   )  tbl #> # A tibble: 6 x 6 #>       a     b     c d     e     f #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 A     A     A #> 2     5     1     1 B     B     B #> 3     5     1     1 C     C     C #> 4     5     2     2 E     D     D #> 5     5     2     2 F     E     E #> 6     5     2     2 G     F     F"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"Validate values column equal value 6. determine validation failing test units (6 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_vals_not_equal(columns = a, value = 6) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   col_vals_not_equal(columns = a, value = 6) %>%   dplyr::pull(a) #> [1] 5 5 5 5 5 5"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_not_equal(tbl, columns = a, value = 6)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"test_*() form, get single logical value returned us.","code":"test_col_vals_not_equal(tbl, columns = a, value = 6) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_equal.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data not equal to a fixed value or data in another column? — col_vals_not_equal","text":"2-4","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Are data not part of a specified set of values? — col_vals_not_in_set","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"col_vals_not_in_set() validation function, expect_col_vals_not_in_set() expectation function, test_col_vals_not_in_set() test function check whether column values table part specified set values. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"","code":"col_vals_not_in_set(   x,   columns,   set,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_in_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )  test_col_vals_not_in_set(   object,   columns,   set,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. set Set values vector<integer|numeric|character> // required vector numeric string-based elements, column values found within set considered failing. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_not_in_set() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_not_in_set() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns set arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_not_in_set(     columns = a,     set = c(1, 2, 3, 4),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_not_in_set()` step.\",     active = FALSE   ) steps: - col_vals_not_in_set:    columns: c(a)    set:    - 1.0    - 2.0    - 3.0    - 4.0    preconditions: ~. %>% dplyr::filter(a < 10)    segments: b ~ c(\"group_1\", \"group_2\")    actions:      warn_fraction: 0.1      stop_fraction: 0.2    label: The `col_vals_not_in_set()` step.    active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"small_table dataset package used validate column values part given set.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"Validate values column f contain none values lows, mids, highs. determine validation failing test units (13 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = small_table) %>%   col_vals_not_in_set(     columns = f, set = c(\"lows\", \"mids\", \"highs\")   ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"small_table %>%   col_vals_not_in_set(     columns = f, set = c(\"lows\", \"mids\", \"highs\")   ) %>%   dplyr::pull(f) %>%   unique()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_not_in_set(   small_table,   columns = f, set = c(\"lows\", \"mids\", \"highs\") )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"test_*() form, get single logical value returned us.","code":"small_table %>%   test_col_vals_not_in_set(     columns = f, set = c(\"lows\", \"mids\", \"highs\")   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_in_set.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are data not part of a specified set of values? — col_vals_not_in_set","text":"2-10","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data not NULL/NA? — col_vals_not_null","title":"Are column data not NULL/NA? — col_vals_not_null","text":"col_vals_not_null() validation function, expect_col_vals_not_null() expectation function, test_col_vals_not_null() test function check whether column values table NA values , database context, NULL values. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data not NULL/NA? — col_vals_not_null","text":"","code":"col_vals_not_null(   x,   columns,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_not_null(object, columns, preconditions = NULL, threshold = 1)  test_col_vals_not_null(object, columns, preconditions = NULL, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data not NULL/NA? — col_vals_not_null","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data not NULL/NA? — col_vals_not_null","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are column data not NULL/NA? — col_vals_not_null","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data not NULL/NA? — col_vals_not_null","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data not NULL/NA? — col_vals_not_null","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data not NULL/NA? — col_vals_not_null","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data not NULL/NA? — col_vals_not_null","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are column data not NULL/NA? — col_vals_not_null","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data not NULL/NA? — col_vals_not_null","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data not NULL/NA? — col_vals_not_null","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_not_null() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_not_null() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_not_null(     columns = a,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_not_null()` step.\",     active = FALSE   ) steps: - col_vals_not_null:     columns: c(a)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_not_null()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data not NULL/NA? — col_vals_not_null","text":"examples , use simple table four columns: , b, c, d.","code":"tbl <-   dplyr::tibble(     a = c( 5,  7,  6,  5,  8),     b = c( 7,  1,  0,  0,  0),     c = c(NA, NA, NA, NA, NA),     d = c(35, 23, NA, NA, NA)   )  tbl #> # A tibble: 5 x 4 #>       a     b c         d #>   <dbl> <dbl> <lgl> <dbl> #> 1     5     7 NA       35 #> 2     7     1 NA       23 #> 3     6     0 NA       NA #> 4     5     0 NA       NA #> 5     8     0 NA       NA"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are column data not NULL/NA? — col_vals_not_null","text":"Validate values column b NA (non-NULL database context, case ). determine validation failing test units (5 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_vals_not_null(columns = b) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are column data not NULL/NA? — col_vals_not_null","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   col_vals_not_null(columns = b) %>%   dplyr::pull(b) #> [1] 7 1 0 0 0"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are column data not NULL/NA? — col_vals_not_null","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_not_null(tbl, columns = b)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are column data not NULL/NA? — col_vals_not_null","text":"test_*() form, get single logical value returned us.","code":"tbl %>% test_col_vals_not_null(columns = b) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_not_null.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data not NULL/NA? — col_vals_not_null","text":"2-16","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":null,"dir":"Reference","previous_headings":"","what":"Are column data NULL/NA? — col_vals_null","title":"Are column data NULL/NA? — col_vals_null","text":"col_vals_null() validation function, expect_col_vals_null() expectation function, test_col_vals_null() test function check whether column values table NA values , database context, NULL values. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are column data NULL/NA? — col_vals_null","text":"","code":"col_vals_null(   x,   columns,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_null(object, columns, preconditions = NULL, threshold = 1)  test_col_vals_null(object, columns, preconditions = NULL, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are column data NULL/NA? — col_vals_null","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are column data NULL/NA? — col_vals_null","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are column data NULL/NA? — col_vals_null","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Are column data NULL/NA? — col_vals_null","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are column data NULL/NA? — col_vals_null","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are column data NULL/NA? — col_vals_null","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are column data NULL/NA? — col_vals_null","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are column data NULL/NA? — col_vals_null","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are column data NULL/NA? — col_vals_null","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are column data NULL/NA? — col_vals_null","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_null() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_null() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns argument requires value. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_null(     columns = a,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_null()` step.\",     active = FALSE   ) steps: - col_vals_null:     columns: c(a)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_null()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are column data NULL/NA? — col_vals_null","text":"examples , use simple table four columns: , b, c, d.","code":"tbl <-   dplyr::tibble(     a = c( 5,  7,  6,  5,  8),     b = c( 7,  1,  0,  0,  0),     c = c(NA, NA, NA, NA, NA),     d = c(35, 23, NA, NA, NA)   )  tbl #> # A tibble: 5 x 4 #>       a     b c         d #>   <dbl> <dbl> <lgl> <dbl> #> 1     5     7 NA       35 #> 2     7     1 NA       23 #> 3     6     0 NA       NA #> 4     5     0 NA       NA #> 5     8     0 NA       NA"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are column data NULL/NA? — col_vals_null","text":"Validate values column c NA (NULL database context, case ). determine validation failing test units (5 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   col_vals_null(columns = c) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are column data NULL/NA? — col_vals_null","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   col_vals_null(columns = c) %>%   dplyr::pull(c) #> [1] NA NA NA NA NA"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are column data NULL/NA? — col_vals_null","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_null(tbl, columns = c)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are column data NULL/NA? — col_vals_null","text":"test_*() form, get single logical value returned us.","code":"tbl %>% test_col_vals_null(columns = c) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_null.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are column data NULL/NA? — col_vals_null","text":"2-15","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":null,"dir":"Reference","previous_headings":"","what":"Do strings in column data match a regex pattern? — col_vals_regex","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"col_vals_regex() validation function, expect_col_vals_regex() expectation function, test_col_vals_regex() test function check whether column values table correspond regex matching expression. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"","code":"col_vals_regex(   x,   columns,   regex,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_regex(   object,   columns,   regex,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_regex(   object,   columns,   regex,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. regex Regex pattern scalar<character> // required regular expression pattern test match target column. regex matches values target columns pass validation. na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_regex() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_regex() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns regex arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_regex(     columns = a,     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_regex()` step.\",     active = FALSE   ) steps: - col_vals_regex:     columns: c(a)     regex: '[0-9]-[a-z]{3}-[0-9]{3}'     na_pass: true     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_regex()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"small_table dataset package character-based b column values adhere particular pattern. following examples validate column abides regex pattern.   regex pattern used throughout:","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high pattern <- \"[0-9]-[a-z]{3}-[0-9]{3}\""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"Validate values column b match regex pattern. determine validation failing test units (13 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = small_table) %>%   col_vals_regex(columns = b, regex = pattern) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"small_table %>%   col_vals_regex(columns = b, regex = pattern) %>%   dplyr::slice(1:5) #> # A tibble: 5 x 8 #>   date_time           date           a b             c      d e     f #>   <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #> 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #> 2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #> 3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #> 4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #> 5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_regex(small_table, columns = b, regex = pattern)"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"test_*() form, get single logical value returned us.","code":"small_table %>% test_col_vals_regex(columns = b, regex = pattern) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_regex.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do strings in column data match a regex pattern? — col_vals_regex","text":"2-17","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Do values in column data fit within a specification? — col_vals_within_spec","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"col_vals_within_spec() validation function, expect_col_vals_within_spec() expectation function, test_col_vals_within_spec() test function check whether column values table correspond specification (spec) type (details available Specifications section). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"","code":"col_vals_within_spec(   x,   columns,   spec,   na_pass = FALSE,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_col_vals_within_spec(   object,   columns,   spec,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )  test_col_vals_within_spec(   object,   columns,   spec,   na_pass = FALSE,   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // required column-selecting expression, one use inside dplyr::select(). Specifies column (set columns) validation applied. See Column Names section information. spec Specification type scalar<character> // required specification string defining specification type. Examples \"email\", \"url\", \"postal[USA]\". options explained Specifications section. na_pass Allow missing values pass validation scalar<logical> // default: FALSE encountered NA values considered passing test units? default, FALSE. Set TRUE give NAs pass. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"specifications","dir":"Reference","previous_headings":"","what":"Specifications","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"specification type must used spec argument. character-based keyword corresponds type data specified columns. following keywords can used: \"isbn\": International Standard Book Number (ISBN) unique numerical identifier books, pamphletes, educational kits, microforms, digital/electronic publications. specification formalized ISO 2108. keyword can used validate 10- 13-digit ISBNs. \"VIN\": vehicle identification number (VIN) unique code (includes serial number) used automotive industry identify individual motor vehicles, motorcycles, scooters, mopeds stipulated ISO 3779 ISO 4030. \"postal_code[<country_code>]\": postal code (also known postcodes, PIN, ZIP codes, depending region) series letters, digits, (sometimes including spaces/punctuation) included postal address aid sorting mail. coding varies country, country code either 2- (ISO 3166-1 alpha-2) 3-letter (ISO 3166-1 alpha-3) formats needs supplied along keywords (e.g., postal codes Germany, \"postal_code[DE]\" \"postal_code[DEU]\" can used). keyword alias \"zip\" can used US ZIP codes. \"credit_card\": credit card number can validated check works across large variety credit type issuers (card numbers allocated accordance ISO/IEC 7812). Numbers can various lengths (typically, 14-19 digits) key validation performed usage Luhn algorithm. \"iban[<country_code>]\": International Bank Account Number (IBAN) system identifying bank accounts across different countries purpose improving cross-border transactions. IBAN values validated conversion integer values performing basic mod-97 operation (described ISO 7064) . length coding varies country, country code either 2- (ISO 3166-1 alpha-2) 3-letter (ISO 3166-1 alpha-3) formats needs supplied along keywords (e.g., IBANs Germany, \"iban[DE]\" \"iban[DEU]\" can used). \"swift\": Business Identifier Codes (also known SWIFT-BIC, BIC, SWIFT code) defined standard format described ISO 9362. codes unique identifiers financial non-financial institutions. SWIFT stands Society Worldwide Interbank Financial Telecommunication. numbers used transferring money banks, especially important international wire transfers. \"phone\", \"email\", \"url\", \"ipv4\", \"ipv6\", \"mac\": Phone numbers, email addresses, Internet URLs, IPv4 IPv6 addresses, MAC addresses can validated respective keywords. validations use regex-based matching determine validity. single spec value provided per function call.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing Values","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"validation function supports special handling NA values. na_pass argument determine whether NA value appearing test unit counted pass fail. default na_pass = FALSE means NAs encountered accumulate failing test units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). col_vals_within_spec() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call col_vals_within_spec() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter columns spec arguments require values. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   col_vals_within_spec(     columns = a,     spec = \"email\",     na_pass = TRUE,     preconditions = ~ . %>% dplyr::filter(b < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `col_vals_within_spec()` step.\",     active = FALSE   ) steps: - col_vals_within_spec:     columns: c(a)     spec: email     na_pass: true     preconditions: ~. %>% dplyr::filter(b < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `col_vals_within_spec()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"specifications dataset package columns character data correspond specifications can tested. following examples validate email_addresses column 5 correct values (true get subset data: first five rows).","code":"spec_slice <- specifications[1:5, ]  spec_slice #> # A tibble: 5 x 12 #>   isbn_numbers      vin_numbers       zip_codes credit_card_numbers iban_austria #>   <chr>             <chr>             <chr>     <chr>               <chr> #> 1 978 1 85715 201 2 4UZAANDH85CV12329 99553     340000000000009     AT582774098~ #> 2 978-1-84159-362-3 JM1BL1S59A1134659 36264     378734493671000     AT220332087~ #> 3 978 1 84159 329 6 1GCEK14R3WZ274764 71660     6703444444444449    AT328650112~ #> 4 978 1 85715 202 9 2B7JB21Y0XK524370 85225     6703000000000000003 AT193357281~ #> 5 978 1 85715 198 5 4UZAANDH85CV12329 90309     4035501000000008    AT535755326~ #> # i 7 more variables: swift_numbers <chr>, phone_numbers <chr>, #> #   email_addresses <chr>, urls <chr>, ipv4_addresses <chr>, #> #   ipv6_addresses <chr>, mac_addresses <chr>"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"Validate values column email_addresses correct. determine validation failing test units (5 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = spec_slice) %>%   col_vals_within_spec(     columns = email_addresses,     spec = \"email\"   ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"spec_slice %>%   col_vals_within_spec(     columns = email_addresses,     spec = \"email\"   ) %>%   dplyr::select(email_addresses) #> # A tibble: 5 x 1 #>   email_addresses #>   <chr> #> 1 test@test.com #> 2 mail+mail@example.com #> 3 mail.email@e.test.com #> 4 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@letters-in-local.org #> 5 01234567890@numbers-in-local.net"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_col_vals_within_spec(   spec_slice,   columns = email_addresses,   spec = \"email\" )"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"test_*() form, get single logical value returned us.","code":"spec_slice %>%   test_col_vals_within_spec(     columns = email_addresses,     spec = \"email\"   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/col_vals_within_spec.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Do values in column data fit within a specification? — col_vals_within_spec","text":"2-18","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform multiple rowwise validations for joint validity — conjointly","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"conjointly() validation function, expect_conjointly() expectation function, test_conjointly() test function check whether test units index (typically row) pass multiple validations. can use validation functions validate row units (col_vals_*() series), check column existence (col_exists()), validate column type (col_is_*() series). imposed constraint allowed validation functions, ensemble test units either comprised rows table (common preconditions applied) single test units (functions validate columns). functions used conjointly() validation step (composed using multiple validation function calls) ultimately perform rowwise test whether sub-validations reported pass test units. practice, example joint validation testing whether values column greater specific value adjacent values column b lie within specified range. validation functions part conjoint validation supplied one-sided R formulas (using leading ~, . stand data object). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"","code":"conjointly(   x,   ...,   .list = list2(...),   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_conjointly(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )  test_conjointly(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). ... Validation expressions <validation expressions> // required (, use .list) collection one-sided formulas consist validation functions validate row units (col_vals_*() series), column existence (col_exists()), column type (col_is_*() series). example ~ col_vals_gte(., , 5.5), ~ col_vals_not_null(., b). .list Alternative ... <list multiple expressions> // required (, use ...) Allows use list input alternative .... preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. multiple columns specified potential number validation steps m columns multiplied n segments resolved. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). conjointly() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call conjointly() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter expressions validation steps necessary. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   conjointly(     ~ col_vals_lt(., columns = a, value = 8),     ~ col_vals_gt(., columns = c, value = vars(a)),     ~ col_vals_not_null(., columns = b),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `conjointly()` step.\",     active = FALSE   ) steps: - conjointly:     fns:     - ~col_vals_lt(., columns = a, value = 8)     - ~col_vals_gt(., columns = c, value = vars(a))     - ~col_vals_not_null(., columns = b)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `conjointly()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"examples , use simple table three numeric columns (, b, c). basic table 'll useful explaining things later.","code":"tbl <-   dplyr::tibble(     a = c(5, 2, 6),     b = c(3, 4, 6),     c = c(9, 8, 7)   )  tbl #> # A tibble: 3 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     3     9 #> 2     2     4     8 #> 3     6     6     7"},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"Validate number things row--row basis using validation functions col_vals* type (number test units): (1) values less 8, (2) values c greater adjacent values , (3) NA values b. determine validation failing test units (3 test units, one row).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .  going ? Think three parallel validations, producing column TRUE FALSE values (pass fail) line side--side, rows FALSE values results conjoint fail test unit.","code":"agent <-   create_agent(tbl = tbl) %>%   conjointly(     ~ col_vals_lt(., columns = a, value = 8),     ~ col_vals_gt(., columns = c, value = vars(a)),     ~ col_vals_not_null(., columns = b)     ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   conjointly(     ~ col_vals_lt(., columns = a, value = 8),     ~ col_vals_gt(., columns = c, value = vars(a)),     ~ col_vals_not_null(., columns = b)   ) #> # A tibble: 3 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     3     9 #> 2     2     4     8 #> 3     6     6     7"},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_conjointly(   tbl,   ~ col_vals_lt(., columns = a, value = 8),   ~ col_vals_gt(., columns = c, value = vars(a)),   ~ col_vals_not_null(., columns = b) )"},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"test_*() form, get single logical value returned us.","code":"tbl %>%   test_conjointly(     ~ col_vals_lt(., columns = a, value = 8),     ~ col_vals_gt(., columns = c, value = vars(a)),     ~ col_vals_not_null(., columns = b)   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/conjointly.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Perform multiple rowwise validations for joint validity — conjointly","text":"2-34","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a pointblank agent object — create_agent","title":"Create a pointblank agent object — create_agent","text":"create_agent() function creates agent object, used data quality reporting workflow. overall aim workflow generate useful reporting information assessing level data quality target table. can supply many validation functions user wishes write, thereby increasing level validation coverage table. agent assigned create_agent() call takes validation functions (e.g., col_vals_between(), rows_distinct(), etc.), translate discrete validation steps (one numbered later provide set results). process known developing validation plan. validation functions, called agent, merely instructions point interrogate() function called. kicks process agent acting validation plan getting results step. interrogation process complete, can say agent intel. Calling agent result reporting table. reporting interrogation can also accessed get_agent_report() function, reporting options.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a pointblank agent object — create_agent","text":"","code":"create_agent(   tbl = NULL,   tbl_name = NULL,   label = NULL,   actions = NULL,   end_fns = NULL,   embed_report = FALSE,   lang = NULL,   locale = NULL,   read_fn = NULL )"},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a pointblank agent object — create_agent","text":"tbl Table expression reading one obj:<tbl_*>|<tbl reading expression> // required input table. can data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, expression can supplied serve instructions retrieve target table interrogation-time. two ways specify association target table: (1) table-prep formula, right-hand side (RHS) formula expression (e.g., ~ { <tbl reading code>}), (2) function (e.g., function() { <tbl reading code>}). tbl_name table name scalar<character> // default: NULL (optional) optional name assign input table object. value provided, name generated based whatever information available. table name displayed header area agent report generated printing agent calling get_agent_report(). label optional label validation plan scalar<character> // default: NULL (optional) optional label validation plan. value provided, label generated based current system time. Markdown can used make label visually appealing (appear header area agent report). actions Default thresholds actions different states obj:<action_levels> // default: NULL (optional) option include list threshold levels validation steps can react accordingly exceeding set levels. created action_levels() helper function. action levels list used specific validation step, default set specified overridden. end_fns Functions execute interrogation list // default: NULL (optional) list expressions invoked end interrogation. expression form one-sided R formula, overall construction used: end_fns = list(~ <R statements>, ~ <R statements>, ...). example function included pointblank can sensibly used email_blast(), sends email validation report (based sending condition). embed_report Embed validation report agent object? scalar<logical> // default: FALSE option embed gt-based validation report ptblank_agent object. FALSE table object generated available agent upon returning interrogation. lang Reporting language scalar<character> // default: NULL (optional) language use automatic creation briefs (short descriptions validation step) agent report (summary table provides validation plan results interrogation. default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). locale Locale value formatting within reports scalar<character> // default: NULL (optional) optional locale ID use formatting values agent report summary table according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). read_fn Deprecated Table reading function function // default: NULL (optional) read_fn argument deprecated. Instead, supply table-prep formula function tbl.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a pointblank agent object — create_agent","text":"ptblank_agent object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Create a pointblank agent object — create_agent","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"the-use-of-an-agent-for-validation-is-just-one-option-of-several","dir":"Reference","previous_headings":"","what":"The Use of an Agent for Validation Is Just One Option of Several","title":"Create a pointblank agent object — create_agent","text":"validation workflows using agent one provides options. probably best choice assessing state data quality since yields detailed reporting, options exploration root causes, allows granular definition actions taken based severity validation failures (e.g., emailing, logging, etc.). Different situations, however, call different validation workflows. use validation functions (ones agent) directly data. acts sort data filter input table become output data (without modification), may warnings, errors, side effects can define validation fails. Basically, instead   use :   results error (default failure threshold settings), displaying reason error console. Notably, data passed though. can use variants validation functions, test (test_*()) expectation (expect_*()) versions, directly data different workflows. first returns us logical value.   returns FALSE instead error. unit testing scenario, can use expectation functions exactly testthat's library expect_*() functions:   test small_table counted failure.","code":"create_agent(tbl = small_table) %>% rows_distinct() %>% interrogate() small_table %>% rows_distinct() small_table %>% test_rows_distinct() small_table %>% expect_rows_distinct()"},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"the-agent-report","dir":"Reference","previous_headings":"","what":"The Agent Report","title":"Create a pointblank agent object — create_agent","text":"printing agent (ptblank_agent object) display reporting Viewer, can alternatively use get_agent_report() take advantage options (e.g., overriding language, modifying arrangement report rows, etc.), return report independent objects. example, display_table = TRUE option (default), get_agent_report() return ptblank_agent_report object. display_table set FALSE, get data frame back instead. Exporting report standalone HTML file can accomplished using export_report() function. function can accept either ptblank_agent object ptblank_agent_report input. HTML document written disk way self-contained easily viewable web browser.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"data-products-obtained-from-an-agent","dir":"Reference","previous_headings":"","what":"Data Products Obtained from an Agent","title":"Create a pointblank agent object — create_agent","text":"detailed list object, known x-list, can obtained using get_agent_x_list() function agent. font information can taken whole, , broken step number (argument). Sometimes useful see rows failing ones. using get_data_extracts() function agent, either get list tibbles (steps data extracts) one tibble validation step specified argument. target data can split pieces represent 'pass' 'fail' portions get_sundered_data() function. primary requirement agent interrogate() called . addition, validation steps considered data splitting need operate values column (e.g., col_vals_*() functions conjointly()). -consideration validation steps, rows failing test units across validation steps comprise 'pass' data piece, rows least one failing test unit across series validations constitute 'fail' piece. just need know whether validations completely passed (.e., steps failing test units), all_passed() function used agent. However, practice, often case data validation steps free failing units.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Create a pointblank agent object — create_agent","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). example complex call create_agent() expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, YAML file shorter since arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). requirement writing YAML representation agent tbl specified table-prep formula. typically follows chunk YAML steps part, corresponds addition validation steps via validation functions. Help articles validation function YAML section describes given validation function translated YAML. need preview transformation agent YAML (without committing anything disk), use yaml_agent_string() function. already .yml file holds agent, can get glimpse R expressions used regenerate agent yaml_agent_show_exprs().","code":"create_agent(   tbl = ~ small_table,   tbl_name = \"small_table\",   label = \"An example.\",   actions = action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35,     fns = list(notify = ~ email_blast(       x,       to = \"joe_public@example.com\",       from = \"pb_notif@example.com\",       msg_subject = \"Table Validation\",       credentials = blastula::creds_key(         id = \"smtp2go\"       )     ))   ),   end_fns = list(     ~ beepr::beep(2),     ~ Sys.sleep(1)   ),   embed_report = TRUE,   lang = \"fr\",   locale = \"fr_CA\" ) type: agent tbl: ~small_table tbl_name: small_table label: An example. lang: fr locale: fr_CA actions:   warn_fraction: 0.1   stop_fraction: 0.25   notify_fraction: 0.35   fns:     notify: ~email_blast(x, to = \"joe_public@example.com\",       from = \"pb_notif@example.com\",       msg_subject = \"Table Validation\",       credentials = blastula::creds_key(id = \"smtp2go\")) end_fns: - ~beepr::beep(2) - ~Sys.sleep(1) embed_report: true steps: []"},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"writing-an-agent-to-disk","dir":"Reference","previous_headings":"","what":"Writing an Agent to Disk","title":"Create a pointblank agent object — create_agent","text":"agent object can written disk x_write_disk() function. can useful keeping history validations generating views data quality time. Agents stored serialized RDS format can easily retrieved x_read_disk() function. recommended table-prep formulas supplied tbl argument create_agent(). way, agent read disk x_read_disk(), can reused access target table (may change, hence need use expression ).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"combining-several-agents-in-a-multiagent-object","dir":"Reference","previous_headings":"","what":"Combining Several Agents in a multiagent Object","title":"Create a pointblank agent object — create_agent","text":"Multiple agent objects can part multiagent object, two functions can used : create_multiagent() read_disk_multiagent(). gathering multiple agents performed interrogations past, can get multiagent report showing data quality evolved time. use case interesting data quality monitoring management, , reporting (can customized get_multiagent_report()) robust changes validation steps given target table.","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"creating-an-agent-adding-a-validation-plan-and-interrogating","dir":"Reference","previous_headings":"","what":"Creating an agent, adding a validation plan, and interrogating","title":"Create a pointblank agent object — create_agent","text":"walk data quality analysis extremely small table. actually called small_table can find dataset package.   think tolerable terms data quality designate proportional failure thresholds warn, stop, notify states using action_levels().   Now create pointblank agent object give al object (serves default validation steps can overridden). static thresholds provided al make reporting bit useful. also provide target table use pointblank::small_table.   , agent object, can add steps validation plan using many validation functions want. , use interrogate() actually perform validations gather intel.   agent object can printed see validation report Viewer.    want make use report display options, can alternatively use get_agent_report() function.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high al <-   action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   ) agent <-   create_agent(     tbl = pointblank::small_table,     tbl_name = \"small_table\",     label = \"`create_agent()` example.\",     actions = al   ) agent <-   agent %>%   col_exists(columns = c(date, date_time)) %>%   col_vals_regex(     columns = b,     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(columns = d, value = 100) %>%   col_vals_lte(columns = c, value = 5) %>%   col_vals_between(     columns = c,     left = vars(a), right = vars(d),     na_pass = TRUE   ) %>%   interrogate() agent report <-   get_agent_report(     agent = agent,     arrange_by = \"severity\",     title = \"Validation of `small_table`\"   )  report"},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"post-interrogation-operations","dir":"Reference","previous_headings":"","what":"Post-interrogation operations","title":"Create a pointblank agent object — create_agent","text":"can use agent object variety functions get information collected interrogation. can see validation report Step 4 (used rows_distinct() validation function) two test units, corresponding duplicated rows, failed. can see rows get_data_extracts().   can get x-list entire validation process (7 steps), , just 4th step get_agent_x_list().   can peruse different parts list. get fraction test units failed.     x-list specific step way information slightly different structure. See help(get_agent_x_list) info.","code":"agent %>% get_data_extracts(i = 4) ## # A tibble: 2 × 8 ##   date_time           date           a b            c     d e     f ##   <dttm>              <date>     <int> <chr>    <dbl> <dbl> <lgl> <chr> ## 1 2016-01-20 04:30:00 2016-01-20     3 5-bce-6…     9  838. FALSE high ## 2 2016-01-20 04:30:00 2016-01-20     3 5-bce-6…     9  838. FALSE high xl_step_4 <- agent %>% get_agent_x_list(i = 4) xl_step_4$f_failed #> [1] 0.15385"},{"path":"https://rstudio.github.io/pointblank/reference/create_agent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Create a pointblank agent object — create_agent","text":"1-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/create_informant.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a pointblank informant object — create_informant","title":"Create a pointblank informant object — create_informant","text":"create_informant() function creates informant object, used information management workflow. overall aim workflow record, collect, generate useful information data tables. can supply information useful describing particular data table. informant object created create_informant() function takes information-focused functions: info_columns(), info_tabular(), info_section(), info_snippet(). info_*() series functions allows progressive build information target table. info_columns() info_tabular() functions facilitate entry info text concerns table columns table proper; info_section() function allows creation arbitrary sections can multiple subsections full additional info text. system allows dynamic values culled target table way info_snippet(), getting named text extracts queries, use {<snippet_name>} info text. make use info_snippet() convenient common queries, set snip_*() functions provided package (snip_list(), snip_stats(), snip_lowest(), snip_highest()) though free use expressions. snippets need query target table return fragments info text, incorporate() function needs used initiate action. also necessary informant update metadata elements row column counts. incorporation process complete, snippets metadata updated. Calling informant result reporting table. reporting can also accessed get_informant_report() function, reporting options.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_informant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a pointblank informant object — create_informant","text":"","code":"create_informant(   tbl = NULL,   tbl_name = NULL,   label = NULL,   agent = NULL,   lang = NULL,   locale = NULL,   read_fn = NULL )"},{"path":"https://rstudio.github.io/pointblank/reference/create_informant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a pointblank informant object — create_informant","text":"tbl Table expression reading one obj:<tbl_*>|<tbl reading expression> // required input table. can data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, expression can supplied serve instructions retrieve target table incorporation-time. two ways specify association target table: (1) table-prep formula, right-hand side (RHS) formula expression (e.g., ~ { <tbl reading code>}), (2) function (e.g., function() { <tbl reading code>}). tbl_name table name scalar<character> // default: NULL (optional) optional name assign input table object. value provided, name generated based whatever information available. label optional label information report scalar<character> // default: NULL (optional) optional label information report. value provided, label generated based current system time. Markdown can used make label visually appealing (appear header area information report). agent pointblank agent object obj:<ptblank_agent> // default: NULL (optional) pointblank agent object. table object can extracted used new informant instead supplying table tbl. lang Reporting language scalar<character> // default: NULL (optional) language use information report (summary table provides available information table. default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). locale Locale value formatting within reports scalar<character> // default: NULL (optional) optional locale ID use formatting values information report according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). read_fn Deprecated Table reading function function // default: NULL (optional) read_fn argument deprecated. Instead, supply table-prep formula function tbl.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_informant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a pointblank informant object — create_informant","text":"ptblank_informant object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_informant.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Create a pointblank informant object — create_informant","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_informant.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Create a pointblank informant object — create_informant","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). example complex call create_informant() expressed R code corresponding YAML representation. R statement:   YAML representation:   generated YAML includes top-level keys type tbl mandatory, , two metadata sections: table columns. Keys begin underscore character updated whenever incorporate() called informant. table metadata section can multiple subsections info text. columns metadata section can similarly multiple subsections, long children column keys (YAML example, date_time date column keys match table's column names). Additional sections can added must key names top level duplicate default set (.e., type, table, columns, etc. treated reserved keys).","code":"create_informant(   tbl = ~ small_table,   tbl_name = \"small_table\",   label = \"An example.\",   lang = \"fr\",   locale = \"fr_CA\" ) type: informant tbl: ~small_table tbl_name: small_table info_label: An example. lang: fr locale: fr_CA table:   name: small_table   _columns: 8   _rows: 13.0   _type: tbl_df columns:   date_time:     _type: POSIXct, POSIXt   date:     _type: Date   a:     _type: integer   b:     _type: character   c:     _type: numeric   d:     _type: numeric   e:     _type: logical   f:     _type: character"},{"path":"https://rstudio.github.io/pointblank/reference/create_informant.html","id":"writing-an-informant-to-disk","dir":"Reference","previous_headings":"","what":"Writing an Informant to Disk","title":"Create a pointblank informant object — create_informant","text":"informant object can written disk x_write_disk() function. Informants stored serialized RDS format can easily retrieved x_read_disk() function. recommended table-prep formulas supplied tbl argument create_informant(). way, informant read disk x_read_disk(), can reused access target table (may changed, hence need use expression ).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_informant.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a pointblank informant object — create_informant","text":"walk can generate useful information really small table. actually called small_table can find dataset package.   Create pointblank informant object create_informant() small_table dataset.   function creates information without extra help profiling supplied table object. adds COLUMNS section stubs target table's columns. can use info_columns() info_columns_from_tbl() provide descriptions columns. informant object can printed see information report Viewer.    want make use report display options, can alternatively use get_informant_report() function.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high informant <-   create_informant(     tbl = pointblank::small_table,     tbl_name = \"small_table\",     label = \"`create_informant()` example.\"   ) informant report <-   get_informant_report(     informant,     title = \"Data Dictionary for `small_table`\"   )  report"},{"path":"https://rstudio.github.io/pointblank/reference/create_informant.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Create a pointblank informant object — create_informant","text":"1-3","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/create_multiagent.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a pointblank multiagent object — create_multiagent","title":"Create a pointblank multiagent object — create_multiagent","text":"Multiple agents can part single object called multiagent. can useful gathering multiple agents performed interrogations past (perhaps saved disk x_write_disk()). part multiagent, can get report shows data quality evolved time. can interest important monitor data quality even evolution validation plan . reporting table, generated printing ptblank_multiagent object using get_multiagent_report() function, , default, organized interrogation time automatically recognizes validation steps equivalent across interrogations.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_multiagent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a pointblank multiagent object — create_multiagent","text":"","code":"create_multiagent(..., lang = NULL, locale = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/create_multiagent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a pointblank multiagent object — create_multiagent","text":"... Pointblank agents <series obj:<ptblank_agent>> // required One pointblank agent objects. lang Reporting language scalar<character> // default: NULL (optional) language use reporting generated multiagent. (e.g., individual agent reports, multiagent reports, etc.). default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). locale Locale value formatting within reports scalar<character> // default: NULL (optional) optional locale ID use formatting values reporting outputs according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\").","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_multiagent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a pointblank multiagent object — create_multiagent","text":"ptblank_multiagent object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/create_multiagent.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a pointblank multiagent object — create_multiagent","text":"example , use two different, yet simple tables. First, tbl_1:   next, tbl_2:   Next, create two different agents, interrogating different table. First , agent_1:   , agent_2:   Now, combine two agents multiagent create_multiagent() function. Printing \"ptblank_multiagent\" object displays multiagent report default options (.e., 'long' report view).    take advantage display options, use get_multiagent_report() function. added functionality allows 'wide' view data (useful monitoring validations table repeated interrogations), ability modify title multiagent report, means export report HTML (via export_report()).","code":"tbl_1 <-   dplyr::tibble(     a = c(5, 5, 5, 5, 5, 5),     b = c(1, 1, 1, 2, 2, 2),     c = c(1, 1, 1, 2, 3, 4),     d = LETTERS[a],     e = LETTERS[b],     f = LETTERS[c]   )  tbl_1 #> # A tibble: 6 x 6 #>       a     b     c d     e     f #>   <dbl> <dbl> <dbl> <chr> <chr> <chr> #> 1     5     1     1 E     A     A #> 2     5     1     1 E     A     A #> 3     5     1     1 E     A     A #> 4     5     2     2 E     B     B #> 5     5     2     3 E     B     C #> 6     5     2     4 E     B     D tbl_2 <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = LETTERS[1:6]   )  tbl_2 #> # A tibble: 6 x 2 #>       a b #>   <dbl> <chr> #> 1     5 A #> 2     7 B #> 3     6 C #> 4     5 D #> 5     8 E #> 6     7 F agent_1 <-   create_agent(     tbl = tbl_1,     tbl_name = \"tbl_1\",     label = \"Example table 1.\"   ) %>%   col_vals_gt(columns = a, value = 4) %>%   interrogate() agent_2 <-   create_agent(     tbl = tbl_2,     tbl_name = \"tbl_2\",     label = \"Example table 2.\"   ) %>%   col_is_character(columns = b) %>%   interrogate() multiagent <- create_multiagent(agent_1, agent_2)  multiagent"},{"path":"https://rstudio.github.io/pointblank/reference/create_multiagent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Create a pointblank multiagent object — create_multiagent","text":"10-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/db_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a table from a database — db_tbl","title":"Get a table from a database — db_tbl","text":"target table database, db_tbl() function handy way accessing . function simplifies process getting tbl_dbi object, usually involves combination building connection database using dplyr::tbl() function connection table name (reference table schema). can use db_tbl() basis obtaining database table tbl parameter create_agent() create_informant(). Another great option supplying table-prep formula involving db_tbl() tbl_store() access database tables though single names via table store. username password supplied environment variable names. desired, values username password can supplied directly enclosing values ().","code":""},{"path":"https://rstudio.github.io/pointblank/reference/db_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a table from a database — db_tbl","text":"","code":"db_tbl(   table,   dbtype,   dbname = NULL,   host = NULL,   port = NULL,   user = NULL,   password = NULL,   bq_project = NULL,   bq_dataset = NULL,   bq_billing = bq_project )"},{"path":"https://rstudio.github.io/pointblank/reference/db_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a table from a database — db_tbl","text":"table name table, , reference table schema (two-element vector names schema table). Alternatively, can supplied data table copy -memory database connection. works : (1) db chosen either \"sqlite\" \"duckdb\", (2) dbname set \":memory:\", (3) object supplied table data frame tibble object. dbtype Either appropriate driver function (e.g., RPostgres::Postgres()) shortname database type. Valid names : \"postgresql\", \"postgres\", \"pgsql\" (PostgreSQL, using RPostgres::Postgres() driver function); \"mysql\" (MySQL, using RMySQL::MySQL()); bigquery bq (BigQuery, using bigrquery::bigquery()); \"duckdb\" (DuckDB, using duckdb::duckdb()); \"sqlite\" (SQLite, using RSQLite::SQLite()). dbname database name. host, port database host optional port number. user, password environment variables used access username password database. Enclose () using literal username password values. bq_project, bq_dataset, bq_billing accessing table BigQuery data source, requirement provide table's associated project (bq_project) dataset (bq_dataset) names. default, project billed one provided bq_project bq_billing argument can changed reflect different BigQuery project.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/db_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a table from a database — db_tbl","text":"tbl_dbi object.","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/db_tbl.html","id":"obtaining-in-memory-database-tables","dir":"Reference","previous_headings":"","what":"Obtaining in-memory database tables","title":"Get a table from a database — db_tbl","text":"can use -memory database table supplying -memory table. works DuckDB database key thing use dbname = \":memory\" db_tbl() call.   -memory option also works using SQLite database. change required setting dbtype \"sqlite\":   also possible obtain table remote file shove -memory database. , can use -powerful file_tbl() + db_tbl() combo.   really .","code":"small_table_duckdb <-   db_tbl(     table = small_table,     dbtype = \"duckdb\",     dbname = \":memory:\"   )  small_table_duckdb ## # Source:   table<small_table> [?? x 8] ## # Database: duckdb_connection ##    date_time           date           a b         c      d e     f ##    <dttm>              <date>     <int> <chr> <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bc…     3  3423. TRUE  high ##  2 2016-01-04 00:32:00 2016-01-04     3 5-eg…     8 10000. TRUE  low ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kd…     3  2343. TRUE  high ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jd…    NA  3892. FALSE mid ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ld…     7   284. TRUE  low ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dh…     4  3291. TRUE  mid ##  7 2016-01-15 18:46:00 2016-01-15     7 1-kn…     3   843. TRUE  high ##  8 2016-01-17 11:27:00 2016-01-17     4 5-bo…     2  1036. FALSE low ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bc…     9   838. FALSE high ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bc…     9   838. FALSE high ## # … with more rows small_table_sqlite <-   db_tbl(     table = small_table,     dbtype = \"sqlite\",     dbname = \":memory:\"   )  small_table_sqlite ## # Source:   table<small_table> [?? x 8] ## # Database: sqlite 3.37.0 [:memory:] ##     date_time  date     a b             c      d     e f ##         <dbl> <dbl> <int> <chr>     <dbl>  <dbl> <int> <chr> ##  1 1451905200 16804     2 1-bcd-345     3  3423.     1 high ##  2 1451867520 16804     3 5-egh-163     8 10000.     1 low ##  3 1452000720 16805     6 8-kdg-938     3  2343.     1 high ##  4 1452100980 16806     2 5-jdo-903    NA  3892.     0 mid ##  5 1452342960 16809     8 3-ldm-038     7   284.     1 low ##  6 1452492900 16811     4 2-dhe-923     4  3291.     1 mid ##  7 1452883560 16815     7 1-knw-093     3   843.     1 high ##  8 1453030020 16817     4 5-boe-639     2  1036.     0 low ##  9 1453264200 16820     3 5-bce-642     9   838.     0 high ## 10 1453264200 16820     3 5-bce-642     9   838.     0 high ## # … with more rows all_revenue_large_duckdb <-   db_tbl(     table = file_tbl(       file = from_github(         file = \"sj_all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"       )     ),     dbtype = \"duckdb\",     dbname = \":memory:\"   )  all_revenue_large_duckdb ## # Source:   table<sj_all_revenue_large.rds> [?? x 11] ## # Database: duckdb_connection ##    player_id       session_id   session_start       time ##    <chr>           <chr>        <dttm>              <dttm> ##  1 IRZKSAOYUJME796 IRZKSAOYUJM… 2015-01-01 00:18:41 2015-01-01 00:18:53 ##  2 CJVYRASDZTXO674 CJVYRASDZTX… 2015-01-01 01:13:01 2015-01-01 01:13:07 ##  3 CJVYRASDZTXO674 CJVYRASDZTX… 2015-01-01 01:13:01 2015-01-01 01:23:37 ##  4 CJVYRASDZTXO674 CJVYRASDZTX… 2015-01-01 01:13:01 2015-01-01 01:24:37 ##  5 CJVYRASDZTXO674 CJVYRASDZTX… 2015-01-01 01:13:01 2015-01-01 01:31:01 ##  6 CJVYRASDZTXO674 CJVYRASDZTX… 2015-01-01 01:13:01 2015-01-01 01:31:43 ##  7 CJVYRASDZTXO674 CJVYRASDZTX… 2015-01-01 01:13:01 2015-01-01 01:36:01 ##  8 ECPANOIXLZHF896 ECPANOIXLZH… 2015-01-01 01:31:03 2015-01-01 01:31:27 ##  9 ECPANOIXLZHF896 ECPANOIXLZH… 2015-01-01 01:31:03 2015-01-01 01:36:57 ## 10 ECPANOIXLZHF896 ECPANOIXLZH… 2015-01-01 01:31:03 2015-01-01 01:37:45 ## # … with more rows, and 7 more variables: item_type <chr>, ## #   item_name <chr>, item_revenue <dbl>, session_duration <dbl>, ## #   start_day <date>, acquisition <chr>, country <chr>"},{"path":"https://rstudio.github.io/pointblank/reference/db_tbl.html","id":"obtaining-remote-database-tables","dir":"Reference","previous_headings":"","what":"Obtaining remote database tables","title":"Get a table from a database — db_tbl","text":"remote databases, specify quite things one-step process nonetheless. example accesses rna table (RNA Central public database) using db_tbl(). , user password entries using literal username password values (publicly available visiting RNA Central website) enclosing values ().   normally want use names environment variables (envvars) securely access appropriate username password values connecting DB. necessary inputs:   Environment variables can created editing user .Renviron file usethis::edit_r_environ() function makes pretty easy .","code":"rna_db_tbl <-   db_tbl(     table = \"rna\",     dbtype = \"postgres\",     dbname = \"pfmegrnargs\",     host = \"hh-pgsql-public.ebi.ac.uk\",     port = 5432,     user = I(\"reader\"),     password = I(\"NWDMCE5xdipIjRrp\")   )  rna_db_tbl ## # Source:   table<rna> [?? x 9] ## # Database: postgres ## #   [reader@hh-pgsql-public.ebi.ac.uk:5432/pfmegrnargs] ##          id upi    timestamp           userstamp crc64   len seq_short ##     <int64> <chr>  <dttm>              <chr>     <chr> <int> <chr> ##  1 25222431 URS00… 2019-12-02 13:26:46 rnacen    E65C…   521 AGAGTTTG… ##  2 25222432 URS00… 2019-12-02 13:26:46 rnacen    6B91…   520 AGAGTTCG… ##  3 25222433 URS00… 2019-12-02 13:26:46 rnacen    03B8…   257 TACGTAGG… ##  4 25222434 URS00… 2019-12-02 13:26:46 rnacen    E925…   533 AGGGTTTG… ##  5 25222435 URS00… 2019-12-02 13:26:46 rnacen    C2D0…   504 GACGAACG… ##  6 25222436 URS00… 2019-12-02 13:26:46 rnacen    9EF6…   253 TACAGAGG… ##  7 25222437 URS00… 2019-12-02 13:26:46 rnacen    685A…   175 GAGGCAGC… ##  8 25222438 URS00… 2019-12-02 13:26:46 rnacen    4228…   556 AAAACATC… ##  9 25222439 URS00… 2019-12-02 13:26:46 rnacen    B7CC…   515 AGGGTTCG… ## 10 25222440 URS00… 2019-12-02 13:26:46 rnacen    038B…   406 ATTGAACG… ## # … with more rows, and 2 more variables: seq_long <chr>, md5 <chr> example_db_tbl <-   db_tbl(     table = \"<table_name>\",     dbtype = \"<database_type_shortname>\",     dbname = \"<database_name>\",     host = \"<connection_url>\",     port = \"<connection_port>\",     user = \"<DB_USER_NAME>\",     password = \"<DB_PASSWORD>\"   )"},{"path":"https://rstudio.github.io/pointblank/reference/db_tbl.html","id":"db-table-access-and-prep-via-the-table-store","dir":"Reference","previous_headings":"","what":"DB table access and prep via the table store","title":"Get a table from a database — db_tbl","text":"Using table-prep formulas centralized table store can make easier work DB tables pointblank. generate table store two named entries table preparations involving tbl_store() db_tbl() functions.   Now easy obtain either tables via tbl_get(). can reference table store name (given left ~).   second table table store mutated version first. just easily obtainable via tbl_get():   table-prep formulas store object also used functions tbl argument (like create_agent() create_informant()). accomplished easily tbl_source() function.","code":"store <-   tbl_store(     small_table_duck ~ db_tbl(       table = pointblank::small_table,       dbtype = \"duckdb\",       dbname = \":memory:\"     ),     small_high_duck ~ {{ small_table_duck }} %>%       dplyr::filter(f == \"high\")   ) tbl_get(tbl = \"small_table_duck\", store = store) ## # Source:   table<pointblank::small_table> [?? x 8] ## # Database: duckdb_connection ##    date_time           date           a b           c      d e ##    <dttm>              <date>     <int> <chr>   <dbl>  <dbl> <lgl> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-…     3  3423. TRUE ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-…     8 10000. TRUE ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-…     3  2343. TRUE ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-…    NA  3892. FALSE ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-…     7   284. TRUE ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-…     4  3291. TRUE ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-…     3   843. TRUE ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-…     2  1036. FALSE ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE ## # … with more rows, and 1 more variable: f <chr> tbl_get(tbl = \"small_high_duck\", store = store) ## # Source:   lazy query [?? x 8] ## # Database: duckdb_connection ##   date_time           date           a b             c     d e ##   <dttm>              <date>     <int> <chr>     <dbl> <dbl> <lgl> ## 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3 3423. TRUE ## 2 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3 2343. TRUE ## 3 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE ## 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE ## 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE ## 6 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE ## # … with more rows, and 1 more variable: f <chr> agent <-   create_agent(     tbl = ~ tbl_source(       tbl = \"small_table_duck\",       store = tbls     )   ) informant <-   create_informant(     tbl = ~ tbl_source(       tbl = \"small_high_duck\",       store = tbls     )   )"},{"path":"https://rstudio.github.io/pointblank/reference/db_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get a table from a database — db_tbl","text":"1-6","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/deactivate_steps.html","id":null,"dir":"Reference","previous_headings":"","what":"Deactivate one or more of an agent's validation steps — deactivate_steps","title":"Deactivate one or more of an agent's validation steps — deactivate_steps","text":"deactivation one validation steps necessary creation validation plan agent, deactivate_steps() function helpful . effect using active = FALSE option (active argument validation functions) selected validation steps. Please note directly edits validation step, wiping function may defined whether step active .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/deactivate_steps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deactivate one or more of an agent's validation steps — deactivate_steps","text":"","code":"deactivate_steps(agent, i = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/deactivate_steps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deactivate one or more of an agent's validation steps — deactivate_steps","text":"agent pointblank agent object obj:<ptblank_agent> // required pointblank agent object commonly created use create_agent() function. validation step number scalar<integer> // default: NULL (optional) validation step number, assigned validation step order definition. NULL (default) step deactivation occur index.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/deactivate_steps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deactivate one or more of an agent's validation steps — deactivate_steps","text":"ptblank_agent object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/deactivate_steps.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Deactivate one or more of an agent's validation steps — deactivate_steps","text":"9-6","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/deactivate_steps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deactivate one or more of an agent's validation steps — deactivate_steps","text":"","code":"# Create an agent that has the # `small_table` object as the # target table, add a few # validation steps, and then use # `interrogate()` agent_1 <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%   col_exists(columns = date) %>%   col_vals_regex(     columns = b,     regex = \"[0-9]-[a-z]{3}-[0-9]\"   ) %>%   interrogate()    # The second validation step is # now being reconsidered and may # be either phased out or improved # upon; in the interim period it # was decided that the step should # be deactivated for now agent_2 <-   agent_1 %>%   deactivate_steps(i = 2) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/draft_validation.html","id":null,"dir":"Reference","previous_headings":"","what":"Draft a starter pointblank validation .R/.Rmd file with a data table — draft_validation","title":"Draft a starter pointblank validation .R/.Rmd file with a data table — draft_validation","text":"Generate draft validation plan new .R .Rmd file using input data table. Using workflow, data table scanned learn column data set starter validation steps (constituting validation plan) written. best use data extract contains least 1000 rows relatively free spurious data. file, possible tweak validation steps better fit expectations particular domain. column inference used generate reasonable validation plans, difficult infer acceptable values without domain expertise. However, using draft_validation() get started floor 10 tackling data quality issues case better starting empty code editor view.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/draft_validation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draft a starter pointblank validation .R/.Rmd file with a data table — draft_validation","text":"","code":"draft_validation(   tbl,   tbl_name = NULL,   filename = tbl_name,   path = NULL,   lang = NULL,   output_type = c(\"R\", \"Rmd\"),   add_comments = TRUE,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://rstudio.github.io/pointblank/reference/draft_validation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draft a starter pointblank validation .R/.Rmd file with a data table — draft_validation","text":"tbl data table obj:<tbl_*> // required input table. can data frame, tibble, tbl_dbi object, tbl_spark object. tbl_name table name scalar<character> // default: NULL (optional) optional name assign input table object. value provided, name generated based whatever information available. table name displayed header area agent report generated printing agent calling get_agent_report(). filename File name scalar<character> // default: tbl_name optional name .R .Rmd file. name without extension. default, taken tbl_name nothing supplied , name contain text \"draft_validation_\" followed current date time. path File path scalar<character> // default: NULL (optional) path can specified attempt place generated file working directory. lang Commenting language scalar<character> // default: NULL (optional) language use creating comments automatically- generated validation steps. default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). output_type output file type singl-kw:[R|Rmd] // default: \"R\" option choosing type output generated. default, .R script (\"R\") alternatively R Markdown document (\"Rmd\"). add_comments Add comments generated validation plan scalar<logical> // default: TRUE comments explain features validation plan generated document? overwrite Overwrite previous file name scalar<logical> // default: FALSE file name overwritten? quiet Inform () upon file writing scalar<logical> // default: FALSE function inform file written?","code":""},{"path":"https://rstudio.github.io/pointblank/reference/draft_validation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draft a starter pointblank validation .R/.Rmd file with a data table — draft_validation","text":"Invisibly returns TRUE file written.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/draft_validation.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Draft a starter pointblank validation .R/.Rmd file with a data table — draft_validation","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/draft_validation.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draft a starter pointblank validation .R/.Rmd file with a data table — draft_validation","text":"draft validation plan dplyr::storms dataset.   draft_validation() function creates .R file default. Using just defaults dplyr::storms yield \"dplyr__storms.R\" file working directory. contents file:   runnable , promise interrogation produce failing test units. execution, get following validation report:  expressions resulting file constitute just rough approximation validation plan dataset. Certainly, value ranges emitted col_vals_between() may realistic wind column may require modification (provided left right values just limits provided data). However, note lat long (latitude longitude) columns acceptable ranges (providing limits valid lat/lon values). thanks pointblank's column inference routines, able understand certain columns contain. evolving dataset experience changes (either form revised data addition/deletion rows columns), emitted validation serve good first step changes can easily made since foundation build .","code":"dplyr::storms #> # A tibble: 19,537 x 13 #>    name   year month   day  hour   lat  long status      category  wind pressure #>    <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>          <dbl> <int>    <int> #>  1 Amy    1975     6    27     0  27.5 -79   tropical d~       NA    25     1013 #>  2 Amy    1975     6    27     6  28.5 -79   tropical d~       NA    25     1013 #>  3 Amy    1975     6    27    12  29.5 -79   tropical d~       NA    25     1013 #>  4 Amy    1975     6    27    18  30.5 -79   tropical d~       NA    25     1013 #>  5 Amy    1975     6    28     0  31.5 -78.8 tropical d~       NA    25     1012 #>  6 Amy    1975     6    28     6  32.4 -78.7 tropical d~       NA    25     1012 #>  7 Amy    1975     6    28    12  33.3 -78   tropical d~       NA    25     1011 #>  8 Amy    1975     6    28    18  34   -77   tropical d~       NA    30     1006 #>  9 Amy    1975     6    29     0  34.4 -75.8 tropical s~       NA    35     1004 #> 10 Amy    1975     6    29     6  34   -74.8 tropical s~       NA    40     1002 #> # i 19,527 more rows #> # i 2 more variables: tropicalstorm_force_diameter <int>, #> #   hurricane_force_diameter <int> library(pointblank)  agent <-   create_agent(     tbl = ~ dplyr::storms,     actions = action_levels(       warn_at = 0.05,       stop_at = 0.10     ),     tbl_name = \"dplyr::storms\",     label = \"Validation plan generated by `draft_validation()`.\"   ) %>%   # Expect that column `name` is of type: character   col_is_character(     columns = name   ) %>%   # Expect that column `year` is of type: numeric   col_is_numeric(     columns = year   ) %>%   # Expect that values in `year` should be between `1975` and `2020`   col_vals_between(     columns = year,     left = 1975,     right = 2020   ) %>%   # Expect that column `month` is of type: numeric   col_is_numeric(     columns = month   ) %>%   # Expect that values in `month` should be between `1` and `12`   col_vals_between(     columns = month,     left = 1,     right = 12   ) %>%   # Expect that column `day` is of type: integer   col_is_integer(     columns = day   ) %>%   # Expect that values in `day` should be between `1` and `31`   col_vals_between(     columns = day,     left = 1,     right = 31   ) %>%   # Expect that column `hour` is of type: numeric   col_is_numeric(     columns = hour   ) %>%   # Expect that values in `hour` should be between `0` and `23`   col_vals_between(     columns = hour,     left = 0,     right = 23   ) %>%   # Expect that column `lat` is of type: numeric   col_is_numeric(     columns = lat   ) %>%   # Expect that values in `lat` should be between `-90` and `90`   col_vals_between(     columns = lat,     left = -90,     right = 90   ) %>%   # Expect that column `long` is of type: numeric   col_is_numeric(     columns = long   ) %>%   # Expect that values in `long` should be between `-180` and `180`   col_vals_between(     columns = long,     left = -180,     right = 180   ) %>%   # Expect that column `status` is of type: character   col_is_character(     columns = status   ) %>%   # Expect that column `category` is of type: factor   col_is_factor(     columns = category   ) %>%   # Expect that column `wind` is of type: integer   col_is_integer(     columns = wind   ) %>%   # Expect that values in `wind` should be between `10` and `160`   col_vals_between(     columns = wind,     left = 10,     right = 160   ) %>%   # Expect that column `pressure` is of type: integer   col_is_integer(     columns = pressure   ) %>%   # Expect that values in `pressure` should be between `882` and `1022`   col_vals_between(     columns = pressure,     left = 882,     right = 1022   ) %>%   # Expect that column `tropicalstorm_force_diameter` is of type: integer   col_is_integer(     columns = tropicalstorm_force_diameter   ) %>%   # Expect that values in `tropicalstorm_force_diameter` should be between   # `0` and `870`   col_vals_between(     columns = tropicalstorm_force_diameter,     left = 0,     right = 870,     na_pass = TRUE   ) %>%   # Expect that column `hurricane_force_diameter` is of type: integer   col_is_integer(     columns = hurricane_force_diameter   ) %>%   # Expect that values in `hurricane_force_diameter` should be between   # `0` and `300`   col_vals_between(     columns = hurricane_force_diameter,     left = 0,     right = 300,     na_pass = TRUE   ) %>%   # Expect entirely distinct rows across all columns   rows_distinct() %>%   # Expect that column schemas match   col_schema_match(     schema = col_schema(       name = \"character\",       year = \"numeric\",       month = \"numeric\",       day = \"integer\",       hour = \"numeric\",       lat = \"numeric\",       long = \"numeric\",       status = \"character\",       category = c(\"ordered\", \"factor\"),       wind = \"integer\",       pressure = \"integer\",       tropicalstorm_force_diameter = \"integer\",       hurricane_force_diameter = \"integer\"     )   ) %>%   interrogate()  agent"},{"path":"https://rstudio.github.io/pointblank/reference/draft_validation.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Draft a starter pointblank validation .R/.Rmd file with a data table — draft_validation","text":"1-11","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/email_blast.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditionally send email during interrogation — email_blast","title":"Conditionally send email during interrogation — email_blast","text":"email_blast() function useful sending email message explains result pointblank validation. powered blastula glue packages. function invoked part end_fns argument create_agent(). also possible invoke email_blast() part fns argument action_levels() function (.e., send multiple email messages granularity different validation steps exceeding failure thresholds). better get handle emailing email_blast(), analogous email_create() function can used pointblank agent object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/email_blast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditionally send email during interrogation — email_blast","text":"","code":"email_blast(   x,   to,   from,   credentials = NULL,   msg_subject = NULL,   msg_header = NULL,   msg_body = stock_msg_body(),   msg_footer = stock_msg_footer(),   send_condition = ~TRUE %in% x$notify )"},{"path":"https://rstudio.github.io/pointblank/reference/email_blast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditionally send email during interrogation — email_blast","text":"x reference x-list object prepared internally agent. version x-list generated via get_agent_x_list(<agent>) except version internally generated hence available internal evaluation context. , email addresses recipients sender. credentials credentials list object produced either blastula::creds(), blastula::creds_anonymous(), blastula::creds_key(), blastula::creds_file() functions. Please refer blastula documentation information use functions. msg_subject subject line email message. msg_header, msg_body, msg_footer Content header, body, footer components HTML email message. send_condition expression evaluate logical vector length 1. evaluated TRUE email sent, FALSE happen. expression can use x-list variables (e.g., x$notify, x$type, etc.) variables can explored using get_agent_x_list() function. default expression ~ TRUE %% x$notify, results TRUE TRUE values x$notify logical vector (.e., validation step results 'notify' state).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/email_blast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditionally send email during interrogation — email_blast","text":"Nothing returned. end result side-effect email-sending certain conditions met.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/email_blast.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Conditionally send email during interrogation — email_blast","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). example use email_blast() inside end_fns argument create_agent() expressed R code corresponding YAML representation. R statement:   YAML representation:","code":"create_agent(   tbl = ~ small_table,   tbl_name = \"small_table\",   label = \"An example.\",   actions = al,   end_fns = list(     ~ email_blast(       x,       to = \"joe_public@example.com\",       from = \"pb_notif@example.com\",       msg_subject = \"Table Validation\",       credentials = blastula::creds_key(         id = \"smtp2go\"       )     )   ) ) %>%   col_vals_gt(a, 1) %>%   col_vals_lt(a, 7) type: agent tbl: ~small_table tbl_name: small_table label: An example. lang: en locale: en actions:   warn_count: 1.0   notify_count: 2.0 end_fns: ~email_blast(x, to = \"joe_public@example.com\",   from = \"pb_notif@example.com\", msg_subject = \"Table Validation\",   credentials = blastula::creds_key(id = \"smtp2go\"),   ) embed_report: true steps: - col_vals_gt:     columns: c(a)     value: 1.0 - col_vals_lt:     columns: c(a)     value: 7.0"},{"path":"https://rstudio.github.io/pointblank/reference/email_blast.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditionally send email during interrogation — email_blast","text":"example provided , use included small_table dataset. also going create action_levels() list object since useful demonstrating emailing scenario. absolute values warn notify states (thresholds 1 2 'fail' units, respectively, two states).   Validate values column small_tbl always greater 1 (col_vals_gt() validation function), , values always less 7. email_blast() function call used list given end_fns argument create_agent(). email_blast() call send_condition argument determines whether email sent. default set ~ TRUE %% x$notify. unpack bit. variable x list (call x-list) populated elements pertaining agent. interrogation, action levels set notify state, x$notify present logical vector length corresponds number validation steps. Thus, steps entered notify state (, take two failing test units, per step, happen), statement whole TRUE email interrogation report sent. complete set statements creation agent, addition validation steps, interrogation data small_table:   reason ~ present statements: ~ email_blast(...) ~ TRUE %% x$notify defers evocation emailing functionality (also defers evaluation send_condition value) interrogation complete (interrogate()).","code":"al <-   action_levels(     warn_at = 1,     notify_at = 2   ) agent <-   create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al,     end_fns = list(       ~ email_blast(         x,         to =   \"a_person@example.com\",         from = \"pb_notif@example.com\",         msg_subject = \"Table Validation\",         credentials = blastula::creds_key(id = \"smtp2go\"),         send_condition = ~ TRUE %in% x$notify       )     )   ) %>%   col_vals_gt(a, value = 1) %>%   col_vals_lt(a, value = 7) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/email_blast.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Conditionally send email during interrogation — email_blast","text":"4-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/email_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an email object from a pointblank agent — email_create","title":"Create an email object from a pointblank agent — email_create","text":"email_create() function produces email message object sent using blastula package. supplying pointblank agent, blastula email_message message object created printing make HTML email message appear Viewer.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/email_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an email object from a pointblank agent — email_create","text":"","code":"email_create(   x,   msg_header = NULL,   msg_body = stock_msg_body(),   msg_footer = stock_msg_footer() )"},{"path":"https://rstudio.github.io/pointblank/reference/email_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an email object from a pointblank agent — email_create","text":"x pointblank agent object obj:<ptblank_agent> // required pointblank agent object commonly created use create_agent() function. msg_header, msg_body, msg_footer Content header, body, footer components HTML email message.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/email_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an email object from a pointblank agent — email_create","text":"blastula email_message object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/email_create.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an email object from a pointblank agent — email_create","text":"example provided , use included small_table dataset. also going create action_levels() list object since useful demonstrating emailing scenario. absolute values warn notify states (thresholds 1 2 'fail' units, respectively, two states).   workflow involves agent object, can make use end_fns argument programmatically email report email_blast() function. However, alternate workflow demonstrated produce email object directly. provides flexibility send email outside pointblank API. email_create() function lets us agent object. can view HTML email just printing email_object. appear Viewer.","code":"al <-   action_levels(     warn_at = 1,     notify_at = 2   ) email_object <-   create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al   ) %>%   col_vals_gt(a, value = 1) %>%   col_vals_lt(a, value = 7) %>%   interrogate() %>%   email_create()  email_object"},{"path":"https://rstudio.github.io/pointblank/reference/email_create.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Create an email object from a pointblank agent — email_create","text":"4-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/export_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Export an agent, informant, multiagent, or table scan to HTML — export_report","title":"Export an agent, informant, multiagent, or table scan to HTML — export_report","text":"agent, informant, multiagent, table scan object can easily written HTML export_report(). Furthermore, report objects agent, informant, multiagent (generated using get_agent_report(), get_informant_report(), get_multiagent_report()) can provided HTML export. HTML document written disk self-contained easily viewable web browser.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/export_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export an agent, informant, multiagent, or table scan to HTML — export_report","text":"","code":"export_report(x, filename, path = NULL, quiet = FALSE)"},{"path":"https://rstudio.github.io/pointblank/reference/export_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export an agent, informant, multiagent, or table scan to HTML — export_report","text":"x One several types objects <object> // required agent object class ptblank_agent, informant class ptblank_informant, multiagent class ptblank_multiagent, table scan class ptblank_tbl_scan, , customized reporting objects (ptblank_agent_report, ptblank_informant_report, ptblank_multiagent_report.wide, ptblank_multiagent_report.long). filename File name scalar<character> // required filename create disk HTML export object provided. recommended extension \".html\" included. path File path scalar<character> // default: NULL (optional) optional path file saved (automatically combined filename). quiet Inform () upon file writing scalar<logical> // default: FALSE function inform file written?","code":""},{"path":"https://rstudio.github.io/pointblank/reference/export_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export an agent, informant, multiagent, or table scan to HTML — export_report","text":"Invisibly returns TRUE file written.","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/export_report.html","id":"a-writing-an-agent-report-as-html","dir":"Reference","previous_headings":"","what":"A: Writing an agent report as HTML","title":"Export an agent, informant, multiagent, or table scan to HTML — export_report","text":"go process (1) developing agent validation plan (used data quality analysis small_table dataset), (2) interrogating agent interrogate() function, (3) writing agent intel file. Creating action_levels object common workflow step creating pointblank agent. designate failure thresholds warn, stop, notify states using action_levels().   Now create pointblank agent object give al object (serves default validation steps can overridden). data referenced tbl argument leading ~.   agent object, can add steps validation plan using many validation functions want. , interrogate().   agent report can written HTML file export_report().   consistently writing agent reports periodically checking data, make use affix_date() affix_datetime() depending granularity need. example writes file format: \"<filename>-YYYY-mm-dd_HH-MM-SS.html\".","code":"al <-   action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   ) agent <-   create_agent(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"`export_report()`\",     actions = al   ) agent <-   agent %>%   col_exists(columns = c(date, date_time)) %>%   col_vals_regex(     columns = b,     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(columns = d, value = 100) %>%   col_vals_lte(columns = c, value = 5) %>%   interrogate() export_report(   agent,   filename = \"agent-small_table.html\" ) export_report(   agent,   filename = affix_datetime(     \"agent-small_table.html\"   ) )"},{"path":"https://rstudio.github.io/pointblank/reference/export_report.html","id":"b-writing-an-informant-report-as-html","dir":"Reference","previous_headings":"","what":"B: Writing an informant report as HTML","title":"Export an agent, informant, multiagent, or table scan to HTML — export_report","text":"go process (1) creating informant object minimally describes small_table dataset, (2) ensuring data captured target table using incorporate() function, (3) writing informant report HTML. Create pointblank informant object create_informant() small_table dataset. Use incorporate() info snippets integrated text.   informant report can written HTML file export_report(). affix_date() filename datestamp.","code":"informant <-   create_informant(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"`export_report()`\"   ) %>%   info_snippet(     snippet_name = \"high_a\",     fn = snip_highest(column = \"a\")   ) %>%   info_snippet(     snippet_name = \"low_a\",     fn = snip_lowest(column = \"a\")   ) %>%   info_columns(     columns = a,     info = \"From {low_a} to {high_a}.\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values.\"   ) %>%   info_columns(     columns = date,     info = \"The date part of `date_time`.\"   ) %>%   incorporate() export_report(   informant,   filename = affix_date(     \"informant-small_table.html\"   ) )"},{"path":"https://rstudio.github.io/pointblank/reference/export_report.html","id":"c-writing-a-table-scan-as-html","dir":"Reference","previous_headings":"","what":"C: Writing a table scan as HTML","title":"Export an agent, informant, multiagent, or table scan to HTML — export_report","text":"can get report describes data storms dataset.   table scan object can written HTML file export_report().","code":"tbl_scan <- scan_data(tbl = dplyr::storms) export_report(   tbl_scan,   filename = \"tbl_scan-storms.html\" )"},{"path":"https://rstudio.github.io/pointblank/reference/export_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Export an agent, informant, multiagent, or table scan to HTML — export_report","text":"9-3","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/file_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a table from a local or remote file — file_tbl","title":"Get a table from a local or remote file — file_tbl","text":"target table file, stored either locally remotely, file_tbl() function can make possible access single function call. Compatible file types function : CSV (.csv), TSV (.tsv), RDA (.rda), RDS (.rds) files. function generates -memory tbl_df object, can used target table create_agent() create_informant(). Another great option supplying table-prep formula involving file_tbl() tbl_store() access tables based flat files though single names via table store. remote data use case, can specify URL starting http://, https://, etc., ending file containing data table. data files available GitHub repository can use from_github() function specify name location table data repository.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/file_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a table from a local or remote file — file_tbl","text":"","code":"file_tbl(file, type = NULL, ..., keep = FALSE, verify = TRUE)"},{"path":"https://rstudio.github.io/pointblank/reference/file_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a table from a local or remote file — file_tbl","text":"file complete file path leading compatible data table either user system http://, https://, ftp://, ftps:// URL. file hosted GitHub repository, call from_github() function can used . type file type. normally inferred file extension default NULL indicate extension dictate type file reading performed internally. However, extension (valid extensions .csv, .tsv, .rda, .rds), can provide type either csv, tsv, rda, rds. ... Options passed readr's read_csv() read_tsv() function. functions arguments one used internally based file extension explicit value given type. keep case downloaded file, stored working directory (keep = TRUE) downloaded temporary directory? default, FALSE. verify TRUE (default) verification data object data.frame class carried .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/file_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a table from a local or remote file — file_tbl","text":"tbl_df object.","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/file_tbl.html","id":"producing-tables-from-csv-files","dir":"Reference","previous_headings":"","what":"Producing tables from CSV files","title":"Get a table from a local or remote file — file_tbl","text":"local CSV file can obtained tbl object supplying path file CSV reading options (ones used readr::read_csv()) file_tbl() function. example obtain path CSV file pointblank package system.file().   use path file_tbl() option specify column types CSV.   Now `tbl` object tibble introduced create_agent() validation.   different strategy provide data-reading function call directly create_agent():   file-reading instructions encapsulated tbl expression (leading ~) agent always obtain recent version table (logic can translated YAML, later use).","code":"csv_path <-   system.file(     \"data_files\", \"small_table.csv\",     package = \"pointblank\"   ) tbl <-   file_tbl(     file = csv_path,     col_types = \"TDdcddlc\"   )  tbl ## # A tibble: 13 × 8 ##    date_time           date           a b           c      d e     f ##    <dttm>              <date>     <dbl> <chr>   <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-…     3  3423. TRUE  high ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-…     8 10000. TRUE  low ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-…     3  2343. TRUE  high ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-…    NA  3892. FALSE mid ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-…     7   284. TRUE  low ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-…     4  3291. TRUE  mid ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-…     3   843. TRUE  high ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-…     2  1036. FALSE low ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE high ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE high ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-…     7   834. TRUE  low ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-…     8   108. FALSE low ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-…    NA  2230. TRUE  high agent <- create_agent(tbl = tbl) agent <-   create_agent(     tbl = ~ file_tbl(       file = system.file(         \"data_files\", \"small_table.csv\",         package = \"pointblank\"       ),       col_types = \"TDdcddlc\"     )   ) %>%   col_vals_gt(columns = a, value = 0)"},{"path":"https://rstudio.github.io/pointblank/reference/file_tbl.html","id":"producing-tables-from-files-on-github","dir":"Reference","previous_headings":"","what":"Producing tables from files on GitHub","title":"Get a table from a local or remote file — file_tbl","text":"CSV can obtained public GitHub repo using from_github() helper function. create agent supply table-prep formula gets CSV file GitHub repository pointblank package.      interrogated data obtained remote source file, , nothing clean (default, downloaded file goes system temp directory).","code":"agent <-   create_agent(     tbl = ~ file_tbl(       file = from_github(         file = \"inst/data_files/small_table.csv\",         repo = \"rstudio/pointblank\"       ),       col_types = \"TDdcddlc\"     ),     tbl_name = \"small_table\",     label = \"`file_tbl()` example.\",   ) %>%   col_vals_gt(columns = a, value = 0) %>%   interrogate() agent"},{"path":"https://rstudio.github.io/pointblank/reference/file_tbl.html","id":"file-access-table-creation-and-prep-via-the-table-store","dir":"Reference","previous_headings":"","what":"File access, table creation, and prep via the table store","title":"Get a table from a local or remote file — file_tbl","text":"Using table-prep formulas centralized table store can make easier work tables disparate sources. generate table store two named entries table preparations involving tbl_store() file_tbl() functions.   Now easy access either tables via tbl_get(). can reference table store name (given left ~).   second table table store mutated version first. just easily obtainable via tbl_get():   table-prep formulas store object also used functions tbl argument (like create_agent() create_informant()). accomplished easily tbl_source() function.","code":"store <-   tbl_store(     small_table_file ~ file_tbl(       file = system.file(         \"data_files\", \"small_table.csv\",         package = \"pointblank\"       ),       col_types = \"TDdcddlc\"     ),     small_high_file ~ {{ small_table_file }} %>%       dplyr::filter(f == \"high\")   ) tbl_get(tbl = \"small_table_file\", store = store) ## # A tibble: 13 × 8 ##    date_time           date           a b           c      d e     f ##    <dttm>              <date>     <dbl> <chr>   <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-…     3  3423. TRUE  high ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-…     8 10000. TRUE  low ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-…     3  2343. TRUE  high ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-…    NA  3892. FALSE mid ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-…     7   284. TRUE  low ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-…     4  3291. TRUE  mid ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-…     3   843. TRUE  high ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-…     2  1036. FALSE low ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE high ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-…     9   838. FALSE high ## 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-…     7   834. TRUE  low ## 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-…     8   108. FALSE low ## 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-…    NA  2230. TRUE  high tbl_get(tbl = \"small_high_file\", store = store) ## # A tibble: 6 × 8 ##   date_time           date           a b             c     d e     f ##   <dttm>              <date>     <dbl> <chr>     <dbl> <dbl> <lgl> <chr> ## 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3 3423. TRUE  high ## 2 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3 2343. TRUE  high ## 3 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE  high ## 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high ## 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high ## 6 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE  high agent <-   create_agent(     tbl = ~ tbl_source(       tbl = \"small_table_file\",       store = store     )   ) informant <-   create_informant(     tbl = ~ tbl_source(       tbl = \"small_high_file\",       store = store     )   )"},{"path":"https://rstudio.github.io/pointblank/reference/file_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get a table from a local or remote file — file_tbl","text":"1-7","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/from_github.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify a file for download from GitHub — from_github","title":"Specify a file for download from GitHub — from_github","text":"from_github() function helpful generating valid URL points data file public GitHub repository. function can used file argument file_tbl() function anywhere else GitHub URLs raw user content needed.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/from_github.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify a file for download from GitHub — from_github","text":"","code":"from_github(file, repo, subdir = NULL, default_branch = \"main\")"},{"path":"https://rstudio.github.io/pointblank/reference/from_github.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify a file for download from GitHub — from_github","text":"file name file target GitHub repository. can path leading including file. combined path given subdir. repo GitHub repository address format username/repo[/subdir][@ref|#pull|@*release]. subdir path string representing subdirectory GitHub repository. combined path components included file. default_branch name default branch repo. usually \"main\" (default used ).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/from_github.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify a file for download from GitHub — from_github","text":"character vector length 1 contains URL.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/from_github.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Specify a file for download from GitHub — from_github","text":"13-6","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/from_github.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify a file for download from GitHub — from_github","text":"","code":"# A valid URL to a data file in GitHub can be # obtained from the HEAD of the default branch # from_github( #   file = \"inst/data_files/small_table.csv\", #   repo = \"rstudio/pointblank\" # )  # The path to the file location can be supplied # fully or partially to `subdir` # from_github( #   file = \"small_table.csv\", #   repo = \"rstudio/pointblank\", #   subdir = \"inst/data_files\" # )  # We can use the first call in combination with # `file_tbl()` and `create_agent()`; this # supplies a table-prep formula that gets # a CSV file from the GitHub repository for the # pointblank package  # agent <-  #   create_agent( #     tbl = ~ file_tbl( #       file = from_github( #         file = \"inst/data_files/small_table.csv\", #         repo = \"rstudio/pointblank\" #       ), #       col_types = \"TDdcddlc\" #     ) #   ) %>% #   col_vals_gt(a, 0) %>% #   interrogate()  # The `from_github()` helper function is # pretty powerful and can get at lots of # different files in a repository  # A data file from GitHub can be obtained from # a commit at release time # from_github( #   file = \"inst/extdata/small_table.csv\", #   repo = \"rstudio/pointblank@v0.2.1\" # )  # A file may also be obtained from a repo at the # point in time of a specific commit (partial or # full SHA-1 hash for the commit can be used) # from_github( #   file = \"data-raw/small_table.csv\", #   repo = \"rstudio/pointblank@e04a71\" # )  # A file may also be obtained from an # *open* pull request # from_github( #   file = \"data-raw/small_table.csv\", #   repo = \"rstudio/pointblank#248\" # )"},{"path":"https://rstudio.github.io/pointblank/reference/game_revenue.html","id":null,"dir":"Reference","previous_headings":"","what":"A table with game revenue data — game_revenue","title":"A table with game revenue data — game_revenue","text":"table subset sj_all_revenue table intendo data package. first 2,000 rows table revenue records range 2015-01-01 2015-01-21.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/game_revenue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A table with game revenue data — game_revenue","text":"","code":"game_revenue"},{"path":"https://rstudio.github.io/pointblank/reference/game_revenue.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A table with game revenue data — game_revenue","text":"tibble 2,000 rows 11 variables: player_id character column unique identifiers user/player. session_id character column contains unique identifiers player session. session_start date-time column indicates session (containing revenue event) started. time date-time column indicates exactly player purchase (revenue event) occurred. item_type character column provides class item purchased. item_name character column provides name item purchased. item_revenue numeric column revenue amounts per item purchased. session_duration numeric column states length session (minutes) purchase occurred. start_day Date column provides date first login player making purchase. acquisition character column provides method acquisition player. country character column provides probable country residence player.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/game_revenue.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A table with game revenue data — game_revenue","text":"14-4","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/game_revenue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A table with game revenue data — game_revenue","text":"","code":"# Here is a glimpse at the data # available in `game_revenue` dplyr::glimpse(game_revenue) #> Rows: 2,000 #> Columns: 11 #> $ player_id        <chr> \"ECPANOIXLZHF896\", \"ECPANOIXLZHF896\", \"ECPANOIXLZHF89… #> $ session_id       <chr> \"ECPANOIXLZHF896-eol2j8bs\", \"ECPANOIXLZHF896-eol2j8bs… #> $ session_start    <dttm> 2015-01-01 01:31:03, 2015-01-01 01:31:03, 2015-01-01… #> $ time             <dttm> 2015-01-01 01:31:27, 2015-01-01 01:36:57, 2015-01-01… #> $ item_type        <chr> \"iap\", \"iap\", \"iap\", \"ad\", \"ad\", \"ad\", \"ad\", \"ad\", \"a… #> $ item_name        <chr> \"offer2\", \"gems3\", \"gold7\", \"ad_20sec\", \"ad_5sec\", \"a… #> $ item_revenue     <dbl> 8.991, 22.491, 107.991, 0.760, 0.030, 0.070, 0.080, 1… #> $ session_duration <dbl> 16.3, 16.3, 16.3, 16.3, 35.2, 35.2, 35.2, 35.2, 35.2,… #> $ start_day        <date> 2015-01-01, 2015-01-01, 2015-01-01, 2015-01-01, 2015… #> $ acquisition      <chr> \"google\", \"google\", \"google\", \"google\", \"google\", \"go… #> $ country          <chr> \"Germany\", \"Germany\", \"Germany\", \"Germany\", \"Germany\"…"},{"path":"https://rstudio.github.io/pointblank/reference/game_revenue_info.html","id":null,"dir":"Reference","previous_headings":"","what":"A table with metadata for the game_revenue dataset — game_revenue_info","title":"A table with metadata for the game_revenue dataset — game_revenue_info","text":"table contains metadata game_revenue table. first column (named column) provides column names game_revenue. second column (info) contains descriptions columns dataset. table correct format use info_columns_from_tbl() function.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/game_revenue_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A table with metadata for the game_revenue dataset — game_revenue_info","text":"","code":"game_revenue_info"},{"path":"https://rstudio.github.io/pointblank/reference/game_revenue_info.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A table with metadata for the game_revenue dataset — game_revenue_info","text":"tibble 11 rows 2 variables: column character column unique identifiers user/player. info character column contains unique identifiers player session.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/game_revenue_info.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A table with metadata for the game_revenue dataset — game_revenue_info","text":"14-5","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/game_revenue_info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A table with metadata for the game_revenue dataset — game_revenue_info","text":"","code":"# Here is a glimpse at the data # available in `game_revenue_info` dplyr::glimpse(game_revenue_info) #> Rows: 11 #> Columns: 2 #> $ column <chr> \"player_id\", \"session_id\", \"session_start\", \"time\", \"item_type\"… #> $ info   <chr> \"A `character` column with unique identifiers for each user/pla…"},{"path":"https://rstudio.github.io/pointblank/reference/get_agent_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a summary report from an agent — get_agent_report","title":"Get a summary report from an agent — get_agent_report","text":"can get informative summary table agent using get_agent_report() function. table can provided two substantially different forms: gt based display table (default), , tibble. amount fields intel different depending whether agent performed interrogation (interrogate() function). Basically, interrogate() called, agent contain just validation plan (however many rows depends many validation functions supplied part plan). Post-interrogation, information passing failing test units provided, along indicators whether certain failure states entered (provided set actions). display table variant agent report, default form, following columns: (unlabeled): validation step number. STEP: name validation function used validation step, COLUMNS: names target columns used validation step (applicable). VALUES: values used validation step, applicable; literal values, column names, expression, etc. TBL: indicates whether changes target table just prior interrogation. rightward arrow small circle indicates mutation table. arrow circle purple square indicates preconditions used modify target table. arrow circle half-filled circle indicates target table segmented. EVAL: symbol denotes success interrogation evaluation step. checkmark indicates issues evaluation. warning sign indicates warning occurred evaluation. explosion symbol indicates evaluation failed due error. Hover symbol details condition. UNITS: total number test units validation step PASS: top absolute number passing test units fraction passing test units total number test units. FAIL: top absolute number failing test units fraction failing test units total number test units. W, S, N: indicators show whether warn, stop, notify states entered; unset states appear dashes, states set thresholds appear unfilled circles entered filled thresholds exceeded (colors W, S, N amber, red, blue) EXT: column provides buttons download data extracts CSV files row-based validation steps failing test units. Buttons appear data collect. small version display table (obtained using size = \"small\") omits COLUMNS, TBL, EXT columns. width small table 575px; standard table 875px wide. ptblank_agent_report can exported standalone HTML document export_report() function. choosing get tibble (display_table = FALSE), following columns: : validation step number. type: name validation function used validation step. columns: names target columns used validation step (applicable). values: values used validation step, applicable; conjointly() validation step, listing sub-validations. precon: indicates whether preconditions apply interrogation , , number statements used. active: logical value indicates whether validation step set \"active\" interrogation. eval: character value denotes success interrogation evaluation step. value \"OK\" indicates issues evaluation. \"WARNING\" value indicates warning occurred evaluation. \"ERROR\" VALUES indicates evaluation failed due error. \"W+E\" warnings error occurred evaluation. units: total number test units validation step. n_pass: number passing test units. f_pass: fraction passing test units. W, S, N: logical value stating whether warn, stop, notify states entered. NA states unset. extract: integer value indicates number rows available data extract. NA extract available.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_agent_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a summary report from an agent — get_agent_report","text":"","code":"get_agent_report(   agent,   arrange_by = c(\"i\", \"severity\"),   keep = c(\"all\", \"fail_states\"),   display_table = TRUE,   size = \"standard\",   title = \":default:\",   lang = NULL,   locale = NULL )"},{"path":"https://rstudio.github.io/pointblank/reference/get_agent_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a summary report from an agent — get_agent_report","text":"agent pointblank agent object obj:<ptblank_agent> // required pointblank agent object commonly created use create_agent() function. arrange_by Method arranging report's table rows singl-kw:[|severity] // default: \"\" choice arrange report table rows validation step number (\"\", default), , arrange descending order severity failure state (\"severity\"). keep table rows kept? singl-kw:[|fail_states] // default: \"\" option keep \"\" report's table rows (default), , keep rows reflect one \"fail_states\". display_table Return display-table report via gt scalar<logical> // default: TRUE display table generated? TRUE, gt package installed, display table report shown Viewer. FALSE, gt available, tibble returned. size Size option display-table report scalar<character> // default: \"standard\" size display table, can either \"standard\" (default) \"small\". applies display table (display_table = TRUE). title Title customization options scalar<character> // default: \":default:\" Options customizing title report. default keyword \":default:\" produces generic title text refers pointblank package language governed lang option. Another keyword option \":tbl_name:\", presents name table title report. title wanted, \":none:\" keyword option can used. Aside keyword options, text can provided title glue::glue() calls can used construct text string. providing text, interpreted Markdown text transformed internally HTML. circumvent transformation, use text () explicitly state supplied text transformed. lang Reporting language scalar<character> // default: NULL (optional) language use automatic creation briefs (short descriptions validation step) agent report (summary table provides validation plan results interrogation. default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). lang option override previously set language setting (e.g., create_agent() call). locale Locale value formatting scalar<character> // default: NULL (optional) optional locale ID use formatting values agent report summary table according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). locale option override previously set locale value (e.g., create_agent() call).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_agent_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a summary report from an agent — get_agent_report","text":"ptblank_agent_report object display_table = TRUE tibble display_table = FALSE.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_agent_report.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a summary report from an agent — get_agent_report","text":"example , use simple table single numerical column .   create agent validate values column always greater 4.   can get tibble-based report agent using get_agent_report() display_table = FALSE.   full-featured display-table-based report can viewed printing agent object, , can get \"ptblank_agent_report\" object returned us using display_table = TRUE (default get_agent_report).    can report object? Print wherever, , can serve input export_report() function. However, better reason use get_agent_report() just printing agent display-table purposes make use different display options. agent report gt display table comes two sizes: \"standard\" (default, 875px wide) \"small\" (575px wide). take look smaller-sized version report.    can use title supplying title argument, , use special keyword like \":tbl_name:\" get table name (set create_agent() call) title.    options! can change language display table lang argument (overrides language set create_agent()), validation steps can rearranged using arrange_by argument, can also apply filtering keep argument get_agent_report().","code":"tbl <- dplyr::tibble(a = c(5, 7, 8, 5))  tbl #> # A tibble: 4 x 1 #>       a #>   <dbl> #> 1     5 #> 2     7 #> 3     8 #> 4     5 agent <-   create_agent(     tbl = tbl,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%   col_vals_gt(columns = a, value = 4) %>%   interrogate() agent %>% get_agent_report(display_table = FALSE) ## # A tibble: 1 × 14 ##       i type    columns values precon active eval  units n_pass ##   <int> <chr>   <chr>   <chr>  <chr>  <lgl>  <chr> <dbl>  <dbl> ## 1     1 col_va… a       4      NA     TRUE   OK        4      4 ## # … with 5 more variables: f_pass <dbl>, W <lgl>, S <lgl>, ## #   N <lgl>, extract <int> report <- get_agent_report(agent)  report small_report <-   get_agent_report(     agent = agent,     size = \"small\"   )  small_report report_title <- get_agent_report(agent, title = \":tbl_name:\")  report_title"},{"path":"https://rstudio.github.io/pointblank/reference/get_agent_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get a summary report from an agent — get_agent_report","text":"6-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/get_agent_x_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the agent's x-list — get_agent_x_list","title":"Get the agent's x-list — get_agent_x_list","text":"agent's x-list record information agent possesses given time. x-list contain complete information interrogation taken place (, data largely reflects validation plan). x-list can constrained particular validation step (supplying step number argument), , can get information validation steps leaving unspecified. x-list indeed R list object contains veritable cornucopia information. x-list obtained specified validation step, following components available: time_start: time interrogation began (POSIXct [0 1]) time_end: time interrogation ended (POSIXct [0 1]) label: optional label given agent (chr [1]) tbl_name: name table object, available (chr [1]) tbl_src: type table used validation (chr [1]) tbl_src_details: table database table, provides details DB table (chr [1]) tbl: table object col_names: table's column names (chr [ncol(tbl)]) col_types: table's column types (chr [ncol(tbl)]) : validation step index (int [1]) type: type validation, value validation function name (chr [1]) columns: columns specified validation function (chr [variable length]) values: values specified validation function (mixed types [variable length]) briefs: brief validation step specified lang (chr [1]) eval_error, eval_warning: indicates whether evaluation step function, interrogation, resulted error warning (lgl [1]) capture_stack: list captured errors warnings step-function evaluation interrogation time (list [1]) n: number test units validation step (num [1]) n_passed, n_failed: number passing failing test units validation step (num [1]) f_passed: fraction passing test units validation step, n_passed / n (num [1]) f_failed: fraction failing test units validation step, n_failed / n (num [1]) warn, stop, notify: logical value indicating whether level failing test units caused corresponding conditions entered (lgl [1]) lang: two-letter language code indicates language used briefs, agent report, reporting generated scan_data() function (chr [1]) unspecified (.e., constrained specific validation step) certain length-one components x-list expanded total number validation steps (: , type, columns, values, briefs, eval_error, eval_warning, capture_stack, n, n_passed, n_failed, f_passed, f_failed, warn, stop, notify). x-list also additional components NULL, : report_object: gt table object, also presented default print method ptblank_agent email_object: blastula email_message object default set components report_html: HTML source report_object, provided length-one character vector report_html_small: HTML source narrower, condensed version report_object, provided length-one character vector; HTML inlined styles, making suitable email message bodies","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_agent_x_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the agent's x-list — get_agent_x_list","text":"","code":"get_agent_x_list(agent, i = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/get_agent_x_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the agent's x-list — get_agent_x_list","text":"agent pointblank agent object obj:<ptblank_agent> // required pointblank agent object commonly created use create_agent() function. validation step number scalar<integer> // default: NULL (optional) validation step number, assigned validation step order invocation. NULL (default), x-list provide information validation steps. valid step number provided x-list information pertaining step.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_agent_x_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the agent's x-list — get_agent_x_list","text":"x_list object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_agent_x_list.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the agent's x-list — get_agent_x_list","text":"Create simple data frame column numerical values.   Create action_levels() list fractional values warn, stop, notify states.   Create agent (giving tbl al objects), supply two validation step functions, interrogate.   Get f_passed component agent x-list.","code":"tbl <- dplyr::tibble(a = c(5, 7, 8, 5))  tbl #> # A tibble: 4 x 1 #>       a #>   <dbl> #> 1     5 #> 2     7 #> 3     8 #> 4     5 al <-   action_levels(     warn_at = 0.2,     stop_at = 0.8,     notify_at = 0.345   ) agent <-   create_agent(     tbl = tbl,     actions = al   ) %>%   col_vals_gt(columns = a, value = 7) %>%   col_is_numeric(columns = a) %>%   interrogate() x <- get_agent_x_list(agent)  x$f_passed #> [1] 0.25 1.00"},{"path":"https://rstudio.github.io/pointblank/reference/get_agent_x_list.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get the agent's x-list — get_agent_x_list","text":"8-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/get_data_extracts.html","id":null,"dir":"Reference","previous_headings":"","what":"Collect data extracts from a validation step — get_data_extracts","title":"Collect data extracts from a validation step — get_data_extracts","text":"agent-based workflow (.e., initiating create_agent()), interrogation interrogate(), can extract row data pass row-based validation steps get_data_extracts() function. one discrete extract per row-based validation step amount data available particular extract depends fraction test units pass validation step level sampling explicit collection set units. extracts can collected programmatically get_data_extracts() may also downloaded CSV files HTML report generated agent's print method use get_agent_report(). availability data extracts row-based validation step depends whether extract_failed set TRUE within interrogate() call (default). amount fail rows extracted depends collection parameters interrogate(), default behavior collect first 5000 fail rows. Row-based validation steps based validation functions form col_vals_*() also include conjointly() rows_distinct(). functions combined set validation functions can yield data extracts.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_data_extracts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collect data extracts from a validation step — get_data_extracts","text":"","code":"get_data_extracts(agent, i = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/get_data_extracts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collect data extracts from a validation step — get_data_extracts","text":"agent pointblank agent object obj:<ptblank_agent> // required pointblank agent object commonly created use create_agent() function. interrogate() called , validation steps carried sample rows non-passing validations potentially available object. validation step number scalar<integer> // default: NULL (optional) validation step number, assigned validation step pointblank order definition. NULL (default), data extract tables provided list object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_data_extracts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collect data extracts from a validation step — get_data_extracts","text":"list tables provided, , standalone table given.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_data_extracts.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collect data extracts from a validation step — get_data_extracts","text":"Create series two validation steps focused testing row values part small_table object. Use interrogate() right .   Using get_data_extracts() defaults returns list tables, table named validation step extract available.   can get extract specific step specifying argument. get failing rows first validation step (col_vals_gt() one).","code":"agent <-   create_agent(     tbl = small_table %>%       dplyr::select(a:f),     label = \"`get_data_extracts()`\"   ) %>%   col_vals_gt(d, value = 1000) %>%   col_vals_between(     columns = c,     left = vars(a), right = vars(d),     na_pass = TRUE   ) %>%   interrogate() agent %>% get_data_extracts() ## $`1` ## # A tibble: 6 × 6 ##       a b             c     d e     f ##   <int> <chr>     <dbl> <dbl> <lgl> <chr> ## 1     8 3-ldm-038     7  284. TRUE  low ## 2     7 1-knw-093     3  843. TRUE  high ## 3     3 5-bce-642     9  838. FALSE high ## 4     3 5-bce-642     9  838. FALSE high ## 5     4 2-dmx-010     7  834. TRUE  low ## 6     2 7-dmx-010     8  108. FALSE low ## ## $`2` ## # A tibble: 4 × 6 ##       a b             c     d e     f ##   <int> <chr>     <dbl> <dbl> <lgl> <chr> ## 1     6 8-kdg-938     3 2343. TRUE  high ## 2     8 3-ldm-038     7  284. TRUE  low ## 3     7 1-knw-093     3  843. TRUE  high ## 4     4 5-boe-639     2 1036. FALSE low agent %>% get_data_extracts(i = 1) ## # A tibble: 6 × 6 ##       a b             c     d e     f ##   <int> <chr>     <dbl> <dbl> <lgl> <chr> ## 1     8 3-ldm-038     7  284. TRUE  low ## 2     7 1-knw-093     3  843. TRUE  high ## 3     3 5-bce-642     9  838. FALSE high ## 4     3 5-bce-642     9  838. FALSE high ## 5     4 2-dmx-010     7  834. TRUE  low ## 6     2 7-dmx-010     8  108. FALSE low"},{"path":"https://rstudio.github.io/pointblank/reference/get_data_extracts.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Collect data extracts from a validation step — get_data_extracts","text":"8-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/get_informant_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a table information report from an informant object — get_informant_report","title":"Get a table information report from an informant object — get_informant_report","text":"can get table information report informant object generated create_informant() function. report provided gt based display table. amount information shown depends extent added via use info_*() functions direct editing pointblank YAML file (informant can written pointblank YAML yaml_write(informant = <informant>, ...)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_informant_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a table information report from an informant object — get_informant_report","text":"","code":"get_informant_report(   informant,   size = \"standard\",   title = \":default:\",   lang = NULL,   locale = NULL )"},{"path":"https://rstudio.github.io/pointblank/reference/get_informant_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a table information report from an informant object — get_informant_report","text":"informant pointblank informant object obj:<ptblank_informant> // required pointblank informant object commonly created use create_informant() function. size Size option display-table report scalar<character> // default: \"standard\" size display table, can either \"standard\" (default, width 875px), \"small\" (width 575px), , pixel- percent-based width choosing (supply integer value width pixels, values \"px\" \"%\" appended, like \"75%\", \"500px\", etc.). title Title customization options scalar<character> // default: \":default:\" Options customizing title report. default keyword \":default:\" produces generic title text refers pointblank package language governed lang option. Another keyword option \":tbl_name:\", presents name table title report. title wanted, \":none:\" keyword option can used. Aside keyword options, text can provided title glue::glue() calls can used construct text string. providing text, interpreted Markdown text transformed internally HTML. circumvent transformation, use text () explicitly state supplied text transformed. lang Reporting language scalar<character> // default: NULL (optional) language use information report. default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). lang option override previously set language setting (e.g., create_informant() call). locale Locale value formatting scalar<character> // default: NULL (optional) optional locale ID use formatting values information report summary table according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). locale option override previously set locale value (e.g., create_informant() call).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_informant_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a table information report from an informant object — get_informant_report","text":"gt table object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_informant_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get a table information report from an informant object — get_informant_report","text":"7-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/get_informant_report.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a table information report from an informant object — get_informant_report","text":"","code":"# Generate an informant object using # the `small_table` dataset informant <- create_informant(small_table)  # This function creates some information # without any extra help by profiling # the supplied table object; it adds # the sections 'table' and columns' and # we can print the object to see the # table information report  # Alternatively, we can get the same report # by using `get_informant_report()` report <- get_informant_report(informant) class(report) #> [1] \"ptblank_informant_report\" \"gt_tbl\"                   #> [3] \"list\""},{"path":"https://rstudio.github.io/pointblank/reference/get_multiagent_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a summary report using multiple agents — get_multiagent_report","title":"Get a summary report using multiple agents — get_multiagent_report","text":"can get informative summary table collective agents using get_multiagent_report() function. Information multiple agent can provided three forms: (1) Long Display (stacked reports), (2) Wide Display (comparison report), (3) tibble packed columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_multiagent_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a summary report using multiple agents — get_multiagent_report","text":"","code":"get_multiagent_report(   multiagent,   display_table = TRUE,   display_mode = c(\"long\", \"wide\"),   title = \":default:\",   lang = NULL,   locale = NULL )"},{"path":"https://rstudio.github.io/pointblank/reference/get_multiagent_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a summary report using multiple agents — get_multiagent_report","text":"multiagent multiagent object class ptblank_multiagent. display_table display table generated? TRUE (default) display table report shown Viewer. FALSE tibble returned. display_mode getting display table, agent data presented \"long\" \"wide\" form? default \"long\" comparing multiple runs target table might preferable choose \"wide\". title Options customizing title report display_table = TRUE. default keyword \":default:\" produces generic title text. title wanted, \":none:\" keyword option can used. Another keyword option \":tbl_name:\", presents name table title report (can used display_mode = \"long\"). Aside keyword options, text can provided title glue::glue() calls can used construct text string. providing text, interpreted Markdown text transformed internally HTML. circumvent transformation, use text () explicitly state supplied text transformed. lang Reporting language scalar<character> // default: NULL (optional) language use long wide report forms. default, NULL preserve language set component reports. following options force language across component reports: English (\"en\"), French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). locale Locale value formatting scalar<character> // default: NULL (optional) optional locale ID use formatting values long wide report forms (according locale's rules). Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\"). locale option override previously set locale values.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_multiagent_report.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a summary report using multiple agents — get_multiagent_report","text":"gt table object display_table = TRUE tibble display_table = FALSE.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_multiagent_report.html","id":"the-long-display","dir":"Reference","previous_headings":"","what":"The Long Display","title":"Get a summary report using multiple agents — get_multiagent_report","text":"displayed \"long\" multiagent report stack individual agent reports single document order agents multiagent object. validation plan (possibly interrogation info) provided output equivalent calling get_agent_report() agents within multiagent object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_multiagent_report.html","id":"the-wide-display","dir":"Reference","previous_headings":"","what":"The Wide Display","title":"Get a summary report using multiple agents — get_multiagent_report","text":"displayed \"wide\" multiagent report show data individual agents columns, rows standing validation steps common across agents. validation step represented icon (standing name validation function) associated SHA1 hash. highly trustworthy way ascertaining validation steps effectively identical across interrogations. way organizing report beneficial different agents may used different steps want track validation results validation step change target table (.e., new rows added, existing rows updated, etc.). single table display mode following columns: STEP: SHA1 hash validation step, possibly shared among several interrogations. subsequent columns: column beyond STEP represents separate interrogation agent object. time stamp completion interrogation shown column label.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_multiagent_report.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a summary report using multiple agents — get_multiagent_report","text":"walk several theoretical data quality analyses extremely small table. table called small_table can find dataset package.   set failure limits signal conditions, designate proportional failure thresholds warn, stop, notify states using action_levels().   create four different agents slightly different validation steps . first, agent_1, eight different validation steps created agent interrogate small_table.   second agent, agent_2, retains steps agent_1 adds two (last inactive).   third agent, agent_3, adds single validation step, removes fifth one, deactivates first.   fourth final agent, agent_4, reactivates steps 1 10, removes sixth step.   agents slightly different , can still get combined report creating 'multiagent'.   Calling multiagent console prints multiagent report. can generate \"ptblank_multiagent_report\" object get_multiagent_report() function specify options layout presentation. default, get_multiagent_report() gives long report agent reports stacked. Think \"long\" option serial mode agent reports. However want view interrogation results table time, wide view may preferable. way can see whether results common validation steps improved worsened consecutive interrogations data.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high al <-   action_levels(     warn_at = 0.05,     stop_at = 0.10,     notify_at = 0.20   ) agent_1 <-   create_agent(     tbl = small_table,     label = \"An example.\",     actions = al   ) %>%   col_vals_gt(     columns = date_time,     value = vars(date),     na_pass = TRUE   ) %>%   col_vals_gt(     columns = b,     value = vars(g),     na_pass = TRUE   ) %>%   rows_distinct() %>%   col_vals_equal(     columns = d,     value = vars(d),     na_pass = TRUE   ) %>%   col_vals_between(     columns = c,     left = vars(a), right = vars(d)   ) %>%   col_vals_not_between(     columns = c,     left = 10, right = 20,     na_pass = TRUE   ) %>%   rows_distinct(columns = d, e, f) %>%   col_is_integer(columns = a) %>%   interrogate() agent_2 <-   agent_1 %>%   col_exists(columns = date, date_time) %>%   col_vals_regex(     columns = b,     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     active = FALSE   ) %>%   interrogate() agent_3 <-   agent_2 %>%   col_vals_in_set(     columns = f,     set = c(\"low\", \"mid\", \"high\")   ) %>%   remove_steps(i = 5) %>%   deactivate_steps(i = 1) %>%   interrogate() agent_4 <-   agent_3 %>%   activate_steps(i = 1) %>%   activate_steps(i = 10) %>%   remove_steps(i = 6) %>%   interrogate() multiagent <-   create_multiagent(     agent_1, agent_2, agent_3, agent_4   ) report_wide <-   get_multiagent_report(     multiagent,     display_mode = \"wide\"   )  report_wide"},{"path":"https://rstudio.github.io/pointblank/reference/get_multiagent_report.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get a summary report using multiple agents — get_multiagent_report","text":"10-3","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/get_sundered_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Sunder the data, splitting it into 'pass' and 'fail' pieces — get_sundered_data","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces — get_sundered_data","text":"Validation data one thing , sometimes, want use best part input dataset something else. get_sundered_data() function works agent object intel (.e., post interrogate()) gets either 'pass' data piece (rows failing test units across row-based validation functions), , 'fail' data piece (rows least one failing test unit across series validations). final option, can emit data new column (called .pb_combined) labels row passing failing across validation steps. labels \"pass\" \"fail\" default values can easily customized.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_sundered_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces — get_sundered_data","text":"","code":"get_sundered_data(   agent,   type = c(\"pass\", \"fail\", \"combined\"),   pass_fail = c(\"pass\", \"fail\"),   id_cols = NULL )"},{"path":"https://rstudio.github.io/pointblank/reference/get_sundered_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces — get_sundered_data","text":"agent pointblank agent object obj:<ptblank_agent> // required pointblank agent object commonly created use create_agent() function. interrogate() called , validation steps actually carried . type desired piece data resulting splitting. Options returning single table \"pass\" (default) \"fail\". options return single table , \"pass\" case, rows passed across validation steps (.e., failing test units part row validation step), , complementary set rows \"fail\" case. Providing NULL returns split data tables list (names \"pass\" \"fail\"). option \"combined\" applies categorical (pass/fail) label (settable pass_fail argument) new .pb_combined flag column. case ordering rows fully retained input table. pass_fail vector encoding flag column 'pass' 'fail' values type = \"combined\". default c(\"pass\", \"fail\") options c(TRUE, FALSE), c(1, 0), c(1L, 0L). id_cols optional specification one identifying columns. taken together, can count single column grouping columns distinguish rows. table undergoing validation data frame tibble, columns need specified id_cols.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_sundered_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces — get_sundered_data","text":"list table objects type NULL, , single table type given.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_sundered_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces — get_sundered_data","text":"caveats sundering. validation steps considered splitting row-based variety (e.g., col_vals_*() functions conjointly(), rows_distinct()). Furthermore, validation steps experienced evaluation issues interrogation considered, , validation steps active = FALSE disregarded. collection validation steps fulfill requirements sundering termed -consideration validation steps. using preconditions validation steps, must ensure -consideration validation steps use specified preconditions function. Put another way, split target table using collection -consideration validation steps use different forms input table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_sundered_data.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces — get_sundered_data","text":"Create series two validation steps focused testing row values part small_table object. , use interrogate() put validation plan action.   Get sundered data piece contains rows passed validation steps (default piece). yields 5 13 total rows.   Get complementary data piece: rows failed either two validation steps. yields 8 13 total rows.   can get input data returned flag column (called .pb_combined). done using type = \"combined\" rightmost column contain \"pass\" \"fail\" values.   can change \"pass\" \"fail\" text values another type coding pass_fail argument. One possibility TRUE/FALSE.   ...using 0 1 might worthwhile situations.","code":"agent <-   create_agent(     tbl = small_table %>%       dplyr::select(a:f),     label = \"`get_sundered_data()`\"   ) %>%   col_vals_gt(columns = d, value = 1000) %>%   col_vals_between(     columns = c,     left = vars(a), right = vars(d),     na_pass = TRUE   ) %>%   interrogate() agent %>% get_sundered_data() ## # A tibble: 5 × 6 ##       a b             c      d e     f ##   <int> <chr>     <dbl>  <dbl> <lgl> <chr> ## 1     2 1-bcd-345     3  3423. TRUE  high ## 2     3 5-egh-163     8 10000. TRUE  low ## 3     2 5-jdo-903    NA  3892. FALSE mid ## 4     4 2-dhe-923     4  3291. TRUE  mid ## 5     1 3-dka-303    NA  2230. TRUE  high agent %>% get_sundered_data(type = \"fail\") ## # A tibble: 8 × 6 ##       a b             c     d e     f ##   <int> <chr>     <dbl> <dbl> <lgl> <chr> ## 1     6 8-kdg-938     3 2343. TRUE  high ## 2     8 3-ldm-038     7  284. TRUE  low ## 3     7 1-knw-093     3  843. TRUE  high ## 4     4 5-boe-639     2 1036. FALSE low ## 5     3 5-bce-642     9  838. FALSE high ## 6     3 5-bce-642     9  838. FALSE high ## 7     4 2-dmx-010     7  834. TRUE  low ## 8     2 7-dmx-010     8  108. FALSE low agent %>% get_sundered_data(type = \"combined\") ## # A tibble: 13 × 7 ##        a b             c      d e     f     .pb_combined ##    <int> <chr>     <dbl>  <dbl> <lgl> <chr> <chr> ##  1     2 1-bcd-345     3  3423. TRUE  high  pass ##  2     3 5-egh-163     8 10000. TRUE  low   pass ##  3     6 8-kdg-938     3  2343. TRUE  high  fail ##  4     2 5-jdo-903    NA  3892. FALSE mid   pass ##  5     8 3-ldm-038     7   284. TRUE  low   fail ##  6     4 2-dhe-923     4  3291. TRUE  mid   pass ##  7     7 1-knw-093     3   843. TRUE  high  fail ##  8     4 5-boe-639     2  1036. FALSE low   fail ##  9     3 5-bce-642     9   838. FALSE high  fail ## 10     3 5-bce-642     9   838. FALSE high  fail ## 11     4 2-dmx-010     7   834. TRUE  low   fail ## 12     2 7-dmx-010     8   108. FALSE low   fail ## 13     1 3-dka-303    NA  2230. TRUE  high  pass agent %>%   get_sundered_data(     type = \"combined\",     pass_fail = c(TRUE, FALSE)   ) ## # A tibble: 13 × 7 ##        a b             c      d e     f     .pb_combined ##    <int> <chr>     <dbl>  <dbl> <lgl> <chr> <lgl> ##  1     2 1-bcd-345     3  3423. TRUE  high  TRUE ##  2     3 5-egh-163     8 10000. TRUE  low   TRUE ##  3     6 8-kdg-938     3  2343. TRUE  high  FALSE ##  4     2 5-jdo-903    NA  3892. FALSE mid   TRUE ##  5     8 3-ldm-038     7   284. TRUE  low   FALSE ##  6     4 2-dhe-923     4  3291. TRUE  mid   TRUE ##  7     7 1-knw-093     3   843. TRUE  high  FALSE ##  8     4 5-boe-639     2  1036. FALSE low   FALSE ##  9     3 5-bce-642     9   838. FALSE high  FALSE ## 10     3 5-bce-642     9   838. FALSE high  FALSE ## 11     4 2-dmx-010     7   834. TRUE  low   FALSE ## 12     2 7-dmx-010     8   108. FALSE low   FALSE ## 13     1 3-dka-303    NA  2230. TRUE  high  TRUE agent %>%   get_sundered_data(     type = \"combined\",     pass_fail = 0:1   ) ## # A tibble: 13 × 7 ##        a b             c      d e     f     .pb_combined ##    <int> <chr>     <dbl>  <dbl> <lgl> <chr>        <int> ##  1     2 1-bcd-345     3  3423. TRUE  high             0 ##  2     3 5-egh-163     8 10000. TRUE  low              0 ##  3     6 8-kdg-938     3  2343. TRUE  high             1 ##  4     2 5-jdo-903    NA  3892. FALSE mid              0 ##  5     8 3-ldm-038     7   284. TRUE  low              1 ##  6     4 2-dhe-923     4  3291. TRUE  mid              0 ##  7     7 1-knw-093     3   843. TRUE  high             1 ##  8     4 5-boe-639     2  1036. FALSE low              1 ##  9     3 5-bce-642     9   838. FALSE high             1 ## 10     3 5-bce-642     9   838. FALSE high             1 ## 11     4 2-dmx-010     7   834. TRUE  low              1 ## 12     2 7-dmx-010     8   108. FALSE low              1 ## 13     1 3-dka-303    NA  2230. TRUE  high             0"},{"path":"https://rstudio.github.io/pointblank/reference/get_sundered_data.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Sunder the data, splitting it into 'pass' and 'fail' pieces — get_sundered_data","text":"8-3","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/get_tt_param.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a parameter value from a summary table — get_tt_param","title":"Get a parameter value from a summary table — get_tt_param","text":"get_tt_param() function can help obtain single parameter value summary table generated tt_*() functions tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_tbl_colnames(). following parameters used depending input tbl: tt_summary_stats(): \"min\", \"p05\", \"q_1\", \"med\", \"q_3\", \"p95\", \"max\", \"iqr\", \"range\" tt_string_info(): \"length_mean\", \"length_min\", \"length_max\" tt_tbl_dims(): \"rows\", \"columns\" tt_tbl_colnames(): integer present .param. column tt_summary_stats() tt_string_info() functions generate summary tables columns mirror numeric character columns input tables, respectively. reason, column name must supplied column argument get_tt_param().","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_tt_param.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a parameter value from a summary table — get_tt_param","text":"","code":"get_tt_param(tbl, param, column = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/get_tt_param.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a parameter value from a summary table — get_tt_param","text":"tbl Summary table generated specific transformer functions obj:<tbl_*> // required summary table generated either tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_tbl_colnames() functions. param Parameter name scalar<character> // required parameter name associated value gotten. parameter names always available first column (.param.) summary table obtained tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_tbl_colnames(). column target column scalar<character> // required (select cases) column summary table data value obtained. must supplied summary tables generated tt_summary_stats() tt_string_info() (tt_tbl_dims() tt_tbl_colnames() functions always generate two-column summary table).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_tt_param.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a parameter value from a summary table — get_tt_param","text":"scalar value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/get_tt_param.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a parameter value from a summary table — get_tt_param","text":"Get summary statistics first quarter game_revenue dataset included pointblank package.   Sometimes need single value table generated tt_summary_stats() function. , can use get_tt_param() function. wanted test whether maximum session duration rest time period (remaining 0.75) never higher first quarter year, can supply value stats_tbl test_col_vals_lte():","code":"stats_tbl <-   game_revenue %>%   tt_time_slice(slice_point = 0.25) %>%   tt_summary_stats()  stats_tbl #> # A tibble: 9 x 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0.02              5.1 #> 2 p05             0.03             11 #> 3 q_1             0.08             17.2 #> 4 med             0.28             28.3 #> 5 q_3             1.37             32 #> 6 p95            40.0              37.1 #> 7 max           143.               41 #> 8 iqr             1.28             14.8 #> 9 range         143.               35.9 game_revenue %>%   tt_time_slice(     slice_point = 0.25,     keep = \"right\"   ) %>%   test_col_vals_lte(     columns = session_duration,     value = get_tt_param(       tbl = stats_tbl,       param = \"max\",       column = \"session_duration\"     )   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/get_tt_param.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get a parameter value from a summary table — get_tt_param","text":"12-7","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/has_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if one or more columns exist in a table — has_columns","title":"Determine if one or more columns exist in a table — has_columns","text":"utility function can help easily determine whether column specified name present table object. function works well enough table object can also used part formula validation function's active argument. Using active = ~ . %>% has_columns(column_1) means validation step inactive target table contain column named column_1. can also use multiple columns c(), active = ~ . %>% has_columns(c(column_1, column_2)) validation step make inactive interrogate() time unless columns column_1 column_2 present.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/has_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if one or more columns exist in a table — has_columns","text":"","code":"has_columns(x, columns)"},{"path":"https://rstudio.github.io/pointblank/reference/has_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if one or more columns exist in a table — has_columns","text":"x data table obj:<tbl_*> // required input table. can data frame, tibble, tbl_dbi object, tbl_spark object. columns target columns <tidy-select> // required One columns column-selecting expressions. element checked match table x.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/has_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine if one or more columns exist in a table — has_columns","text":"length-1 logical vector.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/has_columns.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine if one or more columns exist in a table — has_columns","text":"small_table dataset package columns date_time, date, f columns.   has_columns() can check column existence using directly table.     Multiple column names can supplied. following TRUE columns present small_table.     possible use tidyselect helper well:     column h present, returns FALSE (specified columns need present obtain TRUE).     holds case tidyselect helpers. columns start \"h\", including starts_with(\"h\") returns FALSE entire check.     has_columns() function can useful expressions involve target table, especially uncertain table contain column involved validation. following agent-based validation, first two steps 'active' columns checked expressions present. third step becomes inactive column j (without active statement get evaluation failure agent report).   agent's x-list, can verify evaluation error (evaluation , really) occurred. third value, representative third validation step, actually NA instead FALSE step became inactive.","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high small_table %>% has_columns(columns = date) ## [1] TRUE small_table %>% has_columns(columns = c(a, b)) ## [1] TRUE small_table %>% has_columns(columns = c(a, starts_with(\"b\"))) ## [1] TRUE small_table %>% has_columns(columns = c(a, h)) ## [1] FALSE small_table %>% has_columns(columns = starts_with(\"h\")) small_table %>% has_columns(columns = c(a, starts_with(\"h\"))) ## [1] FALSE ## [1] FALSE agent <-   create_agent(     tbl = small_table,     tbl_name = \"small_table\"   ) %>%   col_vals_gt(     columns = c, value = vars(a),     active = ~ . %>% has_columns(c(a, c))   ) %>%   col_vals_lt(     columns = h, value = vars(d),     preconditions = ~ . %>% dplyr::mutate(h = d - a),     active = ~ . %>% has_columns(c(a, d))   ) %>%   col_is_character(     columns = j,     active = ~ . %>% has_columns(j)   ) %>%   interrogate() x_list <- get_agent_x_list(agent = agent)  x_list$eval_warning ## [1] FALSE FALSE    NA"},{"path":"https://rstudio.github.io/pointblank/reference/has_columns.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Determine if one or more columns exist in a table — has_columns","text":"13-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/incorporate.html","id":null,"dir":"Reference","previous_headings":"","what":"Given an informant object, update and incorporate table snippets — incorporate","title":"Given an informant object, update and incorporate table snippets — incorporate","text":"informant object number snippets available (using info_snippet()) strings use (using info_*() functions {<snippet_name>} text elements), process incorporating aspects table info text can occur using incorporate() function. , information fully updated (getting current state table dimensions, re-rendering info text, etc.) can print informant object use get_informant_report() function see information report.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/incorporate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Given an informant object, update and incorporate table snippets — incorporate","text":"","code":"incorporate(informant)"},{"path":"https://rstudio.github.io/pointblank/reference/incorporate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Given an informant object, update and incorporate table snippets — incorporate","text":"informant pointblank informant object obj:<ptblank_informant> // required pointblank informant object commonly created use create_informant() function.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/incorporate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Given an informant object, update and incorporate table snippets — incorporate","text":"ptblank_informant object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/incorporate.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Given an informant object, update and incorporate table snippets — incorporate","text":"Take small_table assign changing_table (modify later):   Use create_informant() generate informant object changing_table given tbl argument leading ~ (ensures table fetched time needed, instead statically stored object). add two snippets info_snippet(), add information info_columns() info_section() functions use incorporate() work snippets info text.   can print resulting object see information report.    modify test_table give rows extra column.   Using incorporate() cause snippets reprocessed accordingly content report updated keep current state changing_table.   printed , also see row column counts header updated reflect new dimensions target table. Furthermore, info text ROWS section updated text (\"26 rows available.\").","code":"changing_table <- small_table  changing_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high informant <-   create_informant(     tbl = ~ changing_table,     tbl_name = \"changing_table\",     label = \"`informant()` example\"   ) %>%   info_snippet(     snippet_name = \"row_count\",     fn = ~ . %>% nrow()   ) %>%   info_snippet(     snippet_name = \"col_count\",     fn = ~ . %>% ncol()   ) %>%   info_columns(     columns = a,     info = \"In the range of 1 to 10. ((SIMPLE))\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = date,     info = \"The date part of `date_time`. ((CALC))\"   ) %>%   info_section(     section_name = \"rows\",     row_count = \"There are {row_count} rows available.\"   ) %>%   incorporate() informant changing_table <-   dplyr::bind_rows(changing_table, changing_table) %>%   dplyr::mutate(h = a + c) informant <- informant %>% incorporate() informant"},{"path":"https://rstudio.github.io/pointblank/reference/incorporate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Given an informant object, update and incorporate table snippets — incorporate","text":"7-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/info_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Add information that focuses on aspects of a data table's columns — info_columns","title":"Add information that focuses on aspects of a data table's columns — info_columns","text":"Upon creation informant object (create_informant() function), two sections containing properties: (1) 'table' (2) 'columns'. 'columns' section initialized table's column names types (_type). Beyond , useful provide details nature column can info_columns() function. single column (multiple columns) targeted, series named arguments (form entry_name = \"*info text*.\") serves additional information column columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add information that focuses on aspects of a data table's columns — info_columns","text":"","code":"info_columns(x, columns, ..., .add = TRUE)"},{"path":"https://rstudio.github.io/pointblank/reference/info_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add information that focuses on aspects of a data table's columns — info_columns","text":"x pointblank informant object obj:<ptblank_informant> // required pointblank informant object commonly created use create_informant() function. columns target columns vector<character>|vars(<columns>) // required column set columns focus . Can defined column name quotes (e.g., \"<column_name>\"), one column names vars() (e.g., vars(<column_name>)), select helper (e.g., starts_with(\"date\")). ... Information entries <info-text expressions> // required Information entries series named arguments. names refer subsection titles within COLUMN -> <COLUMN_NAME> RHS contains info text (informational text can written Markdown styled Text Tricks). .add Add existing info text scalar<logical> // default: TRUE new text added existing text? TRUE default; setting FALSE replaces existing text property.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add information that focuses on aspects of a data table's columns — info_columns","text":"ptblank_informant object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_columns.html","id":"info-text","dir":"Reference","previous_headings":"","what":"Info Text","title":"Add information that focuses on aspects of a data table's columns — info_columns","text":"info text used info_*() functions readily accepts Markdown formatting, , Text Tricks can used spice presentation. Markdown links written < link url > [ link text ]( link url ) get nicely-styled links. dates expressed ISO-8601 standard parentheses, \"(2004-12-01)\", styled font variation (monospaced) underlined purple. Spans text can converted label-style text using: (1) double parentheses around text rectangular border ((label text)), (2) triple parentheses around text rounded-rectangular border like (((label text))). CSS style rules can applied spans info text following form: [[ info text ]]<< CSS style rules >> example practice suppose like change color text red make font appear somewhat thinner. variation following might used: \"[[factor]]<<color: red; font-weight: 300;>> value.\" quite CSS style rules can used great effect. might like: color: <color value>; (text color) background-color: <color value>; (text's background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); examples, 'length value' refers CSS length can expressed different units measure (e.g., 12px, 1em, etc.). lengths can expressed positive negative values (e.g., letter-spacing). Color values can expressed ways, common form hexadecimal color values CSS color names.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_columns.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Add information that focuses on aspects of a data table's columns — info_columns","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). way information table columns represented YAML works like : info text goes subsections YAML keys named columns, part top-level columns key. example several calls info_columns() expressed R code result corresponds YAML representation.   Subsections represented column names automatically generated creating informant. Within , can multiple subsections used holding info text column. subsections used across different columns needn't either, commonality enforced presence _type key (automatically updated every incorporate() invocation). safest use single quotation marks around info text directly editing YAML file. Note Markdown formatting info snippet placeholders (shown {snippet_1}, see info_snippet() information) preserved YAML. Markdown HTML conversion done printing informant (invoking get_informant_report() informant) processing snippets (generation insertion) done using incorporate() function. Thus, source text always maintained YAML representation never written processed form.","code":"# R statement informant %>%   info_columns(     columns = date_time,     info = \"*info text* 1.\"   ) %>%   info_columns(     columns = date,     info = \"*info text* 2.\"   ) %>%   info_columns(     columns = item_count,     info = \"*info text* 3. Statistics: {snippet_1}.\"   ) %>%   info_columns(     columns = c(date, date_time),     info = \"UTC time.\"   )  # YAML representation columns:   date_time:     _type: POSIXct, POSIXt     info: '*info text* 1. UTC time.'   date:     _type: Date     info: '*info text* 2. UTC time.'   item_count:     _type: integer     info: '*info text* 3. Statistics: {snippet_1}.'"},{"path":"https://rstudio.github.io/pointblank/reference/info_columns.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add information that focuses on aspects of a data table's columns — info_columns","text":"Create pointblank informant object create_informant(). can specify tbl ~ followed statement gets small_table dataset.   can add info text describe table various info_*() functions. example, use info_columns() multiple times describe columns small_table dataset. Note info text calls additive existing content inside various subsections (.e., text appended overwrite existing lands area).   Upon printing informant object, see additions made 'Columns' section.","code":"informant <-   create_informant(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) informant <-   informant %>%   info_columns(     columns = a,     info = \"In the range of 1 to 10. ((SIMPLE))\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = date,     info = \"The date part of `date_time`. ((CALC))\"   ) informant"},{"path":"https://rstudio.github.io/pointblank/reference/info_columns.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Add information that focuses on aspects of a data table's columns — info_columns","text":"3-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/info_columns_from_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Add column information from another data table — info_columns_from_tbl","title":"Add column information from another data table — info_columns_from_tbl","text":"info_columns_from_tbl() function wrapper around info_columns() function useful wish apply info text columns information already exists data frame (form can readily coaxed data frame). form input tbl (one contains column metadata) basic requirements: data frame must two columns columns must class character first column contain column names second contain info text column matches across tables (.e., tbl target table informant) new entry \"info\" property. Empty missing info text pruned tbl.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_columns_from_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add column information from another data table — info_columns_from_tbl","text":"","code":"info_columns_from_tbl(x, tbl, .add = TRUE)"},{"path":"https://rstudio.github.io/pointblank/reference/info_columns_from_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add column information from another data table — info_columns_from_tbl","text":"x pointblank informant object obj:<ptblank_informant> // required pointblank informant object commonly created use create_informant() function. tbl Metadata table column information obj:<tbl_*> // required two-column data frame contains metadata target table informant object. .add Add existing info text scalar<logical> // default: TRUE new text added existing text? TRUE default; setting FALSE replaces existing text \"info\" property.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_columns_from_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add column information from another data table — info_columns_from_tbl","text":"ptblank_informant object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_columns_from_tbl.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add column information from another data table — info_columns_from_tbl","text":"Create pointblank informant object create_informant(). can specify tbl ~ followed statement gets game_revenue dataset.   can add info text describe data various columns table using info_columns() information another table (info_columns_from_tbl()). , latter. game_revenue_info dataset included pointblank contains metadata game_revenue.   info_columns_from_tbl() function takes table object first column column names second contains info text.   Upon printing informant object, see additions made 'Columns' section info_columns_from_tbl(tbl = game_revenue_info) call.    can continue add info text describe columns since process additive. info_columns_from_tbl() function populates info subsection calls info_columns() also target info subsection append text. , add content item_revenue acquisition columns view updated report.","code":"informant <-   create_informant(     tbl = ~ game_revenue,     tbl_name = \"game_revenue\",     label = \"An example.\"   ) game_revenue_info #> # A tibble: 11 x 2 #>    column           info #>    <chr>            <chr> #>  1 player_id        A `character` column with unique identifiers for each user/~ #>  2 session_id       A `character` column that contains unique identifiers for e~ #>  3 session_start    A date-time column that indicates when the session (contain~ #>  4 time             A date-time column that indicates exactly when the player p~ #>  5 item_type        A `character` column that provides the class of the item pu~ #>  6 item_name        A `character` column that provides the name of the item pur~ #>  7 item_revenue     A `numeric` column with the revenue amounts per item purcha~ #>  8 session_duration A `numeric` column that states the length of the session (i~ #>  9 start_day        A `Date` column that provides the date of first login for t~ #> 10 acquisition      A `character` column that provides the method of acquisitio~ #> 11 country          A `character` column that provides the probable country of ~ informant <-   informant %>%   info_columns_from_tbl(tbl = game_revenue_info) informant informant <-   informant %>%   info_columns(     columns = item_revenue,     info = \"Revenue reported in USD.\"   ) %>%   info_columns(     columns = acquisition,     `top list` = \"{top5_aq}\"   ) %>%   info_snippet(     snippet_name = \"top5_aq\",     fn = snip_list(column = \"acquisition\")   ) %>%   incorporate()  informant"},{"path":"https://rstudio.github.io/pointblank/reference/info_columns_from_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Add column information from another data table — info_columns_from_tbl","text":"3-3","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/info_section.html","id":null,"dir":"Reference","previous_headings":"","what":"Add information that focuses on some key aspect of the data table — info_section","title":"Add information that focuses on some key aspect of the data table — info_section","text":"info_tabular() info_columns() functions allow us add/modify info text specific sections, info_section() makes possible add sections choosing information make sense sections. Define section_name provide series named arguments (form entry_name = \"*info text*.\") build informational content section.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_section.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add information that focuses on some key aspect of the data table — info_section","text":"","code":"info_section(x, section_name, ...)"},{"path":"https://rstudio.github.io/pointblank/reference/info_section.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add information that focuses on some key aspect of the data table — info_section","text":"x pointblank informant object obj:<ptblank_informant> // required pointblank informant object commonly created use create_informant() function. section_name section name scalar<character> // required name section information pertains. ... Information entries <info-text expressions> // required Information entries series named arguments. names refer subsection titles within section defined section_name RHS info text (informational text can written Markdown styled Text Tricks).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_section.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add information that focuses on some key aspect of the data table — info_section","text":"ptblank_informant object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_section.html","id":"info-text","dir":"Reference","previous_headings":"","what":"Info Text","title":"Add information that focuses on some key aspect of the data table — info_section","text":"info text used info_*() functions readily accepts Markdown formatting, , Text Tricks can used spice presentation. Markdown links written < link url > [ link text ]( link url ) get nicely-styled links. dates expressed ISO-8601 standard parentheses, \"(2004-12-01)\", styled font variation (monospaced) underlined purple. Spans text can converted label-style text using: (1) double parentheses around text rectangular border ((label text)), (2) triple parentheses around text rounded-rectangular border like (((label text))). CSS style rules can applied spans info text following form: [[ info text ]]<< CSS style rules >> example practice suppose like change color text red make font appear somewhat thinner. variation following might used: \"[[factor]]<<color: red; font-weight: 300;>> value.\" quite CSS style rules can used great effect. might like: color: <color value>; (text color) background-color: <color value>; (text's background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); examples, 'length value' refers CSS length can expressed different units measure (e.g., 12px, 1em, etc.). lengths can expressed positive negative values (e.g., letter-spacing). Color values can expressed ways, common form hexadecimal color values CSS color names.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_section.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Add information that focuses on some key aspect of the data table — info_section","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). Extra sections (.e., neither table columns sections) can generated filled info text using one calls info_section(). expressed R code YAML representation.   Subsections represented column names automatically generated creating informant. Within top-level sections (.e., History Additional Notes) can multiple subsections used holding info text. safest use single quotation marks around info text directly editing YAML file. Note Markdown formatting info snippet placeholders (shown {snippet}, see info_snippet() information) preserved YAML. Markdown HTML conversion done printing informant (invoking get_informant_report() informant) processing snippets (generation insertion) done using incorporate() function. Thus, source text always maintained YAML representation never written processed form.","code":"# R statement informant %>%   info_section(     section_name = \"History\",     Changes = \" - Change 1 - Change 2 - Change 3\",     `Last Update` = \"(2020-10-23) at 3:28 PM.\"   ) %>%   info_section(     section_name = \"Additional Notes\",     `Notes 1` = \"Notes with a {snippet}.\",     `Notes 2` = \"**Bold notes**.\"   )  # YAML representation History:   Changes: |2-      - Change 1     - Change 2     - Change 3   Last Update: (2020-10-23) at 3:28 PM. Additional Notes:   Notes 1: Notes with a {snippet}.   Notes 2: '**Bold notes**.'"},{"path":"https://rstudio.github.io/pointblank/reference/info_section.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add information that focuses on some key aspect of the data table — info_section","text":"Create pointblank informant object create_informant(). can specify tbl ~ followed statement gets small_table dataset.   informant typically 'Table' 'Columns' sections. can also create entirely different sections (follow ) properties using info_section() function. create subsection report called \"Notes\" add text two parts : \"creation\" \"usage\".   Upon printing informant object, see addition 'Notes' section information.","code":"informant <-   create_informant(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) informant <-   informant %>%   info_section(     section_name = \"Notes\",     creation = \"Dataset generated on (2020-01-15).\",     usage = \"`small_table %>% dplyr::glimpse()`\"   ) %>%   incorporate() informant"},{"path":"https://rstudio.github.io/pointblank/reference/info_section.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Add information that focuses on some key aspect of the data table — info_section","text":"3-4","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/info_snippet.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a useful text 'snippet' from the target table — info_snippet","title":"Generate a useful text 'snippet' from the target table — info_snippet","text":"Getting little snippets information table goes hand--hand mixing bits info table info. Call info_snippet() define snippet get target table. snippet definition supplied either formula, , pointblank-supplied snip_*() function. long know interact table extract information, can easily define snippets informant object. snippets defined, can insert info text defined info_*() functions (info_tabular(), info_columns(), info_section()). Use curly braces just snippet_name inside (e.g., \"column {n_cat} categories.\").","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_snippet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a useful text 'snippet' from the target table — info_snippet","text":"","code":"info_snippet(x, snippet_name, fn)"},{"path":"https://rstudio.github.io/pointblank/reference/info_snippet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a useful text 'snippet' from the target table — info_snippet","text":"x pointblank informant object obj:<ptblank_informant> // required pointblank informant object commonly created use create_informant() function. snippet_name snippet name scalar<character> // required name snippet, used interpolating result snippet formula info text defined info_*() function. fn Function snippet text generation <function> // required formula obtains snippet data target table. best use leading dot (.) stands table use pipes construct series operations performed table (e.g., ~ . %>% dplyr::pull(column_2) %>% max(na.rm = TRUE)). long result length-1 vector, 'll likely valid insertion info text. Alternatively, snip_*() function can used (functions always return formula suitable types data sources).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_snippet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a useful text 'snippet' from the target table — info_snippet","text":"ptblank_informant object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_snippet.html","id":"snip-functions-provided-in-pointblank","dir":"Reference","previous_headings":"","what":"Snip functions provided in pointblank","title":"Generate a useful text 'snippet' from the target table — info_snippet","text":"convenience, several snip_*() functions provided package work column data informant's target table. : snip_list(): get list column categories snip_stats(): get inline statistical summary snip_lowest(): get lowest value column snip_highest() : get highest value column understood target table , column functions necessary obtaining resultant text.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_snippet.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Generate a useful text 'snippet' from the target table — info_snippet","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). Snippets stored YAML representation expressed R code YAML output (showing meta_snippets columns keys demonstrate relationship ).","code":"# R statement informant %>%   info_columns(     columns = date_time,     `Latest Date` = \"The latest date is {latest_date}.\"   ) %>%   info_snippet(     snippet_name = \"latest_date\",     fn = ~ . %>% dplyr::pull(date) %>% max(na.rm = TRUE)   ) %>%   incorporate()  # YAML representation meta_snippets:   latest_date: ~. %>% dplyr::pull(date) %>% max(na.rm = TRUE) ... columns:   date_time:     _type: POSIXct, POSIXt     Latest Date: The latest date is {latest_date}.   date:     _type: Date   item_count:     _type: integer"},{"path":"https://rstudio.github.io/pointblank/reference/info_snippet.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a useful text 'snippet' from the target table — info_snippet","text":"Take small_table dataset included pointblank assign test_table. modify later.   Generate informant object, add two snippets info_snippet(), add information info_*() functions incorporate() snippets info text. first snippet made expression ~ . %>% nrow() (giving us number rows dataset) second uses snip_highest() function column (giving us highest value column).   can print informant object see information report.    modify test_table dplyr give rows extra column.   Using incorporate() informant object cause snippets reprocessed, , info text updated.","code":"test_table <- small_table informant <-   create_informant(     tbl = ~ test_table,     tbl_name = \"test_table\",     label = \"An example.\"   ) %>%   info_snippet(     snippet_name = \"row_count\",     fn = ~ . %>% nrow()   ) %>%   info_snippet(     snippet_name = \"max_a\",     fn = snip_highest(column = \"a\")   ) %>%   info_columns(     columns = a,     info = \"In the range of 1 to {max_a}. ((SIMPLE))\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = date,     info = \"The date part of `date_time`. ((CALC))\"   ) %>%   info_section(     section_name = \"rows\",     row_count = \"There are {row_count} rows available.\"   ) %>%   incorporate() informant test_table <-   dplyr::bind_rows(test_table, test_table) %>%   dplyr::mutate(h = a + c) informant <- informant %>% incorporate()  informant"},{"path":"https://rstudio.github.io/pointblank/reference/info_snippet.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Generate a useful text 'snippet' from the target table — info_snippet","text":"3-5","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/info_tabular.html","id":null,"dir":"Reference","previous_headings":"","what":"Add information that focuses on aspects of the data table as a whole — info_tabular","title":"Add information that focuses on aspects of the data table as a whole — info_tabular","text":"informant object created create_informant() function, two starter sections: (1) 'table' (2) 'columns'. 'table' section contain properties upon creation, supplied table name (name) table dimensions (_columns _rows). can add table-based properties info_tabular() function. providing series named arguments (form entry_name = \"*info text*.\"), can add information makes sense describing table whole.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_tabular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add information that focuses on aspects of the data table as a whole — info_tabular","text":"","code":"info_tabular(x, ...)"},{"path":"https://rstudio.github.io/pointblank/reference/info_tabular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add information that focuses on aspects of the data table as a whole — info_tabular","text":"x pointblank informant object obj:<ptblank_informant> // required pointblank informant object commonly created use create_informant() function. ... Information entries <info-text expressions> // required Information entries series named arguments. names refer subsection titles within TABLE section values info text (informational text can written Markdown styled Text Tricks).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_tabular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add information that focuses on aspects of the data table as a whole — info_tabular","text":"ptblank_informant object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_tabular.html","id":"info-text","dir":"Reference","previous_headings":"","what":"Info Text","title":"Add information that focuses on aspects of the data table as a whole — info_tabular","text":"info text used info_*() functions readily accepts Markdown formatting, , Text Tricks can used spice presentation. Markdown links written < link url > [ link text ]( link url ) get nicely-styled links. dates expressed ISO-8601 standard parentheses, \"(2004-12-01)\", styled font variation (monospaced) underlined purple. Spans text can converted label-style text using: (1) double parentheses around text rectangular border ((label text)), (2) triple parentheses around text rounded-rectangular border like (((label text))). CSS style rules can applied spans info text following form: [[ info text ]]<< CSS style rules >> example practice suppose like change color text red make font appear somewhat thinner. variation following might used: \"[[factor]]<<color: red; font-weight: 300;>> value.\" quite CSS style rules can used great effect. might like: color: <color value>; (text color) background-color: <color value>; (text's background color) text-decoration: (overline | line-| underline); text-transform: (uppercase | lowercase | capitalize); letter-spacing: <+/- length value>; word-spacing: <+/- length value>; font-style: (normal | italic | oblique); font-weight: (normal | bold | 100-900); font-variant: (normal | bold | 100-900); border: <color value> <length value> (solid | dashed | dotted); examples, 'length value' refers CSS length can expressed different units measure (e.g., 12px, 1em, etc.). lengths can expressed positive negative values (e.g., letter-spacing). Color values can expressed ways, common form hexadecimal color values CSS color names.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/info_tabular.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Add information that focuses on aspects of the data table as a whole — info_tabular","text":"pointblank informant can written YAML yaml_write() resulting YAML can used regenerate informant (yaml_read_informant()) perform 'incorporate' action using target table (via yaml_informant_incorporate()). info_tabular() represented YAML, info text goes subsections top-level table key. example call info_tabular() expressed R code corresponding YAML representation. R statement:   YAML representation:   Subsection titles defined info_tabular() can set backticks syntactically correct argument name without (e.g., using spaces, hyphens, etc.). safest use single quotation marks around info text directly editing YAML file. Note Markdown formatting info snippet placeholders (shown {snippet_1}, see info_snippet() information) preserved YAML. Markdown HTML conversion done printing informant (invoking get_informant_report() informant) processing snippets (generation insertion) done using incorporate() function. Thus, source text always maintained YAML representation never written processed form.","code":"informant %>%   info_tabular(     section_1 = \"*info text* 1.\",     `section 2` = \"*info text* 2 and {snippet_1}\"   ) table:   _columns: 23   _rows: 205.0   _type: tbl_df   section_1: '*info text* 1.'   section 2: '*info text* 2 and {snippet_1}'"},{"path":"https://rstudio.github.io/pointblank/reference/info_tabular.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add information that focuses on aspects of the data table as a whole — info_tabular","text":"Create pointblank informant object create_informant(). can specify tbl ~ followed statement gets small_table dataset.   can add info text describe table various info_*() functions. example, use info_tabular() generally describe small_table dataset.   Upon printing informant object, see additions made 'Table' section report.","code":"informant <-   create_informant(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) informant <-   informant %>%   info_tabular(     `Row Definition` = \"A row has randomized values.\",     Source = c(       \"- From the **pointblank** package.\",       \"- [https://rstudio.github.io/pointblank/]()\"      )    ) informant"},{"path":"https://rstudio.github.io/pointblank/reference/info_tabular.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Add information that focuses on aspects of the data table as a whole — info_tabular","text":"3-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/interrogate.html","id":null,"dir":"Reference","previous_headings":"","what":"Given an agent that has a validation plan, perform an interrogation — interrogate","title":"Given an agent that has a validation plan, perform an interrogation — interrogate","text":"agent information (.e., validation plan series validation steps), interrogation process can occur according plan. , agent gathered intel, can use functions like get_agent_report() all_passed() understand interrogation went .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/interrogate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Given an agent that has a validation plan, perform an interrogation — interrogate","text":"","code":"interrogate(   agent,   extract_failed = TRUE,   extract_tbl_checked = TRUE,   get_first_n = NULL,   sample_n = NULL,   sample_frac = NULL,   sample_limit = 5000,   show_step_label = FALSE,   progress = interactive() )"},{"path":"https://rstudio.github.io/pointblank/reference/interrogate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Given an agent that has a validation plan, perform an interrogation — interrogate","text":"agent pointblank agent object obj:<ptblank_agent> // required pointblank agent object commonly created use create_agent() function. extract_failed Collect failed rows data extracts scalar<logical> // default: TRUE option collect rows pass particular validation step. default TRUE options allow fine control rows collected. extract_tbl_checked Collect validation results step scalar<logical> // default: TRUE option collect processed data frames produced executing validation steps. information necessary functions (e.g., get_sundered_data()), may grow large size. opt attaching data agent, set argument FALSE. get_first_n Get first n values scalar<integer> // default: NULL (optional) option collect non-passing rows chosen, option collect first n rows . Supply number rows extract top non-passing rows table (ordering data original table retained). sample_n Sample n values scalar<integer> // default: NULL (optional) option collect non-passing rows chosen, option allows sampling n rows. Supply number rows sample non-passing rows table. n greater number non-passing rows, rows returned. sample_frac Sample fraction values scalar<numeric> // default: NULL (optional) option collect non-passing rows chosen, option allows sampling fraction rows. Provide number range 0 1. number rows return may extremely large (especially querying remote databases), however, sample_limit option apply hard limit returned rows. sample_limit Row limit sampling scalar<integer> // default: 5000 value limits possible number rows returned sampling non-passing rows using sample_frac option. show_step_label Show step labels progress scalar<logical> // default: FALSE Whether show label value validation step console. progress Show interrogation progress scalar<logical> // default: interactive() Whether show progress agent's interrogation console. Defaults TRUE interactive sessions.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/interrogate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Given an agent that has a validation plan, perform an interrogation — interrogate","text":"ptblank_agent object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/interrogate.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Given an agent that has a validation plan, perform an interrogation — interrogate","text":"Create simple table two columns numerical values.   Validate values column tbl always less 5. Using interrogate() carries validation plan completes whole process.   can print resulting object see validation report.","code":"tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 0, 3)   )  tbl #> # A tibble: 6 x 2 #>       a     b #>   <dbl> <dbl> #> 1     5     7 #> 2     7     1 #> 3     6     0 #> 4     5     0 #> 5     8     0 #> 6     7     3 agent <-   create_agent(     tbl = tbl,     label = \"`interrogate()` example\"   ) %>%   col_vals_gt(columns = a, value = 5) %>%   interrogate() agent"},{"path":"https://rstudio.github.io/pointblank/reference/interrogate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Given an agent that has a validation plan, perform an interrogation — interrogate","text":"6-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/log4r_step.html","id":null,"dir":"Reference","previous_headings":"","what":"Enable logging of failure conditions at the validation step level — log4r_step","title":"Enable logging of failure conditions at the validation step level — log4r_step","text":"log4r_step() function can used action action_levels() function (list component fns list). Place call function every failure condition produce log (.e., warn, stop, notify). failure condition highest severity given validation step produce log entry (skipping failure conditions lower severity) long call log4r_step() present.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/log4r_step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Enable logging of failure conditions at the validation step level — log4r_step","text":"","code":"log4r_step(x, message = NULL, append_to = \"pb_log_file\")"},{"path":"https://rstudio.github.io/pointblank/reference/log4r_step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Enable logging of failure conditions at the validation step level — log4r_step","text":"x reference x-list object prepared agent. version x-list generated via get_agent_x_list(<agent>, = <step>) except version internally generated hence available internal evaluation context. message message use log entry. provided, default glue string used messaging. dynamic since internal glue::glue() call occurs environment x, x-list constrained validation step. default message, used message = NULL glue string \"Step {x$} exceeded {level} failure threshold (f_failed = {x$f_failed}) ['{x$type}']\". can seen, custom message can crafted uses elements x-list {x$<component>} construction. append_to file log entries warn level appended. can alternatively one log4r appenders.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/log4r_step.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Enable logging of failure conditions at the validation step level — log4r_step","text":"Nothing returned however log files may written specific conditions.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/log4r_step.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Enable logging of failure conditions at the validation step level — log4r_step","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). example log4r_step() can expressed R code (within action_levels(), inside create_agent()) corresponding YAML representation. R statement:   YAML representation:   need preview transformation agent YAML (without committing anything disk), use yaml_agent_string() function. already .yml file holds agent, can get glimpse R expressions used regenerate agent yaml_agent_show_exprs().","code":"create_agent(   tbl = ~ small_table,   tbl_name = \"small_table\",   label = \"An example.\",   actions = action_levels(     warn_at = 1,     fns = list(       warn = ~ log4r_step(         x, append_to = \"example_log\"       )     )   ) ) type: agent tbl: ~small_table tbl_name: small_table label: An example. lang: en locale: en actions:   warn_count: 1.0   fns:     warn: ~log4r_step(x, append_to = \"example_log\") steps: []"},{"path":"https://rstudio.github.io/pointblank/reference/log4r_step.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Enable logging of failure conditions at the validation step level — log4r_step","text":"example provided , use included small_table dataset. also going create action_levels() list object since useful demonstrating logging scenario. threshold warn state, , associated function invoked whenever warn state entered. , function call log4r_step() invoked whenever one failing test unit.   Within action_levels()-produced object, important match things : notice warn_at given threshold list functions given fns warn component. Printing al show us settings action_levels object:   create agent small_table target table. apply action_levels object created al, add two validation steps, interrogate() data.    agent report, can see steps yielded warnings upon interrogation (.e., filled yellow circles W column). immediately apparent entering warn state validation step interrogation, log4r_step() function call twice invoked! generated \"example_log\" file working directory (since present interrogation) log entries appended file. contents file:","code":"al <-   action_levels(     warn_at = 1,     fns = list(       warn = ~ log4r_step(         x, append_to = \"example_log\"       )     )   ) al #> -- The `action_levels` settings #> WARN failure threshold of 1test units. #> \\fns\\ ~ log4r_step(x, append_to = \"example_log\") #> ---- agent <-   create_agent(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al   ) %>%   col_vals_gt(columns = d, 300) %>%   col_vals_in_set(columns = f, c(\"low\", \"high\")) %>%   interrogate()  agent WARN  [2022-06-28 10:06:01] Step 1 exceeded the WARN failure threshold   (f_failed = 0.15385) ['col_vals_gt'] WARN  [2022-06-28 10:06:01] Step 2 exceeded the WARN failure threshold   (f_failed = 0.15385) ['col_vals_in_set']"},{"path":"https://rstudio.github.io/pointblank/reference/log4r_step.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Enable logging of failure conditions at the validation step level — log4r_step","text":"5-1","code":""},{"path":"https://rstudio.github.io/pointblank/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::[\\%>\\%][magrittr::\\%>\\%] details.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://rstudio.github.io/pointblank/reference/print.action_levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the action_levels object — print.action_levels","title":"Print the action_levels object — print.action_levels","text":"function allow action_levels nicely printed.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.action_levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the action_levels object — print.action_levels","text":"","code":"# S3 method for class 'action_levels' print(x, ...)"},{"path":"https://rstudio.github.io/pointblank/reference/print.action_levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the action_levels object — print.action_levels","text":"x object class action_levels. ... additional parameters.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the ptblank_agent object — print.ptblank_agent","title":"Print the ptblank_agent object — print.ptblank_agent","text":"function allow agent object print useful HTML-based report.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the ptblank_agent object — print.ptblank_agent","text":"","code":"# S3 method for class 'ptblank_agent' print(x, view = interactive(), ...)"},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the ptblank_agent object — print.ptblank_agent","text":"x object class ptblank_agent. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_informant.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the ptblank_informant object — print.ptblank_informant","title":"Print the ptblank_informant object — print.ptblank_informant","text":"function allow informant object print useful HTML-based report.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_informant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the ptblank_informant object — print.ptblank_informant","text":"","code":"# S3 method for class 'ptblank_informant' print(x, view = interactive(), ...)"},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_informant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the ptblank_informant object — print.ptblank_informant","text":"x informant object class ptblank_informant. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_multiagent.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the ptblank_multiagent object — print.ptblank_multiagent","title":"Print the ptblank_multiagent object — print.ptblank_multiagent","text":"function allow multiagent object print useful HTML-based report.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_multiagent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the ptblank_multiagent object — print.ptblank_multiagent","text":"","code":"# S3 method for class 'ptblank_multiagent' print(x, view = interactive(), ...)"},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_multiagent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the ptblank_multiagent object — print.ptblank_multiagent","text":"x object class ptblank_multiagent. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_multiagent_report.long.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the ptblank_multiagent_report.long object — print.ptblank_multiagent_report.long","title":"Print the ptblank_multiagent_report.long object — print.ptblank_multiagent_report.long","text":"function print ptblank_multiagent_report.long object, HTML-based report.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_multiagent_report.long.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the ptblank_multiagent_report.long object — print.ptblank_multiagent_report.long","text":"","code":"# S3 method for class 'ptblank_multiagent_report.long' print(x, view = interactive(), ...)"},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_multiagent_report.long.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the ptblank_multiagent_report.long object — print.ptblank_multiagent_report.long","text":"x object class ptblank_multiagent_report.long. view value print()s browse argument. ... additional parameters.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_tbl_scan.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the ptblank_tbl_scan object — print.ptblank_tbl_scan","title":"Print the ptblank_tbl_scan object — print.ptblank_tbl_scan","text":"function print ptblank_tbl_scan object, HTML-based report.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_tbl_scan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the ptblank_tbl_scan object — print.ptblank_tbl_scan","text":"","code":"# S3 method for class 'ptblank_tbl_scan' print(x, ..., view = interactive())"},{"path":"https://rstudio.github.io/pointblank/reference/print.ptblank_tbl_scan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the ptblank_tbl_scan object — print.ptblank_tbl_scan","text":"x object class ptblank_tbl_scan. ... additional parameters. view value print()s browse argument.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.read_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the a table-prep formula — print.read_fn","title":"Print the a table-prep formula — print.read_fn","text":"function allow table-prep formula nicely printed.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.read_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the a table-prep formula — print.read_fn","text":"","code":"# S3 method for class 'read_fn' print(x, ...)"},{"path":"https://rstudio.github.io/pointblank/reference/print.read_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the a table-prep formula — print.read_fn","text":"x object class read_fn. ... additional parameters.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.tbl_store.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the tbl_store object — print.tbl_store","title":"Print the tbl_store object — print.tbl_store","text":"function allow tbl_store nicely printed.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.tbl_store.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the tbl_store object — print.tbl_store","text":"","code":"# S3 method for class 'tbl_store' print(x, ...)"},{"path":"https://rstudio.github.io/pointblank/reference/print.tbl_store.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the tbl_store object — print.tbl_store","text":"x object class tbl_store. ... additional parameters.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.x_list_i.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a single-step x-list to the console — print.x_list_i","title":"Print a single-step x-list to the console — print.x_list_i","text":"function print x-list object, single step, console.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.x_list_i.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a single-step x-list to the console — print.x_list_i","text":"","code":"# S3 method for class 'x_list_i' print(x, ...)"},{"path":"https://rstudio.github.io/pointblank/reference/print.x_list_i.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a single-step x-list to the console — print.x_list_i","text":"x x-list object class x_list_i. ... additional parameters.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.x_list_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Print an x-list comprising all validation steps to the console — print.x_list_n","title":"Print an x-list comprising all validation steps to the console — print.x_list_n","text":"function print x-list object, validation steps included, console.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/print.x_list_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print an x-list comprising all validation steps to the console — print.x_list_n","text":"","code":"# S3 method for class 'x_list_n' print(x, ...)"},{"path":"https://rstudio.github.io/pointblank/reference/print.x_list_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print an x-list comprising all validation steps to the console — print.x_list_n","text":"x x-list object class x_list_n. ... additional parameters.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/read_disk_multiagent.html","id":null,"dir":"Reference","previous_headings":"","what":"Read pointblank agents stored on disk as a multiagent — read_disk_multiagent","title":"Read pointblank agents stored on disk as a multiagent — read_disk_multiagent","text":"agent informant can written disk x_write_disk() function. useful later retrieving stored agent x_read_disk() also possible read series -disk agents read_disk_multiagent() function, creates ptblank_multiagent object. multiagent object can also generated via create_multiagent() function less convenient use one just using agents previously written disk.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/read_disk_multiagent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read pointblank agents stored on disk as a multiagent — read_disk_multiagent","text":"","code":"read_disk_multiagent(filenames = NULL, pattern = NULL, path = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/read_disk_multiagent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read pointblank agents stored on disk as a multiagent — read_disk_multiagent","text":"filenames File names vector<character> // default: NULL (optional) names files (holding agent objects) previously written x_write_disk(). pattern Regex pattern scalar<character> // default: NULL (optional) regex pattern accessing saved--disk agent files located directory (specified path argument). path File path scalar<character> // default: NULL (optional) path collection files. either optional case files specified filenames (path combined filenames), , required providing pattern file names.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/read_disk_multiagent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read pointblank agents stored on disk as a multiagent — read_disk_multiagent","text":"ptblank_multiagent object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/read_disk_multiagent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Read pointblank agents stored on disk as a multiagent — read_disk_multiagent","text":"10-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. blastula creds, creds_anonymous, creds_file, creds_key dplyr , case_when, vars rlang expr","code":""},{"path":"https://rstudio.github.io/pointblank/reference/remove_steps.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove one or more of an agent's validation steps — remove_steps","title":"Remove one or more of an agent's validation steps — remove_steps","text":"Validation steps can removed agent object use remove_steps() function. useful, instance, getting agent disk (via x_read_disk() function) omitting one steps agent's validation plan. Please note removing validation steps stored data extracts removed agent.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/remove_steps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove one or more of an agent's validation steps — remove_steps","text":"","code":"remove_steps(agent, i = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/remove_steps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove one or more of an agent's validation steps — remove_steps","text":"agent pointblank agent object obj:<ptblank_agent> // required pointblank agent object commonly created use create_agent() function. validation step number scalar<integer> // default: NULL (optional) validation step number, assigned validation step order definition. NULL (default) step removal occur index.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/remove_steps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove one or more of an agent's validation steps — remove_steps","text":"ptblank_agent object. ptblank_agent object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/remove_steps.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Remove one or more of an agent's validation steps — remove_steps","text":"9-7","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/remove_steps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove one or more of an agent's validation steps — remove_steps","text":"","code":"# Create an agent that has the # `small_table` object as the # target table, add a few # validation steps, and then use # `interrogate()` agent_1 <-    create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%   col_exists(columns = date) %>%   col_vals_regex(     columns = b,     regex = \"[0-9]-[a-z]{3}-[0-9]\"   ) %>%   interrogate()    # The second validation step has # been determined to be unneeded and # is to be removed; this can be done # by using `remove_steps()` with the # agent object agent_2 <-   agent_1 %>%   remove_steps(i = 2) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Does the row count match that of a different table? — row_count_match","title":"Does the row count match that of a different table? — row_count_match","text":"row_count_match() validation function, expect_row_count_match() expectation function, test_row_count_match() test function check whether row count target table matches comparison table. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation, single test unit hinges whether row counts two tables (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does the row count match that of a different table? — row_count_match","text":"","code":"row_count_match(   x,   count,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE,   tbl_compare = NULL )  expect_row_count_match(   object,   count,   preconditions = NULL,   threshold = 1,   tbl_compare = NULL )  test_row_count_match(   object,   count,   preconditions = NULL,   threshold = 1,   tbl_compare = NULL )"},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does the row count match that of a different table? — row_count_match","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). count count comparison scalar<numeric|integer>|obj:<tbl_*> // required Either literal value number rows, , table compare target table terms row count values. supplying comparison table, can either table object data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, table-prep formula (~ <tbl reading code>) function (function() <tbl reading code>) can used lazily read comparison table interrogation time. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). tbl_compare Deprecated Comparison table obj:<tbl_*> // default: NULL (optional) tbl_compare argument deprecated. Instead, use count. object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Does the row count match that of a different table? — row_count_match","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Does the row count match that of a different table? — row_count_match","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Does the row count match that of a different table? — row_count_match","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires operation target table row count comparison takes place. Using preconditions can useful times since since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed. Alternatively, function instead supplied.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Does the row count match that of a different table? — row_count_match","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Does the row count match that of a different table? — row_count_match","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. Using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Does the row count match that of a different table? — row_count_match","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Does the row count match that of a different table? — row_count_match","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Does the row count match that of a different table? — row_count_match","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). row_count_match() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call row_count_match() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   row_count_match(     count = ~ file_tbl(       file = from_github(         file = \"sj_all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       ),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `row_count_match()` step.\",     active = FALSE   ) steps: - row_count_match:     count: ~ file_tbl(       file = from_github(         file = \"sj_all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       )     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `row_count_match()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Does the row count match that of a different table? — row_count_match","text":"Create simple table three columns four rows values.   Create second table quite different number rows tbl.","code":"tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5),     b = c(7, 1, 0, 0),     c = c(1, 1, 1, 3)   )  tbl #> # A tibble: 4 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     7     1 #> 2     7     1     1 #> 3     6     0     1 #> 4     5     0     3 tbl_2 <-   dplyr::tibble(     e = c(\"a\", NA, \"a\", \"c\"),     f = c(2.6, 1.2, 0, NA)   )  tbl_2 #> # A tibble: 4 x 2 #>   e         f #>   <chr> <dbl> #> 1 a       2.6 #> 2 <NA>    1.2 #> 3 a       0 #> 4 c      NA"},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Does the row count match that of a different table? — row_count_match","text":"Validate count rows target table (tbl) matches comparison table (tbl_2).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   row_count_match(count = tbl_2) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Does the row count match that of a different table? — row_count_match","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>% row_count_match(count = tbl_2) #> # A tibble: 4 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     7     1 #> 2     7     1     1 #> 3     6     0     1 #> 4     5     0     3"},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Does the row count match that of a different table? — row_count_match","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_row_count_match(tbl, count = tbl_2)"},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Does the row count match that of a different table? — row_count_match","text":"test_*() form, get single logical value returned us.","code":"tbl %>% test_row_count_match(count = 4) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/row_count_match.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Does the row count match that of a different table? — row_count_match","text":"2-31","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":null,"dir":"Reference","previous_headings":"","what":"Are row data complete? — rows_complete","title":"Are row data complete? — rows_complete","text":"rows_complete() validation function, expect_rows_complete() expectation function, test_rows_complete() test function check whether rows contain NA/NULL values (optionally constrained selection specified columns). validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation, operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are row data complete? — rows_complete","text":"","code":"rows_complete(   x,   columns = tidyselect::everything(),   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_rows_complete(   object,   columns = tidyselect::everything(),   preconditions = NULL,   threshold = 1 )  test_rows_complete(   object,   columns = tidyselect::everything(),   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are row data complete? — rows_complete","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // default: everything() column-selecting expression, one use inside dplyr::select(). Specifies set column(s) completeness rows checked. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are row data complete? — rows_complete","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are row data complete? — rows_complete","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are row data complete? — rows_complete","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are row data complete? — rows_complete","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are row data complete? — rows_complete","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. Using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are row data complete? — rows_complete","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are row data complete? — rows_complete","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are row data complete? — rows_complete","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). rows_complete() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call rows_complete() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter. value columns necessary checking unique values across subset columns. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   rows_complete(     columns = c(a, b),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `rows_complete()` step.\",     active = FALSE   ) steps: - rows_complete:     columns: c(a, b)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `rows_complete()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are row data complete? — rows_complete","text":"Create simple table three columns numerical values.","code":"tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 8, 3),     c = c(1, 1, 1, 3, 3, 3)   )  tbl #> # A tibble: 6 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     7     1 #> 2     7     1     1 #> 3     6     0     1 #> 4     5     0     3 #> 5     8     8     3 #> 6     7     3     3"},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are row data complete? — rows_complete","text":"Validate considering data columns b, complete rows (.e., rows NA values).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   rows_complete(columns = c(a, b)) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are row data complete? — rows_complete","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   rows_complete(columns = c(a, b)) %>%   dplyr::pull(a) #> [1] 5 7 6 5 8 7"},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are row data complete? — rows_complete","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_rows_complete(tbl, columns = c(a, b))"},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are row data complete? — rows_complete","text":"test_*() form, get single logical value returned us.","code":"test_rows_complete(tbl, columns = c(a, b)) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/rows_complete.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are row data complete? — rows_complete","text":"2-21","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":null,"dir":"Reference","previous_headings":"","what":"Are row data distinct? — rows_distinct","title":"Are row data distinct? — rows_distinct","text":"rows_distinct() validation function, expect_rows_distinct() expectation function, test_rows_distinct() test function check whether row values (optionally constrained selection specified columns) , taken complete unit, distinct units table. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. validation step expectation, operate number test units equal number rows table (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are row data distinct? — rows_distinct","text":"","code":"rows_distinct(   x,   columns = tidyselect::everything(),   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_rows_distinct(   object,   columns = tidyselect::everything(),   preconditions = NULL,   threshold = 1 )  test_rows_distinct(   object,   columns = tidyselect::everything(),   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are row data distinct? — rows_distinct","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). columns target columns <tidy-select> // default: everything() column-selecting expression, one use inside dplyr::select(). Specifies set column(s) distinctness rows checked. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are row data distinct? — rows_distinct","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Are row data distinct? — rows_distinct","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Are row data distinct? — rows_distinct","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Are row data distinct? — rows_distinct","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Are row data distinct? — rows_distinct","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. Using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Are row data distinct? — rows_distinct","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Are row data distinct? — rows_distinct","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Are row data distinct? — rows_distinct","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). rows_distinct() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call rows_distinct() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter. value columns necessary checking unique values across subset columns. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   rows_distinct(     columns = c(a, b),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `rows_distinct()` step.\",     active = FALSE   ) steps: - rows_distinct:     columns: c(a, b)     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `rows_distinct()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are row data distinct? — rows_distinct","text":"Create simple table three columns numerical values.","code":"tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5, 8, 7),     b = c(7, 1, 0, 0, 8, 3),     c = c(1, 1, 1, 3, 3, 3)   )  tbl #> # A tibble: 6 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     7     1 #> 2     7     1     1 #> 3     6     0     1 #> 4     5     0     3 #> 5     8     8     3 #> 6     7     3     3"},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Are row data distinct? — rows_distinct","text":"Validate considering data columns b, duplicate rows (.e., rows distinct).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   rows_distinct(columns = c(a, b)) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Are row data distinct? — rows_distinct","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   rows_distinct(columns = c(a, b)) %>%   dplyr::pull(a) #> [1] 5 7 6 5 8 7"},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Are row data distinct? — rows_distinct","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_rows_distinct(tbl, columns = c(a, b))"},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Are row data distinct? — rows_distinct","text":"test_*() form, get single logical value returned us.","code":"test_rows_distinct(tbl, columns = c(a, b)) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/rows_distinct.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Are row data distinct? — rows_distinct","text":"2-20","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/scan_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Thoroughly scan a table to better understand it — scan_data","title":"Thoroughly scan a table to better understand it — scan_data","text":"Generate HTML report scours input table data. calling agent validate data, good idea understand data level precision. Make initial step well-balanced data quality reporting workflow. reporting output contains several sections make everything digestible, : Overview Table dimensions, duplicate row counts, column types, reproducibility information Variables summary table variable statistics summaries depending variable type Interactions matrix plot shows interactions variables Correlations set correlation matrix plots numerical variables Missing Values summary figure shows degree missingness across variables Sample table provides head tail rows dataset resulting object can printed make viewable RStudio Viewer. also \"shiny.tag.list\" object can integrated R Markdown HTML output Shiny applications. need output HTML, export file export_report() function.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/scan_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Thoroughly scan a table to better understand it — scan_data","text":"","code":"scan_data(   tbl,   sections = \"OVICMS\",   navbar = TRUE,   width = NULL,   lang = NULL,   locale = NULL )"},{"path":"https://rstudio.github.io/pointblank/reference/scan_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Thoroughly scan a table to better understand it — scan_data","text":"tbl data table obj:<tbl_*> // required input table. can data frame, tibble, tbl_dbi object, tbl_spark object. sections Sections include scalar<character> // default: \"OVICMS\" sections include finalized Table Scan report. string key characters representing section names required . default string \"OVICMS\" wherein letter stands following sections default order: \"O\": \"overview\"; \"V\": \"variables\"; \"\": \"interactions\"; \"C\": \"correlations\"; \"M\": \"missing\"; \"S\": \"sample\". string can comprised less characters order can changed suit desired layout report. tbl_dbi tbl_spark objects supplied tbl, \"interactions\" \"correlations\" sections currently excluded. navbar Include navigation HTML report scalar<logical> // default: TRUE navigation bar anchored top report page? width Width option HTML report scalar<integer> // default: NULL (optional) optional fixed width (pixels) HTML report. default, fixed width applied. lang Reporting language scalar<character> // default: NULL (optional) language use label text report. default, NULL create English (\"en\") text. options include French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"),  Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\"). locale Locale value formatting within reports scalar<character> // default: NULL (optional) optional locale ID use formatting values report according locale's rules. Examples include \"en_US\" English (United States) \"fr_FR\" French (France); simply, can language identifier without country designation, like \"es\" Spanish (Spain, \"es_ES\").","code":""},{"path":"https://rstudio.github.io/pointblank/reference/scan_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Thoroughly scan a table to better understand it — scan_data","text":"ptblank_tbl_scan object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/scan_data.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Thoroughly scan a table to better understand it — scan_data","text":"Get HTML document describes data dplyr::storms dataset.","code":"tbl_scan <- scan_data(tbl = dplyr::storms)"},{"path":"https://rstudio.github.io/pointblank/reference/scan_data.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Thoroughly scan a table to better understand it — scan_data","text":"1-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":null,"dir":"Reference","previous_headings":"","what":"Run several tests and a final validation in a serial manner — serially","title":"Run several tests and a final validation in a serial manner — serially","text":"serially() validation function allows series tests run sequence either culminating final validation step simply exiting series. construction allows pre-testing may make sense validation step. example, may situations vital check column type performing validation column (since wrong type can result evaluation error subsequent validation). Another serial workflow might entail bundle checks prescribed order , pass, goal testing achieved (e.g., checking table matches another series increasingly specific tests). series specified inside serially() composed listing calls, draw upon test functions (T) describe tests optionally provide finalizing call validation function (V). following constraints apply: must least one test function series (T -> V good, V ) can one validation function call, V; optional , included, must placed end (T -> T -> V good, sequences bad: (1) T -> V -> T, (2) T -> T -> V -> V) validation function call (V), included, yield multiple validation steps (may happen providing multiple columns segments) example arrange expressions:   series concentrates column called count first checks whether column exists, checks column numeric, finally validates whether values column greater 2. Note listing calls, . stands target table always necessary . Also important test_*() functions threshold argument set 1 default. need bump threshold value can changed different integer value (absolute threshold failing test units) decimal value 0 1 (serving fractional threshold failing test units).","code":"~ test_col_exists(., columns = count), ~ test_col_is_numeric(., columns = count), ~ col_vals_gt(., columns = count, value = 2)"},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run several tests and a final validation in a serial manner — serially","text":"","code":"serially(   x,   ...,   .list = list2(...),   preconditions = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_serially(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )  test_serially(   object,   ...,   .list = list2(...),   preconditions = NULL,   threshold = 1 )"},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run several tests and a final validation in a serial manner — serially","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). ... Test/validation expressions <test/validation expressions> // required (, use .list) collection one-sided formulas consist test_*() function calls (e.g., test_col_vals_between(), etc.) arranged sequence intended interrogation order. Typically, validations final one threshold value set (default 1) short circuiting within series. finishing validation function call (e.g., col_vals_increasing(), etc.) can optionally inserted end series, serving validation step undergoes interrogation prior tests adequately pass. example ~ test_column_exists(., ), ~ col_vals_not_null(., )). .list Alternative ... <list multiple expressions> // required (, use ...) Allows use list input alternative .... preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run several tests and a final validation in a serial manner — serially","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Run several tests and a final validation in a serial manner — serially","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"column-names","dir":"Reference","previous_headings":"","what":"Column Names","title":"Run several tests and a final validation in a serial manner — serially","text":"columns may single column (symbol string \"\") vector columns (c(, b, c) c(\"\", \"b\", \"c\")). {tidyselect} helpers also supported, contains(\"date\") (.double). passing external vector columns, wrapped all_of(). multiple columns selected columns, result expansion validation steps number columns (e.g., c(col_a, col_b) result entry two validation steps). Previously, columns specified vars(). continues work, c() offers capability supersedes vars() columns.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Run several tests and a final validation in a serial manner — serially","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Run several tests and a final validation in a serial manner — serially","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Run several tests and a final validation in a serial manner — serially","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Run several tests and a final validation in a serial manner — serially","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Run several tests and a final validation in a serial manner — serially","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). serially() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call serially() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter expressions validation steps necessary. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   serially(     ~ test_col_vals_lt(., columns = a, value = 8),     ~ test_col_vals_gt(., columns = c, value = vars(a)),     ~ col_vals_not_null(., columns = b),     preconditions = ~ . %>% dplyr::filter(a < 10),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `serially()` step.\",     active = FALSE   ) steps: - serially:     fns:     - ~test_col_vals_lt(., columns = a, value = 8)     - ~test_col_vals_gt(., columns = c, value = vars(a))     - ~col_vals_not_null(., columns = b)     preconditions: ~. %>% dplyr::filter(a < 10)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `serially()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run several tests and a final validation in a serial manner — serially","text":"examples , use simple table three numeric columns (, b, c). basic table 'll useful explaining things later.","code":"tbl <-   dplyr::tibble(     a = c(5, 2, 6),     b = c(6, 4, 9),     c = c(1, 2, 3)   )  tbl #> # A tibble: 3 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     6     1 #> 2     2     4     2 #> 3     6     9     3"},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Run several tests and a final validation in a serial manner — serially","text":"serially() function can set perform series tests perform validation (tests pass). , going (1) test whether columns b numeric, (2) check NA values, (3) perform finalizing validation checks whether values b greater values . determine validation failing test units (4 tests final validation).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .  going ? four tests passed final validation occurred. failing test units either! final validation optional variation serial tests performed.   Everything good :","code":"agent_1 <-   create_agent(tbl = tbl) %>%   serially(     ~ test_col_is_numeric(., columns = c(a, b)),     ~ test_col_vals_not_null(., columns = c(a, b)),     ~ col_vals_gt(., columns = b, value = vars(a))     ) %>%   interrogate() agent_2 <-   create_agent(tbl = tbl) %>%   serially(     ~ test_col_is_numeric(., columns = c(a, b)),     ~ test_col_vals_not_null(., columns = c(a, b))   ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Run several tests and a final validation in a serial manner — serially","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>%   serially(     ~ test_col_is_numeric(., columns = c(a, b)),     ~ test_col_vals_not_null(., columns = c(a, b)),     ~ col_vals_gt(., columns = b, value = vars(a))   ) #> # A tibble: 3 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     6     1 #> 2     2     4     2 #> 3     6     9     3"},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Run several tests and a final validation in a serial manner — serially","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_serially(   tbl,   ~ test_col_is_numeric(., columns = c(a, b)),   ~ test_col_vals_not_null(., columns = c(a, b)),   ~ col_vals_gt(., columns = b, value = vars(a)) )"},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Run several tests and a final validation in a serial manner — serially","text":"test_*() form, get single logical value returned us.","code":"tbl %>%   test_serially(     ~ test_col_is_numeric(., columns = c(a, b)),     ~ test_col_vals_not_null(., columns = c(a, b)),     ~ col_vals_gt(., columns = b, value = vars(a))   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/serially.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Run several tests and a final validation in a serial manner — serially","text":"2-35","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/set_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Set a data table to an agent or an informant — set_tbl","title":"Set a data table to an agent or an informant — set_tbl","text":"Setting data table agent informant set_tbl() replaces associated table (data frame, tibble, objects class tbl_dbi tbl_spark).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/set_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set a data table to an agent or an informant — set_tbl","text":"","code":"set_tbl(x, tbl, tbl_name = NULL, label = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/set_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set a data table to an agent or an informant — set_tbl","text":"x pointblank agent informant object obj:<ptblank_agent|ptblank_informant> // required agent object class ptblank_agent, , informant class ptblank_informant. tbl Table expression reading one obj:<tbl_*>|<tbl reading expression> // required input table agent informant. can data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, expression can supplied serve instructions retrieve target table interrogation- incorporation-time. two ways specify association target table: (1) table-prep formula, right-hand side (RHS) formula expression (e.g., ~ { <tbl reading code>}), (2) function (e.g., function() { <tbl reading code>}). tbl_name table name scalar<character> // default: NULL (optional) optional name assign new input table object. value provided, name generated based whatever information available. label optional label reporting scalar<character> // default: NULL (optional) optional label validation plan information report. value provided existing label retained.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/set_tbl.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set a data table to an agent or an informant — set_tbl","text":"Set proportional failure thresholds warn, stop, notify states using action_levels().   Create agent small_table set target table via tbl. Apply actions, add validation steps interrogate data.   Replace agent's association small_table mutated version (one removes duplicate rows). , interrogate new target table.","code":"al <-   action_levels(       warn_at = 0.10,       stop_at = 0.25,     notify_at = 0.35   ) agent_1 <-   create_agent(     tbl = small_table,     tbl_name = \"small_table\",     label = \"An example.\",     actions = al   ) %>%   col_exists(columns = c(date, date_time)) %>%   col_vals_regex(     columns = b,     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   interrogate() agent_2 <-   agent_1 %>%   set_tbl(     tbl = small_table %>% dplyr::distinct()   ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/set_tbl.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Set a data table to an agent or an informant — set_tbl","text":"9-4","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/small_table.html","id":null,"dir":"Reference","previous_headings":"","what":"A small table that is useful for testing — small_table","title":"A small table that is useful for testing — small_table","text":"small table different types columns. probably just useful testing functions pointblank. Rows 9 10 exact duplicates. c column contains two NA values.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/small_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A small table that is useful for testing — small_table","text":"","code":"small_table"},{"path":"https://rstudio.github.io/pointblank/reference/small_table.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A small table that is useful for testing — small_table","text":"tibble 13 rows 8 variables: date_time date-time column (POSIXct class) dates correspond exactly date column. Time values somewhat randomized 'seconds' values 00. date Date column dates 2016-01-04 2016-01-30. integer column values ranging 1 8. b character column values adhere common pattern. c integer column values ranging 2 9. Contains two NA values. d numeric column values ranging 108 10000. e logical column. f character column \"low\", \"mid\", \"high\" values.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/small_table.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A small table that is useful for testing — small_table","text":"14-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/small_table.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A small table that is useful for testing — small_table","text":"","code":"# Here is a glimpse at the data # available in `small_table` dplyr::glimpse(small_table) #> Rows: 13 #> Columns: 8 #> $ date_time <dttm> 2016-01-04 11:00:00, 2016-01-04 00:32:00, 2016-01-05 13:32:… #> $ date      <date> 2016-01-04, 2016-01-04, 2016-01-05, 2016-01-06, 2016-01-09,… #> $ a         <int> 2, 3, 6, 2, 8, 4, 7, 4, 3, 3, 4, 2, 1 #> $ b         <chr> \"1-bcd-345\", \"5-egh-163\", \"8-kdg-938\", \"5-jdo-903\", \"3-ldm-0… #> $ c         <dbl> 3, 8, 3, NA, 7, 4, 3, 2, 9, 9, 7, 8, NA #> $ d         <dbl> 3423.29, 9999.99, 2343.23, 3892.40, 283.94, 3291.03, 843.34,… #> $ e         <lgl> TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, FAL… #> $ f         <chr> \"high\", \"low\", \"high\", \"mid\", \"low\", \"mid\", \"high\", \"low\", \"…"},{"path":"https://rstudio.github.io/pointblank/reference/small_table_sqlite.html","id":null,"dir":"Reference","previous_headings":"","what":"An SQLite version of the small_table dataset — small_table_sqlite","title":"An SQLite version of the small_table dataset — small_table_sqlite","text":"small_table_sqlite() function creates SQLite, tbl_dbi version small_table dataset. requirement availability DBI RSQLite packages. packages can installed using install.packages(\"DBI\") install.packages(\"RSQLite\").","code":""},{"path":"https://rstudio.github.io/pointblank/reference/small_table_sqlite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An SQLite version of the small_table dataset — small_table_sqlite","text":"","code":"small_table_sqlite()"},{"path":"https://rstudio.github.io/pointblank/reference/small_table_sqlite.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"An SQLite version of the small_table dataset — small_table_sqlite","text":"14-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/small_table_sqlite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"An SQLite version of the small_table dataset — small_table_sqlite","text":"","code":"# Use `small_table_sqlite()` to # create an SQLite version of the # `small_table` table # # small_table_sqlite <- small_table_sqlite()"},{"path":"https://rstudio.github.io/pointblank/reference/snip_highest.html","id":null,"dir":"Reference","previous_headings":"","what":"A fn for info_snippet(): get the highest value from a column — snip_highest","title":"A fn for info_snippet(): get the highest value from a column — snip_highest","text":"snip_highest() function can used info_snippet() function (.e., provided fn) get highest numerical, time value, alphabetical value column target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/snip_highest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A fn for info_snippet(): get the highest value from a column — snip_highest","text":"","code":"snip_highest(column)"},{"path":"https://rstudio.github.io/pointblank/reference/snip_highest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A fn for info_snippet(): get the highest value from a column — snip_highest","text":"column target column scalar<character> // required name column contains target values.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/snip_highest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A fn for info_snippet(): get the highest value from a column — snip_highest","text":"formula needed info_snippet()'s fn argument.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/snip_highest.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A fn for info_snippet(): get the highest value from a column — snip_highest","text":"Generate informant object, add snippet info_snippet() snip_highest() (giving us method get highest value column ); define location snippet result { } incorporate() snippet info text. Note order info_columns() info_snippet() calls matter.   can print informant object see information report.","code":"informant <-   create_informant(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%   info_columns(     columns = a,     `Highest Value` = \"Highest value is {highest_a}.\"   ) %>%   info_snippet(     snippet_name = \"highest_a\",     fn = snip_highest(column = \"a\")   ) %>%   incorporate() informant"},{"path":"https://rstudio.github.io/pointblank/reference/snip_highest.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A fn for info_snippet(): get the highest value from a column — snip_highest","text":"3-9","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/snip_list.html","id":null,"dir":"Reference","previous_headings":"","what":"A fn for info_snippet(): get a list of column categories — snip_list","title":"A fn for info_snippet(): get a list of column categories — snip_list","text":"snip_list() function can used info_snippet() function (.e., provided fn) get catalog list table column. can limit items list limit value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/snip_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A fn for info_snippet(): get a list of column categories — snip_list","text":"","code":"snip_list(   column,   limit = 5,   sorting = c(\"inorder\", \"infreq\", \"inseq\"),   reverse = FALSE,   sep = \",\",   and_or = NULL,   oxford = TRUE,   as_code = TRUE,   quot_str = NULL,   na_rm = FALSE,   lang = NULL )"},{"path":"https://rstudio.github.io/pointblank/reference/snip_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A fn for info_snippet(): get a list of column categories — snip_list","text":"column target column scalar<character> // required name column contains target values. limit Limit list length scalar<integer> // default: 5 limit items put generated list. returned text state remaining number items beyond limit. sorting Type sorting within list singl-kw:[inorder|infreq|inseq] // default: \"inorder\" keyword used designate type sorting use list. three options \"inorder\" (default), \"infreq\", \"inseq\". \"inorder\", distinct items listed order first appear. Using \"infreq\" orders items decreasing frequency item. \"inseq\" option applies alphanumeric sorting distinct list items. reverse Reversal list order scalar<logical> // default: FALSE option reverse ordering list items. default, FALSE using TRUE reverse items applying limit. sep Separator text list scalar<character> // default: \",\" separator use list items. default, comma. and_or Use '' '' within list scalar<character> // default: NULL (optional) type conjunction use final penultimate list items (item length limit value). NULL (default) used, '' conjunction used. Alternatively, following keywords can used: \"\", \"\", empty string (conjunction ). oxford Usage oxford comma scalar<logical> // default: TRUE Whether use Oxford comma certain conditions. as_code Treat items code scalar<logical> // default: TRUE list item appear 'code font' (.e., monospaced text)? default TRUE. Using FALSE keeps list items font rest information report. quot_str Set items double quotes scalar<logical> // default: NULL (optional) option whether list items set double quotes. NULL (default), quotation marks mainly associated list items derived character factor values; numbers, dates, logical values quotation marks. can explicitly use quotations () either TRUE FALSE . na_rm Remove NA values list scalar<logical> // default: FALSE option whether NA values counted item list. lang Reporting language scalar<character> // default: NULL (optional) language use joining words (and_or option) additional words generated list string. default, NULL use whichever lang setting available parent informant object (settable create_informant() lang argument). specified override, language options English (\"en\"), French (\"fr\"), German (\"de\"), Italian (\"\"), Spanish (\"es\"), Portuguese (\"pt\"), Turkish (\"tr\"), Chinese (\"zh\"), Russian (\"ru\"), Polish (\"pl\"), Danish (\"da\"), Swedish (\"sv\"), Dutch (\"nl\").","code":""},{"path":"https://rstudio.github.io/pointblank/reference/snip_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A fn for info_snippet(): get a list of column categories — snip_list","text":"formula needed info_snippet()'s fn argument.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/snip_list.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A fn for info_snippet(): get a list of column categories — snip_list","text":"Generate informant object, add snippet info_snippet() snip_list() (giving us method get distinct list column values column f). Define location snippet result { } incorporate() snippet info text. Note order info_columns() info_snippet() calls matter.   can print informant object see information report.","code":"informant <-   create_informant(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%   info_columns(     columns = f,     `Items` = \"This column contains {values_f}.\"   ) %>%   info_snippet(     snippet_name = \"values_f\",     fn = snip_list(column = \"f\")   ) %>%   incorporate() informant"},{"path":"https://rstudio.github.io/pointblank/reference/snip_list.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A fn for info_snippet(): get a list of column categories — snip_list","text":"3-6","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/snip_lowest.html","id":null,"dir":"Reference","previous_headings":"","what":"A fn for info_snippet(): get the lowest value from a column — snip_lowest","title":"A fn for info_snippet(): get the lowest value from a column — snip_lowest","text":"snip_lowest() function can used info_snippet() function (.e., provided fn) get lowest numerical, time value, alphabetical value column target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/snip_lowest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A fn for info_snippet(): get the lowest value from a column — snip_lowest","text":"","code":"snip_lowest(column)"},{"path":"https://rstudio.github.io/pointblank/reference/snip_lowest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A fn for info_snippet(): get the lowest value from a column — snip_lowest","text":"column target column scalar<character> // required name column contains target values.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/snip_lowest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A fn for info_snippet(): get the lowest value from a column — snip_lowest","text":"formula needed info_snippet()'s fn argument.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/snip_lowest.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A fn for info_snippet(): get the lowest value from a column — snip_lowest","text":"Generate informant object, add snippet info_snippet() snip_lowest() (giving us method get lowest value column ). Define location snippet result { } incorporate() snippet info text. Note order info_columns() info_snippet() calls matter.   can print informant object see information report.","code":"informant <-   create_informant(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%   info_columns(     columns = a,     `Lowest Value` = \"Lowest value is {lowest_a}.\"   ) %>%   info_snippet(     snippet_name = \"lowest_a\",     fn = snip_lowest(column = \"a\")   ) %>%   incorporate() informant"},{"path":"https://rstudio.github.io/pointblank/reference/snip_lowest.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A fn for info_snippet(): get the lowest value from a column — snip_lowest","text":"3-8","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/snip_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"A fn for info_snippet(): get an inline statistical summary — snip_stats","title":"A fn for info_snippet(): get an inline statistical summary — snip_stats","text":"snip_stats() function can used info_snippet() function (.e., provided fn) produce five- seven-number statistical summary. inline summary works well within paragraph text can help describing distribution numerical values column. given column, three different types inline statistical summaries can provided: five-number summary (\"5num\"): minimum, Q1, median, Q3, maximum seven-number summary (\"7num\"): P2, P9, Q1, median, Q3, P91, P98 Bowley's seven-figure summary (\"bowley\"): minimum, P10, Q1, median, Q3, P90, maximum","code":""},{"path":"https://rstudio.github.io/pointblank/reference/snip_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A fn for info_snippet(): get an inline statistical summary — snip_stats","text":"","code":"snip_stats(column, type = c(\"5num\", \"7num\", \"bowley\"))"},{"path":"https://rstudio.github.io/pointblank/reference/snip_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A fn for info_snippet(): get an inline statistical summary — snip_stats","text":"column target column scalar<character> // required name column contains target values. type Type statistical summary singl-kw:[5num|7num|bowley] // default: \"5num\" type summary. default, \"5num\" keyword used generate five-number summary. Two options provide seven-number summaries: \"7num\" \"bowley\".","code":""},{"path":"https://rstudio.github.io/pointblank/reference/snip_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A fn for info_snippet(): get an inline statistical summary — snip_stats","text":"formula needed info_snippet()'s fn argument.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/snip_stats.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A fn for info_snippet(): get an inline statistical summary — snip_stats","text":"Generate informant object, add snippet info_snippet() snip_stats() (giving us method get summary stats column d). Define location snippet result { } incorporate() snippet info text. Note order info_columns() info_snippet() calls matter.   can print informant object see information report.","code":"informant <-   create_informant(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"An example.\"   ) %>%   info_columns(     columns = d,     `Stats` = \"Stats (fivenum): {stats_d}.\"   ) %>%   info_snippet(     snippet_name = \"stats_d\",     fn = snip_stats(column = \"d\")   ) %>%   incorporate() informant"},{"path":"https://rstudio.github.io/pointblank/reference/snip_stats.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A fn for info_snippet(): get an inline statistical summary — snip_stats","text":"3-7","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform a specialized validation with a user-defined function — specially","title":"Perform a specialized validation with a user-defined function — specially","text":"specially() validation function allows custom validation function provide. major proviso provided function must either return logical vector table final column logical. function operate table object, , can whatever like, also operate types objects. , can transform input table preconditions inject entirely different object . interrogation, checks ensure data table object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform a specialized validation with a user-defined function — specially","text":"","code":"specially(   x,   fn,   preconditions = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_specially(object, fn, preconditions = NULL, threshold = 1)  test_specially(object, fn, preconditions = NULL, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform a specialized validation with a user-defined function — specially","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). fn Specialized validation function <function> // required function performs specialized validation data. must either return logical vector table last column logical column. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform a specialized validation with a user-defined function — specially","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Perform a specialized validation with a user-defined function — specially","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite()) database tables may work varying degrees formally tested (mindful using unsupported backends pointblank).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Perform a specialized validation with a user-defined function — specially","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires calculated column, filtering rows, addition columns via join, etc. Especially agent-based report can advantageous since can develop large validation plan single target table make minor adjustments , needed, along way. Within specially(), function special, internal checking whether preconditions-based output table. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed (e.g., ~ . %>% dplyr::mutate(col_b = col_a + 10)). Alternatively, function instead supplied (e.g., function(x) dplyr::mutate(x, col_b = col_a + 10)).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Perform a specialized validation with a user-defined function — specially","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. especially true x table object , otherwise, nothing happens. col_vals_*()-type functions, using action_levels(warn_at = 0.25) action_levels(stop_at = 0.25) good choices depending situation (first produces warning quarter total test units fails, stop()s threshold level).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Perform a specialized validation with a user-defined function — specially","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Perform a specialized validation with a user-defined function — specially","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Perform a specialized validation with a user-defined function — specially","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). specially() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call specially() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter expressions validation steps necessary. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   specially(     fn = function(x) { ... },     preconditions = ~ . %>% dplyr::filter(a < 10),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `specially()` step.\",     active = FALSE   ) steps: - specially:     fn: function(x) { ... }     preconditions: ~. %>% dplyr::filter(a < 10)     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `specially()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform a specialized validation with a user-defined function — specially","text":"examples , use simple table three numeric columns (, b, c). basic table 'll useful explaining things later.","code":"tbl <-   dplyr::tibble(     a = c(5, 2, 6),     b = c(3, 4, 6),     c = c(9, 8, 7)   )  tbl #> # A tibble: 3 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     3     9 #> 2     2     4     8 #> 3     6     6     7"},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Perform a specialized validation with a user-defined function — specially","text":"Validate target table exactly three rows. single validation specially() 1 test unit since function executed x (target table) results logical vector length 1. determine validation failing test units (1 test unit).   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   specially(fn = function(x) nrow(x) == 3) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Perform a specialized validation with a user-defined function — specially","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>% specially(fn = function(x) nrow(x) == 3) #> # A tibble: 3 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     3     9 #> 2     2     4     8 #> 3     6     6     7"},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Perform a specialized validation with a user-defined function — specially","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_specially(tbl, fn = function(x) nrow(x) == 3)"},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Perform a specialized validation with a user-defined function — specially","text":"test_*() form, get single logical value returned us.","code":"tbl %>% test_specially(fn = function(x) nrow(x) == 3) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"variations","dir":"Reference","previous_headings":"","what":"Variations","title":"Perform a specialized validation with a user-defined function — specially","text":"can complex things specially() variants. Check class target table.   Check number rows target table less small_table.   Check numbers across numeric column less 10.   Check values column c greater b greater (row) always less 10. creates table new column d logical column (used evaluation test units).   Check game_revenue table (target table) exactly 2000 rows.","code":"tbl %>%   test_specially(     fn = function(x) {       inherits(x, \"data.frame\")     }   ) #> [1] TRUE tbl %>%   test_specially(     fn = function(x) {       nrow(x) < nrow(small_table)     }   ) #> [1] TRUE tbl %>%   test_specially(     fn = function(x) {       (x %>%          dplyr::select(where(is.numeric)) %>%          unlist()       ) < 10     }   ) #> [1] TRUE tbl %>%   test_specially(     fn = function(x) {       x %>%         dplyr::mutate(           d = c > b & c > a & c < 10         )     }   ) #> [1] TRUE tbl %>%   test_specially(     fn = function(x) {       nrow(game_revenue) == 2000     }   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/specially.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Perform a specialized validation with a user-defined function — specially","text":"2-36","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/specifications.html","id":null,"dir":"Reference","previous_headings":"","what":"A table containing data pertaining to various specifications — specifications","title":"A table containing data pertaining to various specifications — specifications","text":"specifications dataset useful testing col_vals_within_spec(), test_col_vals_within_spec(), expect_col_vals_within_spec() functions. column, holding character values different specifications, rows 1-5 contain valid values, 6th row NA value, final two values (rows 7 8) invalid. Different specification (spec) keywords apply columns validating aforementioned functions.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/specifications.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A table containing data pertaining to various specifications — specifications","text":"","code":"specifications"},{"path":"https://rstudio.github.io/pointblank/reference/specifications.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A table containing data pertaining to various specifications — specifications","text":"tibble 8 rows 12 variables: isbn_numbers ISBN-13 numbers; can validated \"isbn\" specification. vin_numbers VIN numbers (identifiers motor vehicles); can validated \"vin\" specification. zip_codes Postal codes U.S.; can validated \"postal[USA]\" specification \"zip\" alias. credit_card_numbers Credit card numbers; can validated \"credit_card\" specification \"cc\" alias. iban_austria IBAN numbers Austrian accounts; can validated \"iban[AUT]\" specification. swift_numbers Swift-BIC numbers; can validated \"swift\" specification. phone_numbers Phone numbers; can validated \"phone\" specification. email_addresses Email addresses; can validated \"email\" specification. urls URLs; can validated  \"url\" specification. ipv4_addresses IPv4 addresses; can validated \"ipv4\" specification ipv6_addresses IPv6 addresses; can validated \"ipv6\" specification mac_addresses MAC addresses; can validated \"mac\" specification","code":""},{"path":"https://rstudio.github.io/pointblank/reference/specifications.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A table containing data pertaining to various specifications — specifications","text":"14-3","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/specifications.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A table containing data pertaining to various specifications — specifications","text":"","code":"# Here is a glimpse at the data # available in `specifications` dplyr::glimpse(specifications) #> Rows: 8 #> Columns: 12 #> $ isbn_numbers        <chr> \"978 1 85715 201 2\", \"978-1-84159-362-3\", \"978 1 8… #> $ vin_numbers         <chr> \"4UZAANDH85CV12329\", \"JM1BL1S59A1134659\", \"1GCEK14… #> $ zip_codes           <chr> \"99553\", \"36264\", \"71660\", \"85225\", \"90309\", NA, \"… #> $ credit_card_numbers <chr> \"340000000000009\", \"378734493671000\", \"67034444444… #> $ iban_austria        <chr> \"AT582774098454337653\", \"AT220332087576467472\", \"A… #> $ swift_numbers       <chr> \"RBOSGGSX\", \"RZTIAT22263\", \"BCEELULL\", \"MARKDEFF\",… #> $ phone_numbers       <chr> \"+5-555-555-5555\", \"+5 555 555 5555\", \"+5.555.555.… #> $ email_addresses     <chr> \"test@test.com\", \"mail+mail@example.com\", \"mail.em… #> $ urls                <chr> \"http://foo.com/blah_blah\", \"http://foo.com/blah_b… #> $ ipv4_addresses      <chr> \"93.184.220.20\", \"161.148.172.130\", \"161.148.172.1… #> $ ipv6_addresses      <chr> \"2001:0db8:0000:85a3:0000:0000:ac1f:8001\", \"2001:d… #> $ mac_addresses       <chr> \"01-2d-4c-ef-89-ab\", \"01-2D-4C-EF-89-AB\", \"01:2d:4…"},{"path":"https://rstudio.github.io/pointblank/reference/stock_msg_body.html","id":null,"dir":"Reference","previous_headings":"","what":"Provide simple email message body components: body — stock_msg_body","title":"Provide simple email message body components: body — stock_msg_body","text":"stock_msg_body() function simply provides stock text email message sent via email_blast() obtained standalone object email_create().","code":""},{"path":"https://rstudio.github.io/pointblank/reference/stock_msg_body.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Provide simple email message body components: body — stock_msg_body","text":"","code":"stock_msg_body()"},{"path":"https://rstudio.github.io/pointblank/reference/stock_msg_body.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Provide simple email message body components: body — stock_msg_body","text":"Text suitable msg_body argument email_blast() email_create().","code":""},{"path":"https://rstudio.github.io/pointblank/reference/stock_msg_body.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Provide simple email message body components: body — stock_msg_body","text":"4-3","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/stock_msg_footer.html","id":null,"dir":"Reference","previous_headings":"","what":"Provide simple email message body components: footer — stock_msg_footer","title":"Provide simple email message body components: footer — stock_msg_footer","text":"stock_msg_footer() function simply provides stock text email message sent via email_blast() obtained standalone object email_create().","code":""},{"path":"https://rstudio.github.io/pointblank/reference/stock_msg_footer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Provide simple email message body components: footer — stock_msg_footer","text":"","code":"stock_msg_footer()"},{"path":"https://rstudio.github.io/pointblank/reference/stock_msg_footer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Provide simple email message body components: footer — stock_msg_footer","text":"Text suitable msg_footer argument email_blast() email_create().","code":""},{"path":"https://rstudio.github.io/pointblank/reference/stock_msg_footer.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Provide simple email message body components: footer — stock_msg_footer","text":"4-4","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/stop_if_not.html","id":null,"dir":"Reference","previous_headings":"","what":"A specialized version of stopifnot() for pointblank: stop_if_not() — stop_if_not","title":"A specialized version of stopifnot() for pointblank: stop_if_not() — stop_if_not","text":"variation stopifnot() works well standalone replacement stopifnot() also customized use validation checks R Markdown documents pointblank loaded validate_rmd() invoked. Using stop_if_not() code chunk validate = TRUE option set yield correct reporting successes failures whereas stopifnot() .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/stop_if_not.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A specialized version of stopifnot() for pointblank: stop_if_not() — stop_if_not","text":"","code":"stop_if_not(...)"},{"path":"https://rstudio.github.io/pointblank/reference/stop_if_not.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A specialized version of stopifnot() for pointblank: stop_if_not() — stop_if_not","text":"... R expressions evaluate (logical vector ) TRUE.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/stop_if_not.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A specialized version of stopifnot() for pointblank: stop_if_not() — stop_if_not","text":"NULL statements ... TRUE.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/stop_if_not.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"A specialized version of stopifnot() for pointblank: stop_if_not() — stop_if_not","text":"13-5","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/stop_if_not.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A specialized version of stopifnot() for pointblank: stop_if_not() — stop_if_not","text":"","code":"# This checks whether the number of # rows in `small_table` is greater # than `10` stop_if_not(nrow(small_table) > 10) #> NULL  # This will stop for sure: there # isn't a `time` column in `small_table` # (but there are the `date_time` and # `date` columns) # stop_if_not(\"time\" %in% colnames(small_table))  # You're not bound to using tabular # data here, any statements that # evaluate to logical vectors will work stop_if_not(1 < 20:25 - 18) #> NULL"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_get.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain a materialized table via a table store — tbl_get","title":"Obtain a materialized table via a table store — tbl_get","text":"tbl_get() function gives us means materialize table entry table store (.e., table-prep formula unique name). table store used can form tbl_store object (created tbl_store() function) -disk YAML representation table store (created using yaml_write() tbl_store object). want table-prep formula table store use value tbl (create_agent(), create_informant(), set_tbl()), look tbl_source() function.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_get.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain a materialized table via a table store — tbl_get","text":"","code":"tbl_get(tbl, store = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_get.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain a materialized table via a table store — tbl_get","text":"tbl table retrieve table store. table identified name (e.g., tbl = \"large_table\") supplying reference using subset ($) tbl_store object (e.g., tbl = store$large_table). using latter method nothing needs supplied store. store Either table store object created tbl_store() function path table store YAML file created yaml_write().","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_get.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain a materialized table via a table store — tbl_get","text":"table object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_get.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain a materialized table via a table store — tbl_get","text":"Define tbl_store object adding several table-prep formulas tbl_store().   object available, can access tables named: \"small_table_duck\", \"rna\", \"sml_table\". check \"rna\" table accessible tbl_get():   alternative method getting table materialized using $ get formula choice tbls passing tbl_get(). benefit can use autocompletion show us available table store (.e., appears typing $).","code":"store <-   tbl_store(     small_table_duck ~ db_tbl(       table = small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     ~ db_tbl(       table = \"rna\",       dbname = \"pfmegrnargs\",       dbtype = \"postgres\",       host = \"hh-pgsql-public.ebi.ac.uk\",       port = 5432,       user = I(\"reader\"),       password = I(\"NWDMCE5xdipIjRrp\")     ),     sml_table ~ pointblank::small_table   ) tbl_get(   tbl = \"rna\",   store = store ) ## # Source:   table<rna> [?? x 9] ## # Database: postgres [reader@hh-pgsql-public.ebi.ac.uk:5432/pfmegrnargs] ##          id upi        timestamp           userstamp crc64   len seq_short ##     <int64> <chr>      <dttm>              <chr>     <chr> <int> <chr> ##  1 24583872 URS000177… 2019-12-02 13:26:08 rnacen    C380…   511 ATTGAACG… ##  2 24583873 URS000177… 2019-12-02 13:26:08 rnacen    BC42…   390 ATGGGCGA… ##  3 24583874 URS000177… 2019-12-02 13:26:08 rnacen    19A5…   422 CTACGGGA… ##  4 24583875 URS000177… 2019-12-02 13:26:08 rnacen    66E1…   534 AGGGTTCG… ##  5 24583876 URS000177… 2019-12-02 13:26:08 rnacen    CC8F…   252 TACGTAGG… ##  6 24583877 URS000177… 2019-12-02 13:26:08 rnacen    19E4…   413 ATGGGCGA… ##  7 24583878 URS000177… 2019-12-02 13:26:08 rnacen    AE91…   253 TACGAAGG… ##  8 24583879 URS000177… 2019-12-02 13:26:08 rnacen    E21A…   304 CAGCAGTA… ##  9 24583880 URS000177… 2019-12-02 13:26:08 rnacen    1AA7…   460 CCTACGGG… ## 10 24583881 URS000177… 2019-12-02 13:26:08 rnacen    2046…   440 CCTACGGG… ## # … with more rows, and 2 more variables: seq_long <chr>, md5 <chr> store$small_table_duck %>% tbl_get() ## # Source:   table<small_table> [?? x 8] ## # Database: duckdb_connection ##    date_time           date           a b             c      d e     f ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high ## # … with more rows"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_get.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtain a materialized table via a table store — tbl_get","text":"1-10","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Does the target table match a comparison table? — tbl_match","title":"Does the target table match a comparison table? — tbl_match","text":"tbl_match() validation function, expect_tbl_match() expectation function, test_tbl_match() test function check whether target table's composition matches comparison table. validation function can used directly data table agent object (technically, ptblank_agent object) whereas expectation test functions can used data table. types data tables can used include data frames, tibbles, database tables (tbl_dbi), Spark DataFrames (tbl_spark). validation step expectation, single test unit hinges whether two tables (preconditions applied).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does the target table match a comparison table? — tbl_match","text":"","code":"tbl_match(   x,   tbl_compare,   preconditions = NULL,   segments = NULL,   actions = NULL,   step_id = NULL,   label = NULL,   brief = NULL,   active = TRUE )  expect_tbl_match(object, tbl_compare, preconditions = NULL, threshold = 1)  test_tbl_match(object, tbl_compare, preconditions = NULL, threshold = 1)"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does the target table match a comparison table? — tbl_match","text":"x pointblank agent data table obj:<ptblank_agent>|obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark), , agent object class ptblank_agent commonly created create_agent(). tbl_compare data table comparison obj:<tbl_*> // required table compare target table. can either table object, table-prep formula. can table object data frame, tibble, tbl_dbi object, tbl_spark object. Alternatively, table-prep formula (~ <tbl reading code>) function (function() <tbl reading code>) can used lazily read table interrogation time. preconditions Input table modification prior validation <table mutation expression> // default: NULL (optional) optional expression mutating input table proceeding validation. can either provided one-sided R formula using leading ~ (e.g., ~ . %>% dplyr::mutate(col = col + 10) function (e.g., function(x) dplyr::mutate(x, col = col + 10). See Preconditions section information. segments Expressions segmenting target table <segmentation expressions> // default: NULL (optional) optional expression set expressions (held list) serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . See Segments section details . actions Thresholds actions different states obj:<action_levels> // default: NULL (optional) list containing threshold levels validation step can react accordingly exceeding set levels different states. created action_levels() helper function. step_id Manual setting step ID value scalar<character> // default: NULL (optional) One optional identifiers single multiple validation steps generated calling validation function. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. default NULL, pointblank automatically generate step ID value (based step index) case. One values can provided, exact number ID values (1) match number validation steps validation function call produce (influenced number columns provided), (2) ID string used previous validation step, (3) vector unique values. label Optional label validation step vector<character> // default: NULL (optional) Optional label validation step. label appears agent report , best appearance, kept quite short. See Labels section information. brief Brief description validation step scalar<character> // default: NULL (optional) brief short, text-based description validation step. nothing provided autobrief generated agent, using language provided create_agent()'s lang argument (defaults \"en\" English). autobrief incorporates details validation step often preferred option cases (label might better suited succinctly describe validation). active validation step active? scalar<logical> // default: TRUE logical value indicating whether validation step active. validation function working agent, FALSE make validation step inactive (still reporting presence keeping indexes steps unchanged). validation function operating directly data (agent involvement), step active = FALSE simply pass data validation whatsoever. Aside logical vector, one-sided R formula using leading ~ can used . (serving input data table) evaluate single logical value. approach, pointblank function has_columns() can used determine whether make validation step active basis one columns existing table (e.g., ~ . %>% has_columns(c(d, e))). object data table expectations tests obj:<tbl_*> // required data frame, tibble (tbl_df tbl_dbi), Spark DataFrame (tbl_spark) serves target table expectation function test function. threshold failure threshold scalar<integer|numeric>(val>=0) // default: 1 simple failure threshold value use expectation (expect_) test (test_) function variants. default, set 1 meaning single unit failure data validation results overall test failure. Whole numbers beyond 1 indicate failing units absolute threshold value result succeeding testthat test evaluate TRUE. Likewise, fractional values (0 1) act proportional failure threshold, 0.15 means 15 percent failing test units results overall test failure.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Does the target table match a comparison table? — tbl_match","text":"validation function, return value either ptblank_agent object table object (depending whether agent object table passed x). expectation function invisibly returns input , context testing data, function called primarily potential side-effects (e.g., signaling failure). test function returns logical value.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"supported-input-tables","dir":"Reference","previous_headings":"","what":"Supported Input Tables","title":"Does the target table match a comparison table? — tbl_match","text":"types data tables officially supported : data frames (data.frame) tibbles (tbl_df) Spark DataFrames (tbl_spark) following database tables (tbl_dbi): PostgreSQL tables (using RPostgres::Postgres() driver) MySQL tables (RMySQL::MySQL()) Microsoft SQL Server tables (via odbc) BigQuery tables (using bigrquery::bigquery()) DuckDB tables (duckdb::duckdb()) SQLite (RSQLite::SQLite())","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"preconditions","dir":"Reference","previous_headings":"","what":"Preconditions","title":"Does the target table match a comparison table? — tbl_match","text":"Providing expressions preconditions means pointblank preprocess target table interrogation preparatory step. might happen particular validation requires operation target table comparison takes place. Using preconditions can useful times since since can develop large validation plan single target table make minor adjustments , needed, along way. table mutation totally isolated scope validation step(s) preconditions used. Using dplyr code suggested since statements can translated SQL necessary (.e., target table resides database). code easily supplied one-sided R formula (using leading ~). formula representation, . serves input data table transformed. Alternatively, function instead supplied.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"segments","dir":"Reference","previous_headings":"","what":"Segments","title":"Does the target table match a comparison table? — tbl_match","text":"using segments argument, possible define particular validation segments (row slices) target table. optional expression set expressions serve segment target table column values. expression can given one two ways: (1) column names, (2) two-sided formula LHS holds column name RHS contains column values segment . example first type expression can used, vars(a_column) segment target table however many unique values present column called a_column. great every unique value particular column (like different locations, different dates) requires repeating validation. formula, can selective column values used segmentation. Using a_column ~ c(\"group_1\", \"group_2\") attempt obtain two segments one slice data value \"group_1\" exists column named \"a_column\", , slice \"group_2\" exists column. group rows resolved formula result separate validation step. Segmentation always occur preconditions (.e., statements mutate target table), , applied. type one-two combo, possible generate labels segmentation using expression preconditions refer labels segments without generate separate version target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"actions","dir":"Reference","previous_headings":"","what":"Actions","title":"Does the target table match a comparison table? — tbl_match","text":"Often, want specify actions validation. argument, present every validation function, takes specially-crafted list object best produced action_levels() function. Read function's documentation lowdown create reactions -threshold failure levels validation. basic gist want least single threshold level (specified either fraction test units failed, , absolute value), often using warn_at argument. Using action_levels(warn_at = 1) action_levels(stop_at = 1) good choices depending situation (first produces warning, stop()s).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Does the target table match a comparison table? — tbl_match","text":"label may single string character vector matches number expanded steps. label also supports {glue} syntax exposes following dynamic variables contextualized current step: \"{.step}\": validation step name \"{.seg_col}\": current segment's column name \"{.seg_val}\": current segment's value/group glue context also supports ordinary expressions flexibility (e.g., \"{toupper(.step)}\") long return length-1 string.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"briefs","dir":"Reference","previous_headings":"","what":"Briefs","title":"Does the target table match a comparison table? — tbl_match","text":"Want describe validation step detail? Keep mind useful x agent. case, brief agent text fits. worry want . autobrief protocol kicked brief = NULL simple brief automatically generated.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Does the target table match a comparison table? — tbl_match","text":"pointblank agent can written YAML yaml_write() resulting YAML can used regenerate agent (yaml_read_agent()) interrogate target table (via yaml_agent_interrogate()). tbl_match() represented YAML (top-level steps key list member), syntax closely follows signature validation function. example complex call tbl_match() validation step expressed R code corresponding YAML representation. R statement:   YAML representation:   practice, often shorter. Arguments default values written YAML using yaml_write() (though acceptable include default generating YAML means). also possible preview transformation agent YAML without writing disk using yaml_agent_string() function.","code":"agent %>%   tbl_match(     tbl_compare = ~ file_tbl(       file = from_github(         file = \"sj_all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       ),     preconditions = ~ . %>% dplyr::filter(a < 10),     segments = b ~ c(\"group_1\", \"group_2\"),     actions = action_levels(warn_at = 0.1, stop_at = 0.2),     label = \"The `tbl_match()` step.\",     active = FALSE   ) steps: - tbl_match:     tbl_compare: ~ file_tbl(       file = from_github(         file = \"sj_all_revenue_large.rds\",         repo = \"rich-iannone/intendo\",         subdir = \"data-large\"         )       )     preconditions: ~. %>% dplyr::filter(a < 10)     segments: b ~ c(\"group_1\", \"group_2\")     actions:       warn_fraction: 0.1       stop_fraction: 0.2     label: The `tbl_match()` step.     active: false"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Does the target table match a comparison table? — tbl_match","text":"Create simple table three columns four rows values.   Create second table tbl.","code":"tbl <-   dplyr::tibble(     a = c(5, 7, 6, 5),     b = c(7, 1, 0, 0),     c = c(1, 1, 1, 3)   )  tbl #> # A tibble: 4 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     7     1 #> 2     7     1     1 #> 3     6     0     1 #> 4     5     0     3 tbl_2 <-   dplyr::tibble(     a = c(5, 7, 6, 5),     b = c(7, 1, 0, 0),     c = c(1, 1, 1, 3)   )  tbl_2 #> # A tibble: 4 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     7     1 #> 2     7     1     1 #> 3     6     0     1 #> 4     5     0     3"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"a-using-an-agent-with-validation-functions-and-then-interrogate-","dir":"Reference","previous_headings":"","what":"A: Using an agent with validation functions and then interrogate()","title":"Does the target table match a comparison table? — tbl_match","text":"Validate target table (tbl) comparison table (tbl_2) equivalent terms content.   Printing agent console shows validation report Viewer. excerpt validation report, showing single entry corresponds validation step demonstrated .","code":"agent <-   create_agent(tbl = tbl) %>%   tbl_match(tbl_compare = tbl_2) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"b-using-the-validation-function-directly-on-the-data-no-agent-","dir":"Reference","previous_headings":"","what":"B: Using the validation function directly on the data (no agent)","title":"Does the target table match a comparison table? — tbl_match","text":"way using validation functions acts data filter. Data passed stop() single test unit failing. behavior side effects can customized actions option.","code":"tbl %>% tbl_match(tbl_compare = tbl_2) #> # A tibble: 4 x 3 #>       a     b     c #>   <dbl> <dbl> <dbl> #> 1     5     7     1 #> 2     7     1     1 #> 3     6     0     1 #> 4     5     0     3"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"c-using-the-expectation-function","dir":"Reference","previous_headings":"","what":"C: Using the expectation function","title":"Does the target table match a comparison table? — tbl_match","text":"expect_*() form, typically perform one validation time. primarily used testthat tests.","code":"expect_tbl_match(tbl, tbl_compare = tbl_2)"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"d-using-the-test-function","dir":"Reference","previous_headings":"","what":"D: Using the test function","title":"Does the target table match a comparison table? — tbl_match","text":"test_*() form, get single logical value returned us.","code":"tbl %>% test_tbl_match(tbl_compare = tbl_2) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_match.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Does the target table match a comparison table? — tbl_match","text":"2-33","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/tbl_source.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain a table-prep formula from a table store — tbl_source","title":"Obtain a table-prep formula from a table store — tbl_source","text":"tbl_source() function provides convenient means access table-prep formula either tbl_store object table store YAML file (can created yaml_write() function). call tbl_source() useful input tbl argument create_agent(), create_informant(), set_tbl(). need obtain table (generated via table-prep formula), tbl_get() function used .","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_source.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain a table-prep formula from a table store — tbl_source","text":"","code":"tbl_source(tbl, store = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_source.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain a table-prep formula from a table store — tbl_source","text":"tbl table name associated table-prep formula. part table store. table identified name (e.g., tbl = \"large_table\") supplying reference using subset ($) tbl_store object (e.g., tbl = store$large_table). using latter method nothing needs supplied store. store Either table store object created tbl_store() function path table store YAML file created yaml_write().","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_source.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain a table-prep formula from a table store — tbl_source","text":"table-prep formula.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_source.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain a table-prep formula from a table store — tbl_source","text":"create tbl_store object giving two table-prep formulas tbl_store().   can pass table-prep formula create_agent() via tbl_source(), add validation steps, interrogate table shortly thereafter.   agent_1 object can printed see validation report Viewer.    tbl_store object can transformed YAML yaml_write() function. following statement writes tbl_store.yml file default (different name used filename argument):   modify agent's target point table labeled \"sml_table\" YAML representation tbl_store.   can likewise write agent YAML file yaml_write() (writes agent-sml_table.yml default filename allows filename want).   Now agent associated table store present -disk YAML, interrogations can done using yaml_agent_interrogate().","code":"store <-   tbl_store(     small_table_duck ~ db_tbl(       table = small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     sml_table ~ pointblank::small_table   ) agent_1 <-   create_agent(     tbl = ~ tbl_source(\"sml_table\", store),     label = \"`tbl_source()` example\",     actions = action_levels(warn_at = 0.10)   ) %>%   col_exists(columns = c(date, date_time)) %>%   interrogate() agent_1 yaml_write(store) agent_2 <-   agent_1 %>%   set_tbl(     ~ tbl_source(         tbl = \"sml_table\",         store = \"tbl_store.yml\"       )   ) yaml_write(agent_2) agent <- yaml_agent_interrogate(filename = \"agent-sml_table.yml\")"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_source.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Obtain a table-prep formula from a table store — tbl_source","text":"1-9","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/tbl_store.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a store of tables with table-prep formulas: a table store — tbl_store","title":"Define a store of tables with table-prep formulas: a table store — tbl_store","text":"can useful set data sources need just draw necessary. upfront configuration tbl_store() lets us define methods obtaining tabular data mixed sources (e.g., database tables, tables generated flat files, etc.) provide identifiers data preparation procedures. results work convenient way materialize tables tbl_get(). can also get table-prep formula table store tbl_source(). content table-prep formulas can involve reading table location, , can involve data transformation. One can imagine scenarios might (1) procure several mutated variations source table, (2) generate table using disparate data sources, (3) filter rows database table according system time. Another nice aspect organizing table-prep formulas single object supplying tbl argument create_agent() create_informant() via $ notation (e.g, create_agent(tbl = <tbl_store>$<name>)) tbl_source() (e.g., create_agent(tbl = ~ tbl_source(\"<name>\", <tbl_store>))).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_store.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a store of tables with table-prep formulas: a table store — tbl_store","text":"","code":"tbl_store(..., .list = list2(...), .init = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_store.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a store of tables with table-prep formulas: a table store — tbl_store","text":"... Expressions contain table-prep formulas table names data retrieval. Two-sided formulas (e.g, <LHS> ~ <RHS>) used, left-hand side identifier right-hand contains statement obtains table (.e., table-prep formula). LHS omitted identifier generated . .list Allows use list input alternative .... .init can optionally provide initialization statement (one-sided formula) executed whenever tables table store obtained. useful, instance, including library() call can executed table-prep formulas ....","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_store.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a store of tables with table-prep formulas: a table store — tbl_store","text":"tbl_store object contains table-prep formulas.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tbl_store.html","id":"yaml","dir":"Reference","previous_headings":"","what":"YAML","title":"Define a store of tables with table-prep formulas: a table store — tbl_store","text":"pointblank table store can written YAML yaml_write() resulting YAML can used several ways. ideal scenario pointblank agents informants also YAML form. way agent informant can refer table store YAML (via tbl_source()), , processing agents informants can performed yaml_agent_interrogate() yaml_informant_incorporate(). following R code, table store two table-prep formulas generated written YAML (filename given YAML written \"tbl_store.yml\"). R statement generating \"tbl_store.yml\" file:   YAML representation (\"tbl_store.yml\"):   useful want get fresh pulls prepared data source materialized R session (tbl_get() function. example, sml_table_high table can obtained using tbl_get(\"sml_table_high\", \"tbl_store.yml\"). get agent check prepared data periodically, following example tbl_source() useful: R code generate agent checks sml_table_high writing agent YAML:   YAML representation (\"agent-sml_table_high.yml\"):   Now, whenever sml_table_high table needs validated, can done yaml_agent_interrogate() (e.g., yaml_agent_interrogate(\"agent-sml_table_high.yml\")).","code":"tbl_store(   tbl_duckdb ~ db_tbl(small_table, dbname = \":memory:\", dbtype = \"duckdb\"),   sml_table_high ~ small_table %>% dplyr::filter(f == \"high\"),   .init = ~ library(tidyverse) ) %>%   yaml_write() type: tbl_store tbls:   tbl_duckdb: ~ db_tbl(small_table, dbname = \":memory:\", dbtype = \"duckdb\")   sml_table_high: ~ small_table %>% dplyr::filter(f == \"high\") init: ~library(tidyverse) create_agent(   tbl = ~ tbl_source(\"sml_table_high\", \"tbl_store.yml\"),   label = \"An example that uses a table store.\",   actions = action_levels(warn_at = 0.10) ) %>%   col_exists(c(date, date_time)) %>%   write_yaml() tbl: ~ tbl_source(\"sml_table_high\", \"tbl_store.yml\") tbl_name: sml_table_high label: An example that uses a table store. actions:   warn_fraction: 0.1 locale: en steps:   - col_exists:     columns: c(date, date_time)"},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/tbl_store.html","id":"creating-an-in-memory-table-store-and-adding-table-prep-formulas","dir":"Reference","previous_headings":"","what":"Creating an in-memory table store and adding table-prep formulas","title":"Define a store of tables with table-prep formulas: a table store — tbl_store","text":"table store provides way get tables need fairly easily. Think identifier table like provide code necessary obtain table. repeat many times like! define two tables can materialized later: tbl_duckdb (-memory DuckDB database table pointblank's small_table dataset) sml_table_high (filtered version tbl_duckdb):   can see table store store_1 printing :   good check tables can obtained without error. can tbl_get() function. function, need supply given name table-prep formula (quotes) table store object.     can shorten tbl_store() statement syntax pointblank provides. sml_table_high table-prep simply transformation tbl_duckdb, , can use {{ tbl_duckdb }} place repeated statement. Additionally, can provide library() call .init argument tbl_store() dplyr available (thus allowing us use filter(...) instead dplyr::filter(...)). revised tbl_store() call:   Printing table store store_2 now shows used .init statement:   Checking tbl_get() provide tables :","code":"store_1 <-   tbl_store(     tbl_duckdb ~       db_tbl(         pointblank::small_table,         dbname = \":memory:\",         dbtype = \"duckdb\"       ),     sml_table_high ~       db_tbl(         pointblank::small_table,         dbname = \":memory:\",         dbtype = \"duckdb\"       ) %>%       dplyr::filter(f == \"high\")   ) store_1 ## -- The `table_store` table-prep formulas ## 1 tbl_duckdb // ~ db_tbl(pointblank::small_table, dbname = \":memory:\", ## dbtype = \"duckdb\") ## 2 sml_table_high // ~ db_tbl(pointblank::small_table, dbname = \":memory:\", ## dbtype = \"duckdb\") %>% dplyr::filter(f == \"high\") ## ---- tbl_get(tbl = \"tbl_duckdb\", store = store_1) ## # Source:   table<pointblank::small_table> [?? x 8] ## # Database: duckdb_connection ##    date_time           date           a b             c      d e     f ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high ## # … with more rows tbl_get(tbl = \"sml_table_high\", store = store_1) ## # Source:   lazy query [?? x 8] ## # Database: duckdb_connection ##   date_time           date           a b             c     d e     f ##   <dttm>              <date>     <int> <chr>     <dbl> <dbl> <lgl> <chr> ## 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3 3423. TRUE  high ## 2 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3 2343. TRUE  high ## 3 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE  high ## 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high ## 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high ## 6 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE  high store_2 <-   tbl_store(     tbl_duckdb ~       db_tbl(         pointblank::small_table,         dbname = \":memory:\",         dbtype = \"duckdb\"       ),     sml_table_high ~       {{ tbl_duckdb }} %>%       filter(f == \"high\"),     .init = ~ library(tidyverse)   ) store_2 ## -- The `table_store` table-prep formulas ## 1 tbl_duckdb // ~ db_tbl(pointblank::small_table, dbname = \":memory:\", ## dbtype = \"duckdb\") ## 2 sml_table_high // ~ {{tbl_duckdb}} %>% filter(f == \"high\") ## ---- ## INIT // ~library(tidyverse) ## ---- tbl_get(tbl = \"tbl_duckdb\", store = store_2) ## # Source:   table<pointblank::small_table> [?? x 8] ## # Database: duckdb_connection ##    date_time           date           a b             c      d e     f ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high ## # … with more rows tbl_get(tbl = \"sml_table_high\", store = store_2) ## # Source:   lazy query [?? x 8] ## # Database: duckdb_connection ##   date_time           date           a b             c     d e     f ##   <dttm>              <date>     <int> <chr>     <dbl> <dbl> <lgl> <chr> ## 1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3 3423. TRUE  high ## 2 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3 2343. TRUE  high ## 3 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE  high ## 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high ## 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high ## 6 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_store.html","id":"using-a-table-store-in-a-data-validation-workflow","dir":"Reference","previous_headings":"","what":"Using a table store in a data validation workflow","title":"Define a store of tables with table-prep formulas: a table store — tbl_store","text":"Define tbl_store object adding table-prep formulas inside tbl_store() call.   get summary table store store_3 printing:   object available, can check table interest produced specification tbl_get() function.   Another way get table materialized using $ get entry choice tbl_get().   Creating agent easy table-prep formulas encapsulated tbl_store object. Use $ notation pass appropriate procedure reading table tbl argument.   ways use table store assign target table agent, like using tbl_source() function (extracts table-prep formula table store).","code":"store_3 <-   tbl_store(     small_table_duck ~ db_tbl(       table = small_table,       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     ~ db_tbl(       table = \"rna\",       dbname = \"pfmegrnargs\",       dbtype = \"postgres\",       host = \"hh-pgsql-public.ebi.ac.uk\",       port = 5432,       user = I(\"reader\"),       password = I(\"NWDMCE5xdipIjRrp\")     ),     all_revenue ~ db_tbl(       table = file_tbl(         file = from_github(           file = \"sj_all_revenue_large.rds\",           repo = \"rich-iannone/intendo\",           subdir = \"data-large\"         )       ),       dbname = \":memory:\",       dbtype = \"duckdb\"     ),     sml_table ~ pointblank::small_table   ) store_3 ## -- The `table_store` table-prep formulas ## 1 small_table_duck // ~ db_tbl(table = small_table, dbname = \":memory:\", ## dbtype = \"duckdb\") ## 2 rna // ~db_tbl(table = \"rna\", dbname = \"pfmegrnargs\", dbtype = ## \"postgres\", host = \"hh-pgsql-public.ebi.ac.uk\", port = 5432, user = ## I(\"reader\"), password = I(\"NWDMCE5xdipIjRrp\")) ## 3 all_revenue // ~ db_tbl(table = file_tbl(file = from_github(file = ## \"sj_all_revenue_large.rds\", repo = \"rich-iannone/intendo\", subdir = ## \"data-large\")), dbname = \":memory:\", dbtype = \"duckdb\") ## 4 sml_table // ~ pointblank::small_table ## ---- tbl_get(   tbl = \"small_table_duck\",   store = store_3 ) ## # Source:   table<small_table> [?? x 8] ## # Database: duckdb_connection ##    date_time           date           a b             c      d e     f ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high ## # … with more rows store_3$small_table_duck %>% tbl_get() ## # Source:   table<small_table> [?? x 8] ## # Database: duckdb_connection ##    date_time           date           a b             c      d e     f ##    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> ##  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high ##  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low ##  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high ##  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid ##  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low ##  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid ##  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high ##  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low ##  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high ## 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high ## # … with more rows agent_1 <-   create_agent(     tbl = store_3$small_table_duck   ) agent_2 <-   create_agent(     tbl = ~ tbl_source(       tbl = \"small_table_duck\",       store = store_3       )   )"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_store.html","id":"writing-a-table-store-to-a-yaml-file","dir":"Reference","previous_headings":"","what":"Writing a table store to a YAML file","title":"Define a store of tables with table-prep formulas: a table store — tbl_store","text":"table store can moved YAML yaml_write tbl_source() call refer -disk table store. YAML conversion.   writes tbl_store.yml file (providing filename default filename chosen). can convenient read table-prep formulas YAML file table store. achieve , can modify tbl_source() statement create_agent() call store refers -disk YAML file.","code":"yaml_write(store_3) agent_3 <-   create_agent(     tbl = ~ tbl_source(       tbl = \"small_table_duck\",       store = \"tbl_store.yml\"     )   )"},{"path":"https://rstudio.github.io/pointblank/reference/tbl_store.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Define a store of tables with table-prep formulas: a table store — tbl_store","text":"1-8","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/tt_string_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: obtain a summary table for string columns — tt_string_info","title":"Table Transformer: obtain a summary table for string columns — tt_string_info","text":"table object, can produce summary table scoped string-based columns. output summary table leading column called \".param.\" labels three rows, corresponding following pieces information pertaining string length: Mean String Length (\"length_mean\") Minimum String Length (\"length_min\") Maximum String Length (\"length_max\") string data input table generate columns output table. Column names input used output, preserving order well.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_string_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: obtain a summary table for string columns — tt_string_info","text":"","code":"tt_string_info(tbl)"},{"path":"https://rstudio.github.io/pointblank/reference/tt_string_info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: obtain a summary table for string columns — tt_string_info","text":"tbl data table obj:<tbl_*> // required table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_string_info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: obtain a summary table for string columns — tt_string_info","text":"tibble object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_string_info.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: obtain a summary table for string columns — tt_string_info","text":"Get string information string-based columns game_revenue dataset included pointblank package.   Ensure player_id session_id values always fixed numbers characters (15 24, respectively) throughout table.   see data, error, validations successful! use tt_string_info()-transformed table test_col_vals_lte() check maximum string length column f small_table dataset greater 4.","code":"tt_string_info(tbl = game_revenue) #> # A tibble: 3 x 7 #>   .param.     player_id session_id item_type item_name acquisition country #>   <chr>           <dbl>      <dbl>     <dbl>     <dbl>       <dbl>   <dbl> #> 1 length_mean        15         24      2.22      7.35        7.97    8.53 #> 2 length_min         15         24      2         5           5       5 #> 3 length_max         15         24      3        11          14      14 tt_string_info(tbl = game_revenue) %>%   col_vals_equal(     columns = player_id,     value = 15   ) %>%   col_vals_equal(     columns = session_id,     value = 24   ) #> # A tibble: 3 x 7 #>   .param.     player_id session_id item_type item_name acquisition country #>   <chr>           <dbl>      <dbl>     <dbl>     <dbl>       <dbl>   <dbl> #> 1 length_mean        15         24      2.22      7.35        7.97    8.53 #> 2 length_min         15         24      2         5           5       5 #> 3 length_max         15         24      3        11          14      14 tt_string_info(tbl = small_table) %>%   test_col_vals_lte(     columns = f,     value = 4   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/tt_string_info.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: obtain a summary table for string columns — tt_string_info","text":"12-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/tt_summary_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: obtain a summary stats table for numeric columns — tt_summary_stats","title":"Table Transformer: obtain a summary stats table for numeric columns — tt_summary_stats","text":"table object, can produce summary table scoped numeric column values. output summary table leading column called \".param.\" labels nine rows, corresponding following summary statistics: Minimum (\"min\") 5th Percentile (\"p05\") 1st Quartile (\"q_1\") Median (\"med\") 3rd Quartile (\"q_3\") 95th Percentile (\"p95\") Maximum (\"max\") Interquartile Range (\"iqr\") Range (\"range\") numerical data input table generate columns output table. Column names input used output, preserving order well.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_summary_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: obtain a summary stats table for numeric columns — tt_summary_stats","text":"","code":"tt_summary_stats(tbl)"},{"path":"https://rstudio.github.io/pointblank/reference/tt_summary_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: obtain a summary stats table for numeric columns — tt_summary_stats","text":"tbl data table obj:<tbl_*> // required table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_summary_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: obtain a summary stats table for numeric columns — tt_summary_stats","text":"tibble object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_summary_stats.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: obtain a summary stats table for numeric columns — tt_summary_stats","text":"Get summary statistics game_revenue dataset included pointblank package.   Table transformers work great conjunction validation functions. ensure maximum revenue individual purchases game_revenue table less $150.   see data, error, validation successful! another: -app purchases game_revenue table, check median revenue somewhere $8 $12.   can get creative transformer. use transformed table validation plan? performing validations game_revenue table agent can include revenue check using tt_summary_stats() preconditions argument. transforms target table summary table validation step. final step transformation preconditions dplyr::filter() step isolates row median statistic.   Printing agent console shows validation report Viewer. excerpt validation report. Take note final step (STEP 3) shows entry corresponds col_vals_between() validation step uses summary stats table target.","code":"tt_summary_stats(tbl = game_revenue) #> # A tibble: 9 x 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0                 3.2 #> 2 p05             0.02              8.2 #> 3 q_1             0.09             18.5 #> 4 med             0.38             26.5 #> 5 q_3             1.25             33.8 #> 6 p95            22.0              39.5 #> 7 max           143.               41 #> 8 iqr             1.16             15.3 #> 9 range         143.               37.8 tt_summary_stats(tbl = game_revenue) %>%   col_vals_lt(     columns = item_revenue,     value = 150,     segments = .param. ~ \"max\"   ) #> # A tibble: 9 x 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0                 3.2 #> 2 p05             0.02              8.2 #> 3 q_1             0.09             18.5 #> 4 med             0.38             26.5 #> 5 q_3             1.25             33.8 #> 6 p95            22.0              39.5 #> 7 max           143.               41 #> 8 iqr             1.16             15.3 #> 9 range         143.               37.8 game_revenue %>%   dplyr::filter(item_type == \"iap\") %>%   tt_summary_stats() %>%   col_vals_between(     columns = item_revenue,     left = 8, right = 12,     segments = .param. ~ \"med\"   ) #> # A tibble: 9 x 3 #>   .param. item_revenue session_duration #>   <chr>          <dbl>            <dbl> #> 1 min             0.4              3.2 #> 2 p05             1.39             5.99 #> 3 q_1             4.49            14.0 #> 4 med            10.5             22.6 #> 5 q_3            20.3             30.6 #> 6 p95            66.0             38.8 #> 7 max           143.              41 #> 8 iqr            15.8             16.7 #> 9 range         143.              37.8 agent <-   create_agent(     tbl = game_revenue,     tbl_name = \"game_revenue\",     label = \"`tt_summary_stats()` example.\",     actions = action_levels(       warn_at = 0.10,       stop_at = 0.25,       notify_at = 0.35     )   ) %>%   rows_complete() %>%   rows_distinct() %>%   col_vals_between(     columns = item_revenue,     left = 8, right = 12,     preconditions = ~ . %>%       dplyr::filter(item_type == \"iap\") %>%       tt_summary_stats() %>%       dplyr::filter(.param. == \"med\")   ) %>%   interrogate()"},{"path":"https://rstudio.github.io/pointblank/reference/tt_summary_stats.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: obtain a summary stats table for numeric columns — tt_summary_stats","text":"12-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/tt_tbl_colnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: get a table's column names — tt_tbl_colnames","title":"Table Transformer: get a table's column names — tt_tbl_colnames","text":"table object, can produce summary table contains table's column names. output summary table two columns many rows columns input table. first column \".param.\" column, integer-based column containing indices columns input table. second column, \"value\", contains column names input table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_tbl_colnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: get a table's column names — tt_tbl_colnames","text":"","code":"tt_tbl_colnames(tbl)"},{"path":"https://rstudio.github.io/pointblank/reference/tt_tbl_colnames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: get a table's column names — tt_tbl_colnames","text":"tbl data table obj:<tbl_*> // required table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_tbl_colnames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: get a table's column names — tt_tbl_colnames","text":"tibble object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_tbl_colnames.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: get a table's column names — tt_tbl_colnames","text":"Get column names game_revenue dataset included pointblank package.   output table useful want validate column names table. , check game_revenue table, included pointblank package, certain column names present test_col_vals_make_subset().   can check see whether column names specifications table less 15 characters length. , use combination tt_tbl_colnames(), tt_string_info(), finally test_col_vals_lt() perform test.   returned FALSE column name credit_card_numbers 16 characters long.","code":"tt_tbl_colnames(tbl = game_revenue) #> # A tibble: 11 x 2 #>    .param. value #>      <int> <chr> #>  1       1 player_id #>  2       2 session_id #>  3       3 session_start #>  4       4 time #>  5       5 item_type #>  6       6 item_name #>  7       7 item_revenue #>  8       8 session_duration #>  9       9 start_day #> 10      10 acquisition #> 11      11 country tt_tbl_colnames(tbl = game_revenue) %>%   test_col_vals_make_subset(     columns = value,     set = c(\"acquisition\", \"country\")   ) #> [1] TRUE specifications %>%   tt_tbl_colnames() %>%   tt_string_info() %>%   test_col_vals_lt(     columns = value,     value = 15   ) #> [1] FALSE"},{"path":"https://rstudio.github.io/pointblank/reference/tt_tbl_colnames.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: get a table's column names — tt_tbl_colnames","text":"12-4","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/tt_tbl_dims.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: get the dimensions of a table — tt_tbl_dims","title":"Table Transformer: get the dimensions of a table — tt_tbl_dims","text":"table object, can produce summary table contains nothing table's dimensions: number rows number columns. output summary table two columns two rows. first \".param.\" column labels \"rows\" \"columns\"; second column, \"value\", contains row column counts.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_tbl_dims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: get the dimensions of a table — tt_tbl_dims","text":"","code":"tt_tbl_dims(tbl)"},{"path":"https://rstudio.github.io/pointblank/reference/tt_tbl_dims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: get the dimensions of a table — tt_tbl_dims","text":"tbl data table obj:<tbl_*> // required table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_tbl_dims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: get the dimensions of a table — tt_tbl_dims","text":"tibble object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_tbl_dims.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: get the dimensions of a table — tt_tbl_dims","text":"Get dimensions game_revenue dataset included pointblank package.   output table useful table validation depends dimensions. , check game_revenue least 1500 rows.   can check small_table ensure number columns less 10.","code":"tt_tbl_dims(tbl = game_revenue) #> # A tibble: 2 x 2 #>   .param. value #>   <chr>   <int> #> 1 rows     2000 #> 2 columns    11 tt_tbl_dims(tbl = game_revenue) %>%   dplyr::filter(.param. == \"rows\") %>%   test_col_vals_gt(     columns = value,     value = 1500   ) #> [1] TRUE tt_tbl_dims(tbl = small_table) %>%   dplyr::filter(.param. == \"columns\") %>%   test_col_vals_lt(     columns = value,     value = 10   ) #> [1] TRUE"},{"path":"https://rstudio.github.io/pointblank/reference/tt_tbl_dims.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: get the dimensions of a table — tt_tbl_dims","text":"12-3","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: shift the times of a table — tt_time_shift","title":"Table Transformer: shift the times of a table — tt_time_shift","text":"table object containing date date-time columns, values can precisely shifted tt_time_shift() specification time shift. can either provide string time shift components shift direction (like \"-4y 10d\") difftime object (can created via lubridate expressions using base::difftime() function).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: shift the times of a table — tt_time_shift","text":"","code":"tt_time_shift(tbl, time_shift = \"0y 0m 0d 0H 0M 0S\")"},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: shift the times of a table — tt_time_shift","text":"tbl data table obj:<tbl_*> // required table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object. time_shift Time-shift specification scalar<character> // default: \"0y 0m 0d 0H 0M 0S\" Either character-based representation specifies time difference time values time-based columns shifted, , difftime object. character string constructed format \"0y 0m 0d 0H 0M 0S\" individual time components can omitted (.e., \"1y 5d\" valid specification shifting time values ahead one year five days). Adding \"-\" beginning string (e.g., \"-2y\") shift time values back.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: shift the times of a table — tt_time_shift","text":"data frame, tibble, tbl_dbi object, tbl_spark object depending provided tbl.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_shift.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Table Transformer: shift the times of a table — tt_time_shift","text":"time_shift specification higher time granularity least granular time column input table. Put simpler terms, date-based based columns (just single date-based column) time shifting can terms years, months, days. Using time_shift specification \"20d 6H\" presence dates result truncation \"20d\". Similarly, difftime object altered circumstances, however, object resolved exact number days rounding.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_shift.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: shift the times of a table — tt_time_shift","text":"use game_revenue dataset, included pointblank package, input table first demo. entries first 21 days 2015 move date date-time values beginning 2021 tt_time_shift() function \"6y\" time_shift specification.   Keeping date_time -f columns small_table, also included package, shift times back 2 days 12 hours \"-2d 12H\" specification.","code":"tt_time_shift(   tbl = game_revenue,   time_shift = \"6y\" ) #> # A tibble: 2,000 x 11 #>    player_id       session_id  session_start       time                item_type #>    <chr>           <chr>       <dttm>              <dttm>              <chr> #>  1 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 01:31:03 2021-01-01 01:31:27 iap #>  2 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 01:31:03 2021-01-01 01:36:57 iap #>  3 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 01:31:03 2021-01-01 01:37:45 iap #>  4 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 01:31:03 2021-01-01 01:42:33 ad #>  5 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 11:50:02 2021-01-01 11:55:20 ad #>  6 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 11:50:02 2021-01-01 12:08:56 ad #>  7 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 11:50:02 2021-01-01 12:14:08 ad #>  8 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 11:50:02 2021-01-01 12:21:44 ad #>  9 ECPANOIXLZHF896 ECPANOIXLZ~ 2021-01-01 11:50:02 2021-01-01 12:24:20 ad #> 10 FXWUORGYNJAE271 FXWUORGYNJ~ 2021-01-01 15:17:18 2021-01-01 15:19:36 ad #> # i 1,990 more rows #> # i 6 more variables: item_name <chr>, item_revenue <dbl>, #> #   session_duration <dbl>, start_day <date>, acquisition <chr>, country <chr> small_table %>%   dplyr::select(-date) %>%   tt_time_shift(\"-2d 12H\") #> # A tibble: 13 x 7 #>    date_time               a b             c      d e     f #>    <dttm>              <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-01 23:00:00     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-01 12:32:00     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-03 01:32:00     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-04 05:23:00     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-07 00:36:00     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-08 18:15:00     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-13 06:46:00     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-14 23:27:00     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-17 16:30:00     3 5-bce-642     9   838. FALSE high #> 10 2016-01-17 16:30:00     3 5-bce-642     9   838. FALSE high #> 11 2016-01-24 08:07:00     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-25 14:51:00     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-27 23:23:00     1 3-dka-303    NA  2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_shift.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: shift the times of a table — tt_time_shift","text":"12-5","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Table Transformer: slice a table with a slice point on a time column — tt_time_slice","title":"Table Transformer: slice a table with a slice point on a time column — tt_time_slice","text":"table object containing date, date-time columns, mixture thereof, one columns can used effectively slice data table two slice_point: get choose slices want keep. slice point can defined several ways. One method involves using decimal value 0 1, defines slice point time instant somewhere earliest time value (0) latest time value (1). Another way defining slice point supplying time value, following input types accepted: (1) ISO 8601 formatted time string (date date-time), (2) POSIXct time, (3) Date object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table Transformer: slice a table with a slice point on a time column — tt_time_slice","text":"","code":"tt_time_slice(   tbl,   time_column = NULL,   slice_point = 0,   keep = c(\"left\", \"right\"),   arrange = FALSE )"},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Table Transformer: slice a table with a slice point on a time column — tt_time_slice","text":"tbl data table obj:<tbl_*> // required table object used input transformation. can data frame, tibble, tbl_dbi object, tbl_spark object. time_column Column time data scalar<character> // default: NULL (optional) time-based column used basis slicing. time column provided first one found used. slice_point scalar<numeric|character|POSIXct|Date> // default: 0 location time_column slicing occur. can either decimal value 0 1, ISO 8601 formatted time string (date date-time), POSIXct time, Date object. keep Data slice keep singl-kw:[left|right] // default: \"left\" slice kept? \"left\" side (default) contains data rows earlier slice_point \"right\" side rows later. arrange Arrange data slice time data? scalar<logical> // default: FALSE slice arranged time_column? may useful input tbl ordered time_column. default, FALSE original ordering retained.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Table Transformer: slice a table with a slice point on a time column — tt_time_slice","text":"data frame, tibble, tbl_dbi object, tbl_spark object depending provided tbl.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_slice.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Table Transformer: slice a table with a slice point on a time column — tt_time_slice","text":"option arrange table date date-time values time_column. ordering always done ascending manner. NA/NULL values time_column result corresponding rows can removed (matter slice retained).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_slice.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Table Transformer: slice a table with a slice point on a time column — tt_time_slice","text":"use game_revenue dataset, included pointblank package, input table first demo. entries first 21 days 2015 elect get records time values strictly first 15 days 2015. keep argument default \"left\" rows time column less \"2015-01-16 00:00:00\" kept.   Omit first 25% records small_table, also included package, fractional slice_point 0.25 basis timeline begins 2016-01-04 11:00:00 ends 2016-01-30 11:23:00.","code":"tt_time_slice(   tbl = game_revenue,   time_column = \"time\",   slice_point = \"2015-01-16\" ) #> # A tibble: 1,208 x 11 #>    player_id       session_id  session_start       time                item_type #>    <chr>           <chr>       <dttm>              <dttm>              <chr> #>  1 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:31:27 iap #>  2 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:36:57 iap #>  3 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:37:45 iap #>  4 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 01:31:03 2015-01-01 01:42:33 ad #>  5 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 11:55:20 ad #>  6 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:08:56 ad #>  7 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:14:08 ad #>  8 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:21:44 ad #>  9 ECPANOIXLZHF896 ECPANOIXLZ~ 2015-01-01 11:50:02 2015-01-01 12:24:20 ad #> 10 FXWUORGYNJAE271 FXWUORGYNJ~ 2015-01-01 15:17:18 2015-01-01 15:19:36 ad #> # i 1,198 more rows #> # i 6 more variables: item_name <chr>, item_revenue <dbl>, #> #   session_duration <dbl>, start_day <date>, acquisition <chr>, country <chr> small_table %>%   tt_time_slice(     slice_point = 0.25,     keep = \"right\"   ) #> # A tibble: 8 x 8 #>   date_time           date           a b             c     d e     f #>   <dttm>              <date>     <int> <chr>     <dbl> <dbl> <lgl> <chr> #> 1 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4 3291. TRUE  mid #> 2 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3  843. TRUE  high #> 3 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2 1036. FALSE low #> 4 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high #> 5 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9  838. FALSE high #> 6 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7  834. TRUE  low #> 7 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8  108. FALSE low #> 8 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA 2230. TRUE  high"},{"path":"https://rstudio.github.io/pointblank/reference/tt_time_slice.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Table Transformer: slice a table with a slice point on a time column — tt_time_slice","text":"12-6","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/validate_rmd.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform pointblank validation testing within R Markdown documents — validate_rmd","title":"Perform pointblank validation testing within R Markdown documents — validate_rmd","text":"validate_rmd() function sets framework validation testing within specialized validation code chunks inside R Markdown document. enable functionality, validate_rmd() called early within R Markdown document code chunk (preferably setup chunk) signal validation occur within specific code chunks. validation code chunks require validate = TRUE option set. Using pointblank validation functions data marked code chunks flag overall failure stop threshold exceeded anywhere. errors reported validation code chunk rendering document HTML, centered status button either indicates success number overall failures. Clicking button reveals otherwise hidden validation statements error messages ().","code":""},{"path":"https://rstudio.github.io/pointblank/reference/validate_rmd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform pointblank validation testing within R Markdown documents — validate_rmd","text":"","code":"validate_rmd(summary = TRUE, log_to_file = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/validate_rmd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform pointblank validation testing within R Markdown documents — validate_rmd","text":"summary Include validation summary scalar<logical> // default: TRUE TRUE leading summary validations rendered R Markdown document. FALSE, element shown. log_to_file Log validation results file scalar<logical|character> // default: NULL (optional) option log errors text file. default, logging done TRUE write log entries \"validation_errors.log\" working directory. enable logging specify file name, include path log file desired name.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/validate_rmd.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Perform pointblank validation testing within R Markdown documents — validate_rmd","text":"1-4","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/write_testthat_file.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a pointblank agent to a testthat test file — write_testthat_file","title":"Transform a pointblank agent to a testthat test file — write_testthat_file","text":"pointblank agent, can write testthat test file opt place testthat/tests available project path (can specify alternate path well). works transforming validation steps series expect_*() calls inside individual testthat::test_that() statements. major requirement using write_testthat_file() agent presence expression can retrieve target table. Typically, might supply table-prep formula, formula can invoked obtain target table (e.g., tbl = ~ pointblank::small_table). user-supplied statement used write_testthat_file() generate table-loading statement top new testthat test file target table available testthat::test_that() statements follow. agent created using table-prep formula set tbl, can modified via set_tbl() function. Thresholds obtained applied stop state. can set pointblank agent passing action_levels object actions argument create_agent() argument included validation function. stop thresholds available, threshold value 1 used generated expect_*() statement resulting testthat test file. requirement agent first undergo interrogation interrogate(). However, may useful dry run interactively perform interrogation target data generating testthat test file.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/write_testthat_file.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a pointblank agent to a testthat test file — write_testthat_file","text":"","code":"write_testthat_file(   agent,   name = NULL,   path = NULL,   overwrite = FALSE,   skips = NULL,   quiet = FALSE )"},{"path":"https://rstudio.github.io/pointblank/reference/write_testthat_file.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a pointblank agent to a testthat test file — write_testthat_file","text":"agent pointblank agent object obj:<ptblank_agent> // required pointblank agent object commonly created use create_agent() function. name Name generated testthat file scalar<character> // default: NULL (optional) optional name testhat test file. name without extension without leading \"test-\" text. nothing supplied, name derived tbl_name agent. present, generic name used. path File path scalar<character> // default: NULL (optional) path can specified attempt place file testthat/tests. overwrite Overwrite previous file name scalar<logical> // default: FALSE testthat file name overwritten? skips Test skipping vector<character> // default: NULL (optional) optional vector test-skipping keywords modeled testthat skip_on_*() functions. following keywords can used include skip_on_*() statements: \"cran\" (testthat::skip_on_cran()), \"travis\" (testthat::skip_on_travis()), \"appveyor\" (testthat::skip_on_appveyor()), \"ci\" (testthat::skip_on_ci()), \"covr\" (testthat::skip_on_covr()), \"bioc\" (testthat::skip_on_bioc()). keywords skipping tests certain operating systems insert specific testthat::skip_on_os() call. \"windows\" (skip_on_os(\"windows\")), \"mac\" (skip_on_os(\"mac\")), \"linux\" (skip_on_os(\"linux\")), \"solaris\" (skip_on_os(\"solaris\")). calls placed top generated testthat test file. quiet Inform () upon file writing scalar<logical> // default: FALSE function inform file written?","code":""},{"path":"https://rstudio.github.io/pointblank/reference/write_testthat_file.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a pointblank agent to a testthat test file — write_testthat_file","text":"Invisibly returns TRUE testthat file written.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/write_testthat_file.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transform a pointblank agent to a testthat test file — write_testthat_file","text":"Tests inactive validation steps skipped clear message indicating reason skipping due test active. inactive validation steps can forced active state using activate_steps() agent (opposite possible deactivate_steps() function). testthat package comes series skip_on_*() functions conveniently cause test file skipped entirely certain conditions met. can quickly set number top testthat test file supplying keywords vector skips option write_testthat_file(). instance, setting skips = c(\"cran\", \"windows) add testthat skip_on_cran() skip_on_os(\"windows\") statements, meaning generated test file run CRAN system system OS Windows. example testthat test file output (\"test-small_table.R\"):   generated following set R statements:","code":"# Generated by pointblank  tbl <- small_table  test_that(\"column `date_time` exists\", {    expect_col_exists(     tbl,     columns = date_time,     threshold = 1   ) })  test_that(\"values in `c` should be <= `5`\", {    expect_col_vals_lte(     tbl,     columns = c,     value = 5,     threshold = 0.25   ) }) library(pointblank)  agent <-   create_agent(     tbl = ~ small_table,     actions = action_levels(stop_at = 0.25)   ) %>%   col_exists(date_time) %>%   col_vals_lte(c, value = 5)  write_testthat_file(   agent = agent,   name = \"small_table\",   path = \".\" )"},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/write_testthat_file.html","id":"creating-a-testthat-file-from-an-agent","dir":"Reference","previous_headings":"","what":"Creating a testthat file from an agent","title":"Transform a pointblank agent to a testthat test file — write_testthat_file","text":"walk data quality analysis extremely small table. actually called small_table can find dataset package.   Creating action_levels object common workflow step creating pointblank agent. designate failure thresholds warn, stop, notify states using action_levels().   pointblank agent object now created al object provided agent. static thresholds provided al object make reports bit useful interrogation.   agent checks can transformed testthat file write_testthat_file(). stop thresholds ported expect_*() functions new file.   code generate file name \"test-small_table.R\". path specified \".\" file placed working directory. like easily add new file tests/testthat directory path = NULL (default) makes possible (useful package development). new file? :","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high al <-   action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   ) agent <-   create_agent(     tbl = ~ small_table,     label = \"An example.\",     actions = al   ) %>%   col_exists(c(date, date_time)) %>%   col_vals_regex(     b,     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   col_vals_gt(d, value = 100) %>%   col_vals_lte(c, value = 5) %>%   interrogate() write_testthat_file(   agent = agent,   name = \"small_table\",   path = \".\" ) # Generated by pointblank  tbl <- small_table  test_that(\"column `date` exists\", {    expect_col_exists(     tbl,     columns = date,     threshold = 1   ) })  test_that(\"column `date_time` exists\", {    expect_col_exists(     tbl,     columns = date_time,     threshold = 1   ) })  test_that(\"values in `b` should match the regular expression: `[0-9]-[a-z]{3}-[0-9]{3}`\", {    expect_col_vals_regex(     tbl,     columns = b,     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\",     threshold = 0.25   ) })  test_that(\"values in `d` should be > `100`\", {    expect_col_vals_gt(     tbl,     columns = d,     value = 100,     threshold = 0.25   ) })  test_that(\"values in `c` should be <= `5`\", {    expect_col_vals_lte(     tbl,     columns = c,     value = 5,     threshold = 0.25   ) })"},{"path":"https://rstudio.github.io/pointblank/reference/write_testthat_file.html","id":"using-an-agent-stored-on-disk-as-a-yaml-file","dir":"Reference","previous_headings":"","what":"Using an agent stored on disk as a YAML file","title":"Transform a pointblank agent to a testthat test file — write_testthat_file","text":"agent disk YAML file can made testthat file. \"agent-small_table.yml\" file available pointblank package path can obtained system.file().   Writing testthat file working directory much reading agent disk time. read write combo, really. , choosing write file working directory using path = \".\".","code":"yml_file <-   system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) write_testthat_file(   agent = yaml_read_agent(yml_file),   name = \"from_agent_yaml\",   path = \".\" )"},{"path":"https://rstudio.github.io/pointblank/reference/write_testthat_file.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Transform a pointblank agent to a testthat test file — write_testthat_file","text":"8-5","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/x_read_disk.html","id":null,"dir":"Reference","previous_headings":"","what":"Read an agent, informant, multiagent, or table scan from disk — x_read_disk","title":"Read an agent, informant, multiagent, or table scan from disk — x_read_disk","text":"agent, informant, multiagent, table scan written disk (x_write_disk()) can read back memory x_read_disk() function. agent informant object generated way, may data table associated (depending whether keep_tbl option TRUE FALSE writing disk) still able produce reporting (printing agent informant console using get_agent_report()/get_informant_report()). agent return x-list get_agent_x_list() yield available data extracts get_data_extracts(). Furthermore, agent's validation steps still present (along results last interrogation).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/x_read_disk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read an agent, informant, multiagent, or table scan from disk — x_read_disk","text":"","code":"x_read_disk(filename, path = NULL, quiet = FALSE)"},{"path":"https://rstudio.github.io/pointblank/reference/x_read_disk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read an agent, informant, multiagent, or table scan from disk — x_read_disk","text":"filename File name scalar<character> // required name file previously written x_write_disk(). path File path scalar<character> // default: NULL (optional) optional path file (combined filename). quiet Inform () upon file writing scalar<logical> // default: FALSE function inform file written?","code":""},{"path":"https://rstudio.github.io/pointblank/reference/x_read_disk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read an agent, informant, multiagent, or table scan from disk — x_read_disk","text":"Either ptblank_agent, ptblank_informant, ptblank_tbl_scan object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/x_read_disk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read an agent, informant, multiagent, or table scan from disk — x_read_disk","text":"written--disk agent informant possess table-prep formula specific -memory tablewe use interrogate() incorporate() function . data quality reporting workflow, useful interrogate() target tables evolve time. validation steps used, can added calling interrogate(). information management workflow informant object, using incorporate() update aspects reporting table dimensions, info snippets/text regenerated.","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/x_read_disk.html","id":"a-reading-an-agent-from-disk","dir":"Reference","previous_headings":"","what":"A: Reading an agent from disk","title":"Read an agent, informant, multiagent, or table scan from disk — x_read_disk","text":"process developing agent writing disk x_write_disk() function explained function's documentation. Suppose written file named \"agent-small_table.rds\", read new agent object x_read_disk().","code":"agent <- x_read_disk(\"agent-small_table.rds\")"},{"path":"https://rstudio.github.io/pointblank/reference/x_read_disk.html","id":"b-reading-an-informant-from-disk","dir":"Reference","previous_headings":"","what":"B: Reading an informant from disk","title":"Read an agent, informant, multiagent, or table scan from disk — x_read_disk","text":"informant written disk via x_write_disk() named \"informant-small_table.rds\". read new informant object x_read_disk().","code":"informant <- x_read_disk(\"informant-small_table.rds\")"},{"path":"https://rstudio.github.io/pointblank/reference/x_read_disk.html","id":"c-reading-a-multiagent-from-disk","dir":"Reference","previous_headings":"","what":"C: Reading a multiagent from disk","title":"Read an agent, informant, multiagent, or table scan from disk — x_read_disk","text":"process creating multiagent writing disk x_write_disk() function shown function's documentation. written file called \"multiagent-small_table.rds\", read new multiagent object x_read_disk().","code":"multiagent <- x_read_disk(\"multiagent-small_table.rds\")"},{"path":"https://rstudio.github.io/pointblank/reference/x_read_disk.html","id":"d-reading-a-table-scan-from-disk","dir":"Reference","previous_headings":"","what":"D: Reading a table scan from disk","title":"Read an agent, informant, multiagent, or table scan from disk — x_read_disk","text":"table scan written disk via x_write_disk() named \"tbl_scan-storms.rds\", read back R x_read_disk().","code":"tbl_scan <- x_read_disk(\"tbl_scan-storms.rds\")"},{"path":"https://rstudio.github.io/pointblank/reference/x_read_disk.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Read an agent, informant, multiagent, or table scan from disk — x_read_disk","text":"9-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/x_write_disk.html","id":null,"dir":"Reference","previous_headings":"","what":"Write an agent, informant, multiagent, or table scan to disk — x_write_disk","title":"Write an agent, informant, multiagent, or table scan to disk — x_write_disk","text":"Writing agent, informant, multiagent, even table scan disk x_write_disk() can useful keeping data validation intel table information close hand later retrieval (x_read_disk()). default, data table agent informant may held committed disk expunged (applicable table scan since never hold table object). behavior can changed setting keep_tbl TRUE works case table tbl_dbi tbl_spark class.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/x_write_disk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write an agent, informant, multiagent, or table scan to disk — x_write_disk","text":"","code":"x_write_disk(   x,   filename,   path = NULL,   keep_tbl = FALSE,   keep_extracts = FALSE,   quiet = FALSE )"},{"path":"https://rstudio.github.io/pointblank/reference/x_write_disk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write an agent, informant, multiagent, or table scan to disk — x_write_disk","text":"x One several types objects <object> // required agent object class ptblank_agent, informant class ptblank_informant, table scan class ptblank_tbl_scan. filename File name scalar<character> // required filename create disk agent, informant, table scan. path File path scalar<character> // default: NULL (optional) optional path file saved (automatically combined filename). keep_tbl Keep data table inside object scalar<logical> // default: FALSE option keep data table associated agent informant (case agent, example, created using create_agent(tbl = <data table, ...)). default FALSE data table removed writing disk. database tables class tbl_dbi Spark DataFrames (tbl_spark) table always removed (even keep_tbl set TRUE). keep_extracts Keep data extracts inside object scalar<logical> // default: FALSE option keep collected extract data failing rows. applies agent objects. default, FALSE (.e., extract data removed). quiet Inform () upon file writing scalar<logical> // default: FALSE function inform file written?","code":""},{"path":"https://rstudio.github.io/pointblank/reference/x_write_disk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write an agent, informant, multiagent, or table scan to disk — x_write_disk","text":"Invisibly returns TRUE file written.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/x_write_disk.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write an agent, informant, multiagent, or table scan to disk — x_write_disk","text":"recommended set table-prep formula agent informant can access refreshed data read disk x_read_disk(). can done initially tbl argument create_agent()/create_informant() passing table-prep formula function can obtain target table invoked. Alternatively, can use set_tbl() similarly crafted tbl expression ensure agent informant can retrieve table later time.","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/x_write_disk.html","id":"a-writing-an-agent-to-disk","dir":"Reference","previous_headings":"","what":"A: Writing an agent to disk","title":"Write an agent, informant, multiagent, or table scan to disk — x_write_disk","text":"go process (1) developing agent validation plan (used data quality analysis small_table dataset), (2) interrogating agent interrogate() function, (3) writing agent intel file. Creating action_levels object common workflow step creating pointblank agent. designate failure thresholds warn, stop, notify states using action_levels().   Now, create pointblank agent object give al object (serves default validation steps can overridden). data referenced tbl argument leading ~.   , agent object, can add steps validation plan using many validation functions want. , use interrogate().   agent can written file x_write_disk() function.   can read file back agent x_read_disk() function get intel along restored agent. consistently writing agent reports periodically checking data, make use affix_date() affix_datetime() depending granularity need. example writes file format: \"<filename>-YYYY-mm-dd_HH-MM-SS.rds\".","code":"al <-   action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   ) agent <-   create_agent(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"`x_write_disk()`\",     actions = al   ) agent <-   agent %>%   col_exists(columns = c(date, date_time)) %>%   col_vals_regex(     columns = b,     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(columns = d, value = 100) %>%   col_vals_lte(columns = c, value = 5) %>%   interrogate() x_write_disk(   agent,   filename = \"agent-small_table.rds\" ) x_write_disk(   agent,   filename = affix_datetime(     \"agent-small_table.rds\"   ) )"},{"path":"https://rstudio.github.io/pointblank/reference/x_write_disk.html","id":"b-writing-an-informant-to-disk","dir":"Reference","previous_headings":"","what":"B: Writing an informant to disk","title":"Write an agent, informant, multiagent, or table scan to disk — x_write_disk","text":"go process (1) creating informant object minimally describes small_table dataset, (2) ensuring data captured target table using incorporate() function, (3) writing informant file. Create pointblank informant object create_informant() small_table dataset. Use incorporate() info snippets integrated text.   informant can written file x_write_disk(). affix_date() filename datestamp.   can read file back new informant object (state saved) using x_read_disk().","code":"informant <-   create_informant(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"`x_write_disk()`\"   ) %>%   info_snippet(     snippet_name = \"high_a\",     fn = snip_highest(column = \"a\")   ) %>%   info_snippet(     snippet_name = \"low_a\",     fn = snip_lowest(column = \"a\")   ) %>%   info_columns(     columns = a,     info = \"From {low_a} to {high_a}.\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values.\"   ) %>%   info_columns(     columns = date,     info = \"The date part of `date_time`.\"   ) %>%   incorporate() x_write_disk(   informant,   filename = affix_date(     \"informant-small_table.rds\"   ) )"},{"path":"https://rstudio.github.io/pointblank/reference/x_write_disk.html","id":"c-writing-a-multiagent-to-disk","dir":"Reference","previous_headings":"","what":"C: Writing a multiagent to disk","title":"Write an agent, informant, multiagent, or table scan to disk — x_write_disk","text":"create one pointblank agent object, provide validation steps, interrogate().   Now can combine earlier agent object newer agent_b create multiagent.   multiagent can written file x_write_disk() function.   can read file back multiagent x_read_disk() function get constituent agents associated intel back well.","code":"agent_b <-   create_agent(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"`x_write_disk()`\",     actions = al   ) %>%   col_vals_gt(     columns = b,     value = g,     na_pass = TRUE,     label = \"b > g\"   ) %>%   col_is_character(     columns = c(b, f),     label = \"Verifying character-type columns\"   ) %>%   interrogate() multiagent <- create_multiagent(agent, agent_b) x_write_disk(   multiagent,   filename = \"multiagent-small_table.rds\" )"},{"path":"https://rstudio.github.io/pointblank/reference/x_write_disk.html","id":"d-writing-a-table-scan-to-disk","dir":"Reference","previous_headings":"","what":"D: Writing a table scan to disk","title":"Write an agent, informant, multiagent, or table scan to disk — x_write_disk","text":"can get report describes data storms dataset.   table scan object can written file x_write_disk().","code":"tbl_scan <- scan_data(tbl = dplyr::storms) x_write_disk(   tbl_scan,   filename = \"tbl_scan-storms.rds\" )"},{"path":"https://rstudio.github.io/pointblank/reference/x_write_disk.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Write an agent, informant, multiagent, or table scan to disk — x_write_disk","text":"9-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_interrogate.html","id":null,"dir":"Reference","previous_headings":"","what":"Get an agent from pointblank YAML and interrogate() — yaml_agent_interrogate","title":"Get an agent from pointblank YAML and interrogate() — yaml_agent_interrogate","text":"yaml_agent_interrogate() function operates much like yaml_read_agent() function (reading pointblank YAML file generating agent validation plan place). key difference function takes things step interrogates target table (defined table-prep formula required YAML file). additional auto-invocation interrogate() uses default options function. yaml_read_agent() agent returned except, time, intel interrogation.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_interrogate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get an agent from pointblank YAML and interrogate() — yaml_agent_interrogate","text":"","code":"yaml_agent_interrogate(filename, path = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_interrogate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get an agent from pointblank YAML and interrogate() — yaml_agent_interrogate","text":"filename File name scalar<character> // required name YAML file contains fields related agent. path #' @param path File path scalar<character> // default: NULL (optional) optional path YAML file (combined filename).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_interrogate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get an agent from pointblank YAML and interrogate() — yaml_agent_interrogate","text":"ptblank_agent object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_interrogate.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get an agent from pointblank YAML and interrogate() — yaml_agent_interrogate","text":"YAML file available pointblank package also called \"agent-small_table.yml\". path can accessed system.file():   YAML file can read agent pre-existing validation plan using yaml_read_agent() function.    particular agent using ~ tbl_source(\"small_table\", \"tbl_store.yml\") source table-prep YAML file holds table store (can seen using yaml_agent_string(agent = agent)). put file working directory (pointblank package corresponding YAML file):   can seen validation report, interrogation yet performed. Saving agent YAML remove traces interrogation data serve plan new interrogation target table. can either follow interrogate() get agent intel, , can interrogate directly YAML file yaml_agent_interrogate():","code":"yml_file_path <-   system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) agent <- yaml_read_agent(filename = yml_file_path)  agent yml_tbl_store_path <-   system.file(     \"yaml\", \"tbl_store.yml\",     package = \"pointblank\"   )  file.copy(from = yml_tbl_store_path, to = \".\") agent <- yaml_agent_interrogate(filename = yml_file_path)  agent"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_interrogate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get an agent from pointblank YAML and interrogate() — yaml_agent_interrogate","text":"11-4","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_show_exprs.html","id":null,"dir":"Reference","previous_headings":"","what":"Display validation expressions using pointblank YAML — yaml_agent_show_exprs","title":"Display validation expressions using pointblank YAML — yaml_agent_show_exprs","text":"yaml_agent_show_exprs() function follows specifications pointblank YAML file generate show pointblank expressions generating described validation plan. expressions shown console, providing opportunity copy statements extend needed. pointblank YAML file can generated using yaml_write() function pre-existing agent, , can carefully written hand.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_show_exprs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display validation expressions using pointblank YAML — yaml_agent_show_exprs","text":"","code":"yaml_agent_show_exprs(filename, path = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_show_exprs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display validation expressions using pointblank YAML — yaml_agent_show_exprs","text":"filename File name scalar<character> // required name YAML file contains fields related agent. path #' @param path File path scalar<character> // default: NULL (optional) optional path YAML file (combined filename).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_show_exprs.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display validation expressions using pointblank YAML — yaml_agent_show_exprs","text":"create validation plan data quality analysis small_table dataset. need agent table-prep formula enables retrieval target table.   agent can written pointblank YAML file yaml_write().   later time, YAML file can read new agent yaml_read_agent() function.    get sense expressions used generate new agent, can use yaml_agent_show_exprs().","code":"agent <-   create_agent(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = action_levels(       warn_at = 0.10,       stop_at = 0.25,       notify_at = 0.35     )   ) %>%   col_exists(columns = c(date, date_time)) %>%   col_vals_regex(     columns = b,     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(columns = d, value = 100) %>%   col_vals_lte(columns = c, value = 5) yaml_write(   agent = agent,   filename = \"agent-small_table.yml\" ) agent <- yaml_read_agent(filename = \"agent-small_table.yml\")  agent yaml_agent_show_exprs(filename = \"agent-small_table.yml\") create_agent(   tbl = ~small_table,   actions = action_levels(     warn_at = 0.1,     stop_at = 0.25,     notify_at = 0.35   ),   tbl_name = \"small_table\",   label = \"A simple example with the `small_table`.\" ) %>%   col_exists(     columns = c(date, date_time)   ) %>%   col_vals_regex(     columns = b,     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(     columns = d,     value = 100   ) %>%   col_vals_lte(     columns = c,     value = 5   )"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_show_exprs.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Display validation expressions using pointblank YAML — yaml_agent_show_exprs","text":"11-6","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_string.html","id":null,"dir":"Reference","previous_headings":"","what":"Display pointblank YAML using an agent or a YAML file — yaml_agent_string","title":"Display pointblank YAML using an agent or a YAML file — yaml_agent_string","text":"pointblank YAML, can serialize agent's validation plan (yaml_write()), read back later new agent (yaml_read_agent()), perform interrogation target data table directly YAML file (yaml_agent_interrogate()). yaml_agent_string() function allows us inspect YAML generated yaml_write() console, giving us look YAML without needing open file directly. Alternatively, can provide agent yaml_agent_string() view YAML representation validation plan without needing write YAML disk beforehand.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_string.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display pointblank YAML using an agent or a YAML file — yaml_agent_string","text":"","code":"yaml_agent_string(agent = NULL, filename = NULL, path = NULL, expanded = FALSE)"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_string.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display pointblank YAML using an agent or a YAML file — yaml_agent_string","text":"agent agent object class ptblank_agent. object provided , filename must provided. filename name YAML file contains fields related agent. file name provided , agent object must provided agent. path optional path YAML file (combined filename). expanded written validation expressions agent expanded tidyselect expressions columns evaluated, yielding validation function per column? default, FALSE expressions written retained YAML representation.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_string.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display pointblank YAML using an agent or a YAML file — yaml_agent_string","text":"yaml string printed console returned invisibly.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_string.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display pointblank YAML using an agent or a YAML file — yaml_agent_string","text":"YAML file available pointblank package called \"agent-small_table.yml\". path can accessed system.file():   can view contents YAML file console yaml_agent_string() function.     Incidentally, can also use yaml_agent_string() print YAML console supplying agent object input. can useful previewing YAML output just writing disk yaml_write().","code":"yml_file_path <-   system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) yaml_agent_string(filename = yml_file_path) type: agent tbl: ~ tbl_source(\"small_table\", \"tbl_store.yml\") tbl_name: small_table label: A simple example with the `small_table`. lang: en locale: en actions:   warn_fraction: 0.1   stop_fraction: 0.25   notify_fraction: 0.35 steps: - col_exists:     columns: vars(date) - col_exists:     columns: vars(date_time) - col_vals_regex:     columns: vars(b)     regex: '[0-9]-[a-z]{3}-[0-9]{3}' - rows_distinct:     columns: ~ - col_vals_gt:     columns: vars(d)     value: 100.0 - col_vals_lte:     columns: vars(c)     value: 5.0"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_agent_string.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Display pointblank YAML using an agent or a YAML file — yaml_agent_string","text":"11-5","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/yaml_exec.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute all agent and informant YAML tasks — yaml_exec","title":"Execute all agent and informant YAML tasks — yaml_exec","text":"yaml_exec() function takes relevant pointblank YAML files directory executes . Execution involves interrogation agents YAML agents incorporation informants YAML informants. hood, uses yaml_agent_interrogate() yaml_informant_incorporate() x_write_disk() save processed objects output directory. written artifacts can read later time x_read_disk() function read_disk_multiagent() function. useful data target tables changing periodic testing tables part data quality monitoring plan. output RDS files named according object type processed, target table, date-time processing. convenience modularity, setup ideal table store YAML file (typically named \"tbl_store.yml\" produced via tbl_store() yaml_write() workflow) available directory, table-prep formulas accessed name tbl_source(). typical directory files set execution way might following contents: \"tbl_store.yml\" file holding table-prep formulas (created tbl_store() written YAML yaml_write()) one YAML agent files validate tables (ideally using tbl_source()) one YAML informant files provide refreshed metadata tables (, using tbl_source() reference table preparations ideal) output folder (default \"output\") save serialized versions processed agents informants Minimal example files aforementioned types can found pointblank package following system.file() calls: system.file(\"yaml\", \"agent-small_table.yml\", package = \"pointblank\") system.file(\"yaml\", \"informant-small_table.yml\", package = \"pointblank\") system.file(\"yaml\", \"tbl_store.yml\", package = \"pointblank\") directory can accessed using system.file(\"yaml\", package = \"pointblank\").","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_exec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute all agent and informant YAML tasks — yaml_exec","text":"","code":"yaml_exec(   path = NULL,   files = NULL,   write_to_disk = TRUE,   output_path = file.path(path, \"output\"),   keep_tbl = FALSE,   keep_extracts = FALSE )"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_exec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute all agent and informant YAML tasks — yaml_exec","text":"path path contains YAML files agents informants. files vector YAML files use execution workflow. default, yaml_exec() attempt process every valid YAML file path supplying vector limits scope specified files. write_to_disk execution workflow include step writes output files disk? internally calls x_write_disk() write RDS files uses base filename agent/informant YAML file part output filename, appending date-time basename. output_path output path generated output files. default, subdirectory provided path called \"output\". keep_tbl, keep_extracts agents, table may kept data frame object (databases tables never pulled storage) extracts, collections table rows failed validation step, may also stored. default, options set FALSE.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_exec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Execute all agent and informant YAML tasks — yaml_exec","text":"Invisibly returns named vector file paths input files processed; file output paths (wherever writing occurred) given names.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_exec.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Execute all agent and informant YAML tasks — yaml_exec","text":"11-8","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/yaml_exec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Execute all agent and informant YAML tasks — yaml_exec","text":"","code":"if (interactive()) {  # The 'yaml' directory that is # accessible in the package through # `system.file()` contains the files # 1. `agent-small_table.yml` # 2. `informant-small_table.yml` # 3. `tbl_store.yml`  # There are references in YAML files # 1 & 2 to the table store YAML file, # so, they all work together cohesively  # Let's process the agent and the # informant YAML files with `yaml_exec()`; # and we'll specify the working directory # as the place where the output RDS files # are written  output_dir <- getwd()  yaml_exec(   path = system.file(     \"yaml\", package = \"pointblank\"   ),   output = output_dir )  # This generates two RDS files in the # working directory: one for the agent # and the other for the informant; each # of them are automatically time-stamped # so that periodic execution can be # safely carried out without risk of # overwriting   }"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_informant_incorporate.html","id":null,"dir":"Reference","previous_headings":"","what":"Get an informant from pointblank YAML and incorporate() — yaml_informant_incorporate","title":"Get an informant from pointblank YAML and incorporate() — yaml_informant_incorporate","text":"yaml_informant_incorporate() function operates much like yaml_read_informant() function (reading pointblank YAML file generating informant information place). key difference function takes things step incorporates aspects target table (defined table-prep formula required YAML file). additional auto-invocation incorporate() uses default options function. yaml_read_informant() informant returned except, time, updated latest information target table.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_informant_incorporate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get an informant from pointblank YAML and incorporate() — yaml_informant_incorporate","text":"","code":"yaml_informant_incorporate(filename, path = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_informant_incorporate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get an informant from pointblank YAML and incorporate() — yaml_informant_incorporate","text":"filename File name scalar<character> // required name YAML file contains fields related informant. path File path scalar<character> // default: NULL (optional) optional path YAML file (combined filename).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_informant_incorporate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get an informant from pointblank YAML and incorporate() — yaml_informant_incorporate","text":"ptblank_informant object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_informant_incorporate.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get an informant from pointblank YAML and incorporate() — yaml_informant_incorporate","text":"YAML file available pointblank package called \"informant-small_table.yml\". path can accessed system.file():   YAML file can read informant using yaml_informant_incorporate() function. expect metadata change time, best use yaml_informant_incorporate() instead yaml_read_informant() since former go extra mile perform incorporate() addition reading.    can seen information report, available table metadata restored reported. metadata change time, updated well.","code":"yml_file_path <-   system.file(     \"yaml\", \"informant-small_table.yml\",     package = \"pointblank\"   ) informant <- yaml_informant_incorporate(filename = yml_file_path)  informant"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_informant_incorporate.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Get an informant from pointblank YAML and incorporate() — yaml_informant_incorporate","text":"11-7","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/yaml_read_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a pointblank YAML file to create an agent object — yaml_read_agent","title":"Read a pointblank YAML file to create an agent object — yaml_read_agent","text":"yaml_read_agent() can read pointblank YAML file describes validation plan carried agent (typically generated yaml_write() function. returned new agent validation plan, ready interrogate target table (using table-prep formula set tbl argument create_agent()). agent can given validation steps needed using interrogate() taking part agent ops (e.g., writing disk outputs intact via x_write_disk() pointblank YAML yaml_write()). get picture yaml_read_agent() interpreting validation plan specified pointblank YAML, can use yaml_agent_show_exprs() function. function shows us (console) pointblank expressions generating described validation plan.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_read_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a pointblank YAML file to create an agent object — yaml_read_agent","text":"","code":"yaml_read_agent(filename, path = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_read_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a pointblank YAML file to create an agent object — yaml_read_agent","text":"filename File name scalar<character> // required name YAML file contains fields related agent. path File path scalar<character> // default: NULL (optional) optional path YAML file (combined filename).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_read_agent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a pointblank YAML file to create an agent object — yaml_read_agent","text":"ptblank_agent object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_read_agent.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read a pointblank YAML file to create an agent object — yaml_read_agent","text":"YAML file available pointblank package also called \"agent-small_table.yml\". path can accessed system.file():   YAML file can read agent pre-existing validation plan using yaml_read_agent() function.    particular agent using ~ tbl_source(\"small_table\", \"tbl_store.yml\") source table-prep YAML file holds table store (can seen using yaml_agent_string(agent = agent)). put file working directory (pointblank package corresponding YAML file):   can seen validation report, interrogation yet performed. Saving agent YAML remove traces interrogation data serve plan new interrogation target table. can either follow interrogate() get agent intel, , can interrogate directly YAML file yaml_agent_interrogate():","code":"yml_file_path <-   system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) agent <- yaml_read_agent(filename = yml_file_path)  agent yml_tbl_store_path <-   system.file(     \"yaml\", \"tbl_store.yml\",     package = \"pointblank\"   )  file.copy(from = yml_tbl_store_path, to = \".\") agent <- yaml_agent_interrogate(filename = yml_file_path)  agent"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_read_agent.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Read a pointblank YAML file to create an agent object — yaml_read_agent","text":"11-2","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/yaml_read_informant.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a pointblank YAML file to create an informant object — yaml_read_informant","title":"Read a pointblank YAML file to create an informant object — yaml_read_informant","text":"yaml_read_informant() can read pointblank YAML file describes table information (typically generated yaml_write() function. returned new informant object information intact. informant object can given information use info_*() functions.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_read_informant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a pointblank YAML file to create an informant object — yaml_read_informant","text":"","code":"yaml_read_informant(filename, path = NULL)"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_read_informant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a pointblank YAML file to create an informant object — yaml_read_informant","text":"filename File name scalar<character> // required name YAML file contains fields related informant. path File path scalar<character> // default: NULL (optional) optional path YAML file (combined filename).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_read_informant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a pointblank YAML file to create an informant object — yaml_read_informant","text":"ptblank_informant object.","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_read_informant.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read a pointblank YAML file to create an informant object — yaml_read_informant","text":"YAML file available pointblank package called \"informant-small_table.yml\". path can accessed system.file():   YAML file can read informant using yaml_read_informant() function.    can seen information report, available table metadata restored reported. expect metadata change time, might beneficial use incorporate() query target table. , can perform querying directly YAML file yaml_informant_incorporate().","code":"yml_file_path <-   system.file(     \"yaml\", \"informant-small_table.yml\",     package = \"pointblank\"   ) informant <- yaml_read_informant(filename = yml_file_path)  informant"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_read_informant.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Read a pointblank YAML file to create an informant object — yaml_read_informant","text":"11-3","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/yaml_write.html","id":null,"dir":"Reference","previous_headings":"","what":"Write pointblank objects to YAML files — yaml_write","title":"Write pointblank objects to YAML files — yaml_write","text":"yaml_write() can take different pointblank objects (ptblank_agent, ptblank_informant, tbl_store) write YAML. agent, example, yaml_write() write everything needed specify agent validation plan YAML file. YAML, can modify YAML markup desired, , use create new agent yaml_read_agent() function. agent validation plan ready interrogate() data. can go step perform interrogation directly YAML file yaml_agent_interrogate() function. returns agent intel (already interrogated target data table). informant object can also written YAML yaml_write(). One requirement writing agent informant YAML need table-prep formula specified (R formula used read target table interrogate() incorporate() called). option can set using create_agent()/create_informant() set_tbl() (useful existing agent informant object).","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_write.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write pointblank objects to YAML files — yaml_write","text":"","code":"yaml_write(   ...,   .list = list2(...),   filename = NULL,   path = NULL,   expanded = FALSE,   quiet = FALSE )"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_write.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write pointblank objects to YAML files — yaml_write","text":"... Pointblank agents, informants, table stores <series obj:<ptblank_agent|ptblank_informant|tbl_store>> // required mix pointblank objects agent (ptblank_agent), informant (ptblank_informant), table store (tbl_store). agent informant can combined single YAML file (long objects refer table). table store combined either agent informant must undergo conversion alone. .list Alternative ... <list multiple expressions> // required (, use ...) Allows use list input alternative .... filename File name scalar<character> // default: NULL (optional) name YAML file create disk. recommended either .yaml .yml extension used file. provided default names used (\"tbl_store.yml\") table store objects get default naming effect \"<object>-<tbl_name>.yml\". path File path scalar<character> // default: NULL (optional) optional path YAML file saved (combined filename). expanded Expand validation repeating across multiple columns scalar<logical> // default: FALSE written validation expressions agent expanded tidyselect expressions columns evaluated, yielding validation function per column? default, FALSE expressions written retained YAML representation. quiet Inform () upon file writing scalar<logical> // default: FALSE .  function inform file written?","code":""},{"path":"https://rstudio.github.io/pointblank/reference/yaml_write.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write pointblank objects to YAML files — yaml_write","text":"Invisibly returns TRUE YAML file written.","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/reference/yaml_write.html","id":"writing-an-agent-object-to-a-yaml-file","dir":"Reference","previous_headings":"","what":"Writing an agent object to a YAML file","title":"Write pointblank objects to YAML files — yaml_write","text":"go process developing agent validation plan. use small_table dataset following examples, eventually offload developed validation plan YAML file.   Creating action_levels object common workflow step creating pointblank agent. designate failure thresholds warn, stop, notify states using action_levels().   Now create agent pass al object (serves default validation steps can overridden). data referenced tbl leading ~ requirement writing YAML since preparation target table must self contained.   , agent object, can add steps validation plan using many validation functions want.   agent can written pointblank-readable YAML file yaml_write() function. , use filename \"agent-small_table.yml\" , writing, YAML file working directory:   can view YAML file console yaml_agent_string() function.     Incidentally, can also use yaml_agent_string() print YAML console supplying agent input. can useful previewing YAML output just writing disk yaml_write().","code":"small_table #> # A tibble: 13 x 8 #>    date_time           date           a b             c      d e     f #>    <dttm>              <date>     <int> <chr>     <dbl>  <dbl> <lgl> <chr> #>  1 2016-01-04 11:00:00 2016-01-04     2 1-bcd-345     3  3423. TRUE  high #>  2 2016-01-04 00:32:00 2016-01-04     3 5-egh-163     8 10000. TRUE  low #>  3 2016-01-05 13:32:00 2016-01-05     6 8-kdg-938     3  2343. TRUE  high #>  4 2016-01-06 17:23:00 2016-01-06     2 5-jdo-903    NA  3892. FALSE mid #>  5 2016-01-09 12:36:00 2016-01-09     8 3-ldm-038     7   284. TRUE  low #>  6 2016-01-11 06:15:00 2016-01-11     4 2-dhe-923     4  3291. TRUE  mid #>  7 2016-01-15 18:46:00 2016-01-15     7 1-knw-093     3   843. TRUE  high #>  8 2016-01-17 11:27:00 2016-01-17     4 5-boe-639     2  1036. FALSE low #>  9 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 10 2016-01-20 04:30:00 2016-01-20     3 5-bce-642     9   838. FALSE high #> 11 2016-01-26 20:07:00 2016-01-26     4 2-dmx-010     7   834. TRUE  low #> 12 2016-01-28 02:51:00 2016-01-28     2 7-dmx-010     8   108. FALSE low #> 13 2016-01-30 11:23:00 2016-01-30     1 3-dka-303    NA  2230. TRUE  high al <-   action_levels(     warn_at = 0.10,     stop_at = 0.25,     notify_at = 0.35   ) agent <-   create_agent(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\",     actions = al   ) agent <-   agent %>%   col_exists(columns = c(date, date_time)) %>%   col_vals_regex(     columns = b,     regex = \"[0-9]-[a-z]{3}-[0-9]{3}\"   ) %>%   rows_distinct() %>%   col_vals_gt(columns = d, value = 100) %>%   col_vals_lte(columns = c, value = 5) yaml_write(agent, filename = \"agent-small_table.yml\") yaml_agent_string(filename = \"agent-small_table.yml\") type: agent tbl: ~small_table tbl_name: small_table label: A simple example with the `small_table`. lang: en locale: en actions:   warn_fraction: 0.1   stop_fraction: 0.25   notify_fraction: 0.35 steps: - col_exists:     columns: c(date, date_time) - col_vals_regex:     columns: c(b)     regex: '[0-9]-[a-z]{3}-[0-9]{3}' - rows_distinct:     columns: ~ - col_vals_gt:     columns: c(d)     value: 100.0 - col_vals_lte:     columns: c(c)     value: 5.0"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_write.html","id":"reading-an-agent-object-from-a-yaml-file","dir":"Reference","previous_headings":"","what":"Reading an agent object from a YAML file","title":"Write pointblank objects to YAML files — yaml_write","text":"YAML file available pointblank package also called \"agent-small_table.yml\". path can accessed system.file():   YAML file can read agent pre-existing validation plan using yaml_read_agent() function.    particular agent using ~ tbl_source(\"small_table\", \"tbl_store.yml\") source table-prep YAML file holds table store (can seen using yaml_agent_string(agent = agent)). put file working directory (pointblank package corresponding YAML file):   can seen validation report, interrogation yet performed. Saving agent YAML remove traces interrogation data serve plan new interrogation target table. can either follow interrogate() get agent intel, , can interrogate directly YAML file yaml_agent_interrogate():","code":"yml_file_path <-   system.file(     \"yaml\", \"agent-small_table.yml\",     package = \"pointblank\"   ) agent <- yaml_read_agent(filename = yml_file_path)  agent yml_tbl_store_path <-   system.file(     \"yaml\", \"tbl_store.yml\",     package = \"pointblank\"   )  file.copy(from = yml_tbl_store_path, to = \".\") agent <- yaml_agent_interrogate(filename = yml_file_path)  agent"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_write.html","id":"writing-an-informant-object-to-a-yaml-file","dir":"Reference","previous_headings":"","what":"Writing an informant object to a YAML file","title":"Write pointblank objects to YAML files — yaml_write","text":"walk can generate useful information really small table. can create informant object create_informant() use small_table dataset.   , informant object, can add info text using many info_*() functions want.   informant can written pointblank-readable YAML file yaml_write() function. , use filename \"informant-small_table.yml\" , writing, YAML file working directory:   can inspect YAML file working directory expect see following:","code":"informant <-   create_informant(     tbl = ~ small_table,     tbl_name = \"small_table\",     label = \"A simple example with the `small_table`.\"   ) informant <-   informant %>%   info_columns(     columns = a,     info = \"In the range of 1 to 10. (SIMPLE)\"   ) %>%   info_columns(     columns = starts_with(\"date\"),     info = \"Time-based values (e.g., `Sys.time()`).\"   ) %>%   info_columns(     columns = date,     info = \"The date part of `date_time`. (CALC)\"   ) yaml_write(informant, filename = \"informant-small_table.yml\") type: informant tbl: ~small_table tbl_name: small_table info_label: A simple example with the `small_table`. lang: en locale: en table:   name: small_table   _columns: 8   _rows: 13.0   _type: tbl_df columns:   date_time:   _type: POSIXct, POSIXt info: Time-based values (e.g., `Sys.time()`). date:   _type: Date   info: Time-based values (e.g., `Sys.time()`). The date part of `date_time`. a:   _type: integer   info: In the range of 1 to 10. (SIMPLE) b:   _type: character c:   _type: numeric d:   _type: numeric e:   _type: logical f:   _type: character"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_write.html","id":"reading-an-informant-object-from-a-yaml-file","dir":"Reference","previous_headings":"","what":"Reading an informant object from a YAML file","title":"Write pointblank objects to YAML files — yaml_write","text":"YAML file available pointblank package also called \"informant-small_table.yml\". path can accessed system.file():   YAML file can read informant using yaml_read_informant() function.    can seen information report, available table metadata restored reported. expect metadata change time, might beneficial use incorporate() query target table. , can perform querying directly YAML file yaml_informant_incorporate():   apparent difference particular case since small_data static table alterations time. However, using yaml_informant_incorporate() good practice since refreshing data important real-world datasets.","code":"yml_file_path <-   system.file(     \"yaml\", \"informant-small_table.yml\",     package = \"pointblank\"   ) informant <- yaml_read_informant(filename = yml_file_path)  informant informant <- yaml_informant_incorporate(filename = yml_file_path)"},{"path":"https://rstudio.github.io/pointblank/reference/yaml_write.html","id":"function-id","dir":"Reference","previous_headings":"","what":"Function ID","title":"Write pointblank objects to YAML files — yaml_write","text":"11-1","code":""},{"path":[]},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-development-version","dir":"Changelog","previous_headings":"","what":"pointblank (development version)","title":"pointblank (development version)","text":"Add na_pass col_vals_expr() finer control NA values. Previously, NAs ignored, now caught failures default na_pass = FALSE. safeguard, expression generates NA values na_pass explicitly supplied, warning thrown. (#617) Bugfix agents auto-generating table label long. now get truncated (#614) Bugfix agents searching formula environment materializing ~ tbl (#599) info_columns() warn informatively columns selected (#589). write_yaml() errors informatively tbl value incompatible yaml-writing (#597) Data extracts rows_distinct()/rows_complete() preserves columns, just ones tested (#588, #591) brief argument validation functions now also supports glue syntax (#587) Validation step briefs correctly recycle match expanded steps (#564) new Get Started vignette (#605).","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-0122","dir":"Changelog","previous_headings":"","what":"pointblank 0.12.2","title":"pointblank 0.12.2","text":"CRAN release: 2024-10-23 release provides minor improvements along many bug fixes. New argument extract_tbl_checked added interrogate(). FALSE, $tbl_checked column validation set dropped returning agent. may helpful reducing object size large agents (#542). (#554) new argument na_rm snip_list() suppresses NA values won’t included snippet’s list items (#547). (#556) Improved readability error messages rendered tooltips agent report. (#543) col_vals_expr() shows used columns agent report interrogated. (#570) Improved matching rows agent$validation_step rows agent report (#563). (#565) Functions accepting ... now use rlang::list2(), enabling dynamic dots. example, multiagent can now constructed list() agents using create_multiagent(!!!list_of_agents) (#552). (#553) Fixed bug non-standard column names validation functions (#545, #546). (#555) Fixed regression col_vals_*() functions, vars(\"col\") evaluating string \"col\". Behavior vars(\"col\") now aligned back vars(col) - evaluate column name col. (#535) Problems arising comparing columns value different class (example, comparing datetime column date value Sys.Date() instead another datetime value Sys.time()) now signalled appropriately interrogate() (#536, #537). (#539) Fixed bug has_columns() failing detect non-existing columns supplied character vector. (#540) Replace uses crayon::make_style() cli::make_ansi_style(), removing crayon dependency. (#559, thanks @olivroy!) Use rlang::check_installed() perform checks optional package installs. (#559, @olivroy) Modernized CI workflows dedicated linting action. (#560, @olivroy) Avoid unwanted equation formatting agent report arising arbitrary \"$\" characters (#561). (#562)","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-0121","dir":"Changelog","previous_headings":"","what":"pointblank 0.12.1","title":"pointblank 0.12.1","text":"CRAN release: 2024-03-25 Ensured column string symbol constructing expression col_vals_*() functions. longer resolve columns tidyselect target table materialized. Relaxed tests tidyselect error messages.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-0120","dir":"Changelog","previous_headings":"","what":"pointblank 0.12.0","title":"pointblank 0.12.0","text":"CRAN release: 2024-03-01","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"new-features-0-12-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.12.0","text":"Complete tidyselect support columns argument validation functions, well has_columns() info_columns. columns argument can now take familiar column-selection expressions one use inside dplyr::select(). also begins process deprecation: columns = vars(...) continue work, c() now supersedes vars(). passing external vector column names, wrapped all_of(). label argument validation functions now exposes following string variables via glue syntax: \"{.step}\": validation step name \"{.col}\": current column name \"{.seg_col}\": current segment’s column name \"{.seg_val}\": current segment’s value/group dynamic values may useful validations get expanded multiple steps. interrogate() gains two new options printing progress console output: progress: Whether interrogation progress printed console (TRUE interactive sessions, ) show_step_label: Whether validation step’s label value printed alongside progress.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-12-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.12.0","text":"Fixes issue rendering reports Quarto HTML documents. columns returned tidyselect expression columns, agent’s report now displays originally supplied expression instead simply blank (e.g., create_agent(small_table) |> col_vals_null(matches(\"z\"))). Fixes issue hashing implementation improve performance alignment validation steps multiagent.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-0114","dir":"Changelog","previous_headings":"","what":"pointblank 0.11.4","title":"pointblank 0.11.4","text":"CRAN release: 2023-04-25 Fixes issue gt 0.9.0 compatibility.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-0113","dir":"Changelog","previous_headings":"","what":"pointblank 0.11.3","title":"pointblank 0.11.3","text":"CRAN release: 2023-02-09 Fixes issue tables rendering due interaction gt package.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-0112","dir":"Changelog","previous_headings":"","what":"pointblank 0.11.2","title":"pointblank 0.11.2","text":"CRAN release: 2022-10-08 Internal changes made ensure compatibility -development version R.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-0111","dir":"Changelog","previous_headings":"","what":"pointblank 0.11.1","title":"pointblank 0.11.1","text":"CRAN release: 2022-09-06 Updated help files pass HTML validation.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-0110","dir":"Changelog","previous_headings":"","what":"pointblank 0.11.0","title":"pointblank 0.11.0","text":"CRAN release: 2022-07-14","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"new-features-0-11-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.11.0","text":"row_count_match() function can now match count rows target table literal value (addition comparing row counts secondary table). analogous col_count_match() function added compare column counts target table secondary table, , match literal value. Substitution syntax added tbl_store() function {{ <name> }}. great way make table-prep concise, readable, less prone errors. get_informant_report() enhanced width options. Aside \"standard\" \"small\" sizes can now supply pixel- percent-based width precisely size reporting. Added support validating data BigQuery tables.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"documentation-0-11-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.11.0","text":"functions package now better usage examples.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-0100","dir":"Changelog","previous_headings":"","what":"pointblank 0.10.0","title":"pointblank 0.10.0","text":"CRAN release: 2022-01-23","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"new-features-0-10-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.10.0","text":"new function row_count_match() (plus expect_row_count_match() test_row_count_match()) checks exact matching rows across two tables (target table comparison table choosing). Works equally well local tables database Spark tables. new tbl_match() function (along expect_tbl_match() test_tbl_match()) check exact matching target table comparison table. check strict match table schemas, equivalent row counts, exact matches cell values across two tables.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-10-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.10.0","text":"set_tbl() function given tbl_name label arguments provide opportunity set metadata new target table. Support mssql tables restored works exceedingly well majority validation functions (incompatible provide messaging supported).","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"documentation-0-10-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.10.0","text":"functions package now usage examples. RStudio Cloud project prepared .Rmd files contain explainers runnable examples function package. Look project README link project.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"breaking-changes-0-10-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"pointblank 0.10.0","text":"read_fn argument create_agent() create_informant() deprecated favor enhanced tbl argument. Now, can supply variety inputs tbl associating target table agent informant. tbl, ’s now possible provide table (e.g., data.frame, tbl_df, tbl_dbi, tbl_spark, etc.), expression (table-prep formula function) read table interrogation time, table source expression get table preparations table store (-memory object defined YAML file). set_read_fn(), remove_read_fn(), remove_tbl() functions removed since read_fn argument deprecated (’s virtually need remove table object remove_tbl() now).","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-090","dir":"Changelog","previous_headings":"","what":"pointblank 0.9.0","title":"pointblank 0.9.0","text":"CRAN release: 2021-10-28","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"new-features-0-9-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.9.0","text":"new rows_complete() validation function (along expect_rows_complete() test_rows_complete() expectation test variants) check whether rows contain NA/NULL values (optionally constrained selection specified columns). new function serially() (along expect_serially() test_serially()) allows series tests run sequence either culminating final validation step simply exiting series. construction allows pre-testing may make sense validation step. example, may situations ’s vital check column type performing validation column. specially()/expect_specially()/test_specially() functions enable custom validations/tests/expectations user-defined function. still preconditions common args available convenience. great thing require UDF return logical vector passing/failing test units (table rightmost column logical), can incorporate results quite easily standard pointblank reporting. info_columns_from_tbl() function super-convenient wrapper info_columns() function. Say ’re making data dictionary informant already table metadata somewhere table: can use call info_columns() many, many times. Added game_revenue_info dataset contains metadata extant game_revenue dataset. datasets pair nicely together examples create data dictionary create_informant() info_columns_from_tbl(). Added table transformer function tt_tbl_colnames() get table’s column names validation.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-9-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.9.0","text":"Input data tables label attribute values columns displayed ‘Variables’ section scan_data() report. useful scanning imported SAS tables (often labeled variables). all_passed() function improved failed validation steps (return evaluation error, perhaps missing column) result FALSE; argument added all_passed() optionally get subset validation steps evaluation. expect_*() functions can handle multiple columns, pointblank now correctly stops first failure provides correct reporting . Passing multiple columns really mean processing multiple steps serial, previously handled incorrectly.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-080","dir":"Changelog","previous_headings":"","what":"pointblank 0.8.0","title":"pointblank 0.8.0","text":"CRAN release: 2021-07-25","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"new-features-0-8-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.8.0","text":"new draft_validation() function create starter validation .R .Rmd file just table input. Uses new ‘column roles’ feature develop starter set validation steps based kind data columns contain (e.g., latitude/longitude values, URLs, email addresses, etc.). validation function col_vals_within_spec() (variants expect_col_vals_within_spec() test_col_vals_within_spec()) test column values specification like phone numbers (\"phone\"), VIN numbers (\"VIN\"), URLs (\"url\"), email addresses (\"email\"), much (\"isbn\", \"postal_code[<country_code>]\", \"credit_card\", \"iban[<country_code>]\", \"swift\", \"ipv4\", \"ipv6\", \"mac\"). large cross section row-based validation functions can now operate segments target table, can run particular validation slices (segments) target table. segmentation made possible use new segments argument, takes expression serves segment target table column values. can given one two ways: (1) single multiple column names containing keys segment , (2) two-sided formula LHS holds column name RHS contains column values segment (allowing subset keys segmentation). default printing multiagent object now stacked display agent reports. wide report (useful comparisons validations targeting table time) available improved get_multiagent_report() function (display_mode = \"wide\"). Exporting reporting now much easier new export_report() function. export objects agent (validations), informant (table metadata), multiagent (series validations), , also objects containing customized reports (scan_data(), get_agent_report(), get_informant_report(), get_multiagent_report()). ’ll always get self-contained HTML file report use export_report(). new family functions added pointblank: Table Transformers! functions can radically transform data table either provide wholly different table (like summary table table properties table) useful filtering single step. can useful preparing target table validation creating temporary tables (preconditions) validation steps (e.g., validating table properties string lengths). nice bonus transformer functions work equally well data frames, database tables, Spark tables. included functions : tt_summary_stats(), tt_string_info(), tt_tbl_dims(), tt_time_shift(), tt_time_slice(). Two new datasets added: specifications game_revenue. former dataset can used test col_vals_within_spec() validation function. latter dataset (2,000 rows) can used experiment tt_time_shift() tt_time_slice() table transformer functions.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-8-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.8.0","text":"Added Polish (\"pl\"), Danish (\"da\"), Turkish (\"tr\"), Swedish (\"sv\"), Dutch (\"nl\") translations. scan_data() function now bit performant, testable, better communicating progress generating report. preconditions argument, used modify target table validation step, now improved (1) checking table object returned evaluation, (2) correcting YAML writing preconditions expression ’s provided function. x_write_disk() x_read_disk() extended allow writing reading ptblank_tbl_scan objects (returned scan_data()). Print methods received love release. Now, scan_data() table scan reports look much better R Markdown. Reporting objects get_agent_report(), get_informant_report(), get_multiagent_report() now print methods work beautifully R Markdown result. incorporate() function, called informant object, now emits styled messages console. using yaml_exec() process arbitrary amount YAML-based agents informants, ’ll given information progress console.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"documentation-0-8-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.8.0","text":"Many help files overhauled (1) things clearer, (2) details provided (things complex), (3) many ready--run examples present. functions improved help release : all_passed(), get_data_extracts(), get_multiagent_report(), get_sundered_data(), has_columns(), write_testthat_file(), x_write_disk(), yaml_exec().","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-070","dir":"Changelog","previous_headings":"","what":"pointblank 0.7.0","title":"pointblank 0.7.0","text":"CRAN release: 2021-03-09","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"new-features-0-7-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.7.0","text":"New functions set-based interrogations: col_vals_make_set() (+ expect_col_vals_make_set() test_col_vals_make_set()) col_vals_make_subset() (+ expect_col_vals_make_subset() test_col_vals_make_subset()); answer following two questions: (1) set values entirely accounted column values?, (2) set values subset column values? New functions order-based interrogations: col_vals_increasing() (+ expect_col_vals_increasing() test_col_vals_increasing()) col_vals_decreasing() (+ expect_col_vals_decreasing() test_col_vals_decreasing()); check column values either increasing decreasing options allow non-moving values backtracking (threshold). Several functions added facilitate multi-agent workflows: create_multiagent(), read_disk_multiagent(), get_multiagent_report(); workflows help track interrogation results across multiple agents reporting scales well several dozens agents. new function write_testthat_file() generates testthat test file puts tests/testthat certain conditions met; converts agent’s validation plan separate expect_*() statements. New functions tbl_store(), tbl_source(), tbl_get() functions added centrally managing table-prep formulas. Added yaml_exec() function processes relevant pointblank YAML files directory; execution involves interrogation agents (given YAML agents) incorporation informants (given YAML informants), saving processed objects output directory. new functions file_tbl() helper from_github() make easy generate table compatible data file; file form CSV, TSV, RDA, RDS. Several functions added modifying agent’s validation plan: activate_steps(), deactivate_steps(), remove_steps(). Added snip_stats() function generating -line statistical summary information report. Add sorting options snip_list() can choose sort column items frequency sequentially (alphabetically/numerically). improvements made snip_list() : (1) better default appearance, (2) enable customization, (3) include localization options supported spoken languages. Added several options customizing main reporting heading three reporting objects: agent report, information report, multiagent report. active argument every validation function can now take expression evaluates logical; has_columns() added make easy express active whether one columns present target table (e.g., perform validation step target column available). Added support using Arrow tables target tables informant objects.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"documentation-0-7-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.7.0","text":"Added information YAML representations validation functions several functions make appearance YAML. General improvements function documentation made wide cross section exported functions.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.7.0","text":"Included method writing informant object disk (x_write_disk()). Many fixes made tests added ensure agents survive YAML roundtrip (agent %>% yaml_write() yaml_read_agent() creates agent object). Updated several internal dplyr::arrange() statements used scan_data() warnings aren’t issued dbplyr (table scans operating tbl_dbi objects). tidyselect expressions used agents now preserved agent written YAML.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-060","dir":"Changelog","previous_headings":"","what":"pointblank 0.6.0","title":"pointblank 0.6.0","text":"CRAN release: 2020-11-20","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-information-0-6-0","dir":"Changelog","previous_headings":"","what":"Pointblank Information","title":"pointblank 0.6.0","text":"new information management workflow full features help describe tables keep top changes . make work well, new character enters: informant! Added create_informant() function create ptblank_informant object (function similar create_agent()). meant hold information (much want, really) target table, reporting features geared toward communication. Functions facilitating entry info text added need (info_tabular(), info_columns(), info_section()). focused describing columns, table proper, misc. fields. wasn’t enough, release adds info_snippet() round collection info_*() functions workflow. Oh, hang , ’s also -important incorporate() function. ? explain, idea methodology acquiring important bits data target table (’s info_snippet()’s job) use incorporate() grab morsels data stitch info text (via { }). Added get_informant_report() function printing information report (gt table object!). can also just print informant object show information report thanks print method purpose. informant object can written pointblank YAML using revised yaml_write() (previously agent_yaml_write()) function. can actually write agent informant YAML file useful since objects share target table. Reading done yaml_read_agent() yaml_read_informant() functions. informant can emailed using email_create() function; emailing can done one eight languages stock message text.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"translations-and-locales-0-6-0","dir":"Changelog","previous_headings":"","what":"Translations and Locales","title":"pointblank 0.6.0","text":"text agent report translated now. Improved Spanish (Spain) translation. Added Portuguese (\"pt\", Brazil), Chinese (\"zh\", China mainland), Russian (\"ru\") translations. Added locale option reporting; locale match language (using base locale) unless different locale specified. locale used format numeric values according locale’s rules. also applies reporting offered scan_data() function. stock email message parts (used emailing agent report information report) translated eight supported languages. language setting respective objects used determine language stock message parts.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"breaking-changes-0-6-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"pointblank 0.6.0","text":"yaml_write() function replaces agent_yaml_write() function. new function works write agent, informant object, , YAML. names YAML functions changed, final roster now consists : yaml_write(), yaml_read_agent(), yaml_read_informant(), yaml_agent_interrogate(), yaml_agent_string(), yaml_agent_show_exprs(). x_write_disk() function replaces agent_write() function. new function works write agent informant object disk. x_read_disk() function replaces agent_read() function. new function works read agent informant objects written disk. email_preview() function renamed email_create().","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"new-features-0-6-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.6.0","text":"new db_tbl() function makes ridiculously easy access database table selection databases pointblank supports validation; accessible supplied keywords \"postgres\" (PostgreSQL), \"mysql\" (MySQL), \"maria\" (MariaDB), \"duckdb\" (DuckDB), \"sqlite\" (SQLite), , driver function ’d like supply. Added log4r_step() function can used action action_levels() function call (.e., list component fns list). can place call function every condition produce log entry (.e., warn, stop, notify).","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"documentation-0-6-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"pointblank 0.6.0","text":"Added several articles explain different validation workflows (six ’em) articles go Information Management workflow. Improved documentation almost functions package; added useful examples. Added table project README keeps everyone apprised project milestones issues closed upcoming release.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-6-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.6.0","text":"Improved appearance agent report: (1) tooltips, (2) tooltips much improved (animate, larger text, snappier previous ones), (3) SVGs now used symbols validation steps instead blurry PNGs, (4) less confusing glyphs now used TBL column, (5) agent label can expressed Markdown looks nicer report, (6) table type (name, supplied tbl_name) shown header, (7) validation threshold levels also shown table header, (8) interrogation starting/ending timestamps shown (along duration) table footer, (9) table font changed less default-y, (10) adjustments table borders cell shading made better readability. get_agent_report() function now lang locale arguments override values set prior (e.g., create_agent()). allows reporting language changed without need re-run everything scratch. set_tbl(), remove_tbl(), set_read_fn(), remove_read_fn() functions can now also used informant object. get_sundered_data() function clear regard validation steps considered splitting data. Using validation steps preconditions must fulfill rule target table single form across steps. is_exact argument new col_schema_match(), expect_col_schema_match(), test_col_schema_match() functions, allowing types validations less stringent. argument loosens requirement include class names column may multiple. Also, can specify NULL entirely skip checking class/type. can now use combinations validation functions conjointly(). validation functions intrinsically operate single test unit (e.g., col_is_*() functions) now work combination validation functions operate n test units (e.g., col_vals_*() functions). lets us test condition columns certain type individual test units fulfill col_vals_*() requirements. Simplified sections argument scan_data() length-1 character vector containing key characters standing section names. Refactored large portion code produces agent report increase rendering speed. Improved printing errors/warnings (tooltips EVAL column agent report) thanks implementation HTML escaping. small version agent report (perfect emailing) now much improved formatting.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-052","dir":"Changelog","previous_headings":"","what":"pointblank 0.5.2","title":"pointblank 0.5.2","text":"CRAN release: 2020-08-28 Fixes performance issue validations larger tables. Improved formatting value ranges agent report.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-051","dir":"Changelog","previous_headings":"","what":"pointblank 0.5.1","title":"pointblank 0.5.1","text":"CRAN release: 2020-08-27 Improved compatibility validations performed SQL Server 2019. Integrated label argument validation functions; label available agent x_list , importantly, displayed agent report (STEP column). Added \"combined\" option get_sundered_data() function (type argument). applies categorical (pass/fail) label (settable new pass_fail argument function) new .pb_combined flag column output table. Made several visual improvements agent report.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-050","dir":"Changelog","previous_headings":"","what":"pointblank 0.5.0","title":"pointblank 0.5.0","text":"CRAN release: 2020-08-12","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"new-features-0-5-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.5.0","text":"agent can now given table-reading function, used reading data interrogation. tbl provided, function invoked. However, tbl read_fn specified, supplied tbl take priority (useful one-shot interrogations table interactive context). two ways specify read_fn: (1) using function (e.g., function() { <table reading code> }) , (2) R formula expression (e.g., ~ { <table reading code> }). Added set functions setting removing agent’s association data table (set_tbl() remove_tbl()) table-reading function (set_read_fn() remove_read_fn()). validation functions now step_id parameter. use step IDs serves distinguish validation steps provide opportunity supplying meaningful label compared step index. Supplying step_id optional; pointblank automatically generate step ID value (based step index) ’s provided. Added new functions reading writing YAML (, called pointblank YAML). pointblank YAML file can generated agent using agent_yaml_write() function. ’re always free create pointblank YAML hand, , can edit/extend existing pointblank YAML file. agent can created pointblank YAML agent_yaml_read() function. ’s also possible interrogate target data table right pointblank YAML using agent_yaml_interrogate(). agent_write() agent_read() functions added; allow saving agent disk reading agent back disk. Saved--disk agents still retain validation plans, intel interrogations, reference target table (read_fn value) even entire target table (requested). Reading agent disk agent_read() allows us use post-interrogation functions (e.g., get_agent_x_list(), get_data_extracts(), get_agent_report(), etc.) though interrogation just occurred. pointblank now compatible Spark DataFrames sparklyr package. Simply use tbl_spark object specifying target table create_agent(), set_tbl(), scan_data().","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-5-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.5.0","text":"issue showing agent report table email message body via email_blast() function resolved. Resolved issue using literal character values comparison-based validation functions (e.g., col_vals_between(), col_vals_gt(), etc.). Completely rewrote underlying processes storage retrieval translation text. Much improved translations reporting text Spanish German languages. Thanks @pachamaltese @DavZim valuable contributions! New testthat tests added test pointblank validations mock PostgreSQL MySQL database tables via dittodb package. Thank @pachamaltese implementing tests.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-040","dir":"Changelog","previous_headings":"","what":"pointblank 0.4.0","title":"pointblank 0.4.0","text":"CRAN release: 2020-06-22","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"new-r-markdown-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New R Markdown features","title":"pointblank 0.4.0","text":"New R Markdown validation feature allows validation testing within specialized validation code chunks validate = TRUE option set. Using pointblank validation functions data marked code chunks flag overall failure stop threshold exceeded anywhere. errors reported validation code chunk rendering document HTML, green red status buttons indicate whether validations succeeded failures occurred. Clicking button reveals otherwise hidden validation statements error messages (). Using pointblank R Markdown workflow enabled default pointblank library loaded. framework testing set default, new validate_rmd() function offers opportunity set UI logging options. Added R Markdown template new R Markdown validation feature (Pointblank Validation). new stop_if_not() function works well standalone, replacement stopifnot() also customized use validation checks R Markdown documents pointblank loaded. Using stop_if_not() code chunk validate = TRUE option set yield correct reporting successes failures whereas stopifnot() . knit.print() method added facilitate printing agent report table within R Markdown code chunk.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"breaking-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"pointblank 0.4.0","text":"default behavior using validation step functions (e.g., col_vals_lt()) directly data tables changed. , single test unit failure trigger warning. Now, single test unit failing results error. Going back earlier behavior now requires use actions = warn_on_fail() (new helper function, default warn_at threshold value 1) invocation validation step function. stop_on_fail() helper function also new release, stop_at threshold parameter, also default 1.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"pointblank 0.4.0","text":"Added 24 expectation functions (e.g., expect_col_exists(), expect_rows_distinct(), expect_col_schema_match(), etc.) complements 24 validation functions. can used testthat tests tabular data simplified interface exposes easy--use failure threshold (defaulting 1). Added 24 test functions (e.g., test_col_exists(), test_rows_distinct(), test_col_schema_match(), etc.) complement 24 validation functions. functions return logical value: TRUE threshold (default 1) exceeded, FALSE otherwise. test_*() functions use simplified interface expect_*() functions. Added col_vals_expr(), expect_col_vals_expr(), test_col_vals_expr() validation, expectation, test functions, making easier DIY validations. dplyr expr(), case_when(), () functions re-exported easier accessibility since work exceedingly well new functions. col_schema_match() (expect test analogues) gained new arguments: complete in_order. allow relaxation constraints related completeness ordering columns defined col_schema object (created col_schema()). preconditions argument available validation, expectation, test functions now accepts formula function values (previously, formula values accepted). get_agent_report() function now size argument option get agent report table \"standard\" (width: 875px) size \"small\" size (width: 575px); previously option accessible .... appearance agent report improved ’s gained new features: (1) data extracts failing rows (row-based validation steps) can downloaded CSVs via new buttons appear EXT column, (2) useful tooltips fields table (e.g., hovering items STEP show brief, TBL icons describe whether preconditions applied table prior interrogation, etc.), (3) printing improvements COLUMNS VALUES columns (e.g., table columns distinguished literal values). Improved appearance email message generated email_blast() email_preview(). email message, using stock_msg_body() stock_msg_footer() defaults msg_body msg_footer, embeds \"small\" version agent report provides introductory text nicer formatting .","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"documentation-improvements-0-4-0","dir":"Changelog","previous_headings":"","what":"Documentation improvements","title":"pointblank 0.4.0","text":"functions now revised documentation complete, examples, consistent across many validation, expectation, test functions. package README now contains better graphics, reworked examples, new section package’s design goals (listing R packages also focus table validation).","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"minor-improvements-and-bug-fixes-0-4-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"pointblank 0.4.0","text":"Rewrote internal stock_stoppage() stock_warning() functions generated error warning messages match whether validation functions used directly data expectation functions used. Console status messages performing interrogation now appear interactive session. longer appear R Markdown rendering execution unattended scripts. col_vals_regex() validation function (plus associated expectation test functions) can now used database tables (DB types support regular expressions). tested MySQL PostgreSQL, differing underlying SQL implementations. col_schema() function now allows either uppercase lowercase SQL column types (using .db_col_types = \"sql\"). Previously, supplying SQL columns types uppercase (e.g., “INT”, “TINYINT”, etc.) always fail validation SQL column types target table captured lowercase values create_agent() call. Many new tests added cover new functions existing functions. ’s important validation package testing comprehensive rigorous, , continue focus forthcoming releases. Fixed duration label bug console status messages appear interrogation (now consistently values reported seconds) Added column validity checks inside internal interrogate_*() functions","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-031","dir":"Changelog","previous_headings":"","what":"pointblank 0.3.1","title":"pointblank 0.3.1","text":"Fixed implementation col_vals_between() col_vals_not_between() step functions work tbl_dbi objects. Added scan_data() function, thoroughly scans table data can understand better (giving HTML report). Added get_agent_x_list() function provide easy access agent intel Added get_agent_report() function give fine control agent’s gt-based reportage; also, agent’s default print method now report (default appearance options) Added get_sundered_data() function split table data ‘pass’ ‘fail’ pieces interrogation Added col_schema_match() validation step function; works conjunction col_schema object (generated col_schema() function) help determine whether expected schema matches target table. Added multilingual support reports generated agent validations produced new scan_data() function fully integrates gt (tables reports) blastula (email production delivery) packages Numerous fixes ensure compatibility tibble 3.0.0","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-030","dir":"Changelog","previous_headings":"","what":"pointblank 0.3.0","title":"pointblank 0.3.0","text":"CRAN release: 2020-01-10 pointblank package changed significantly previous version favor consistency simplicity, better reporting, increased power. internals extensively refactored API accordingly gone revisions.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"breaking-changes-0-3-0","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"pointblank 0.3.0","text":"focus_on() function removed favor directly using data object. means single use create_agent() can now work single table time (create_agent() now tbl argument). Also, input tbl can data.frame, tbl_df, tbl_dbi object. preconditions argument changed can now used temporarily transform table (.e., transforming particular validation step). Previously, option filter input table now ’s possible useful things like joining table, adding columns, filtering rows, etc. preconditions args now accepts list expressions manipulate table data. action_levels() helper function introduced work actions argument (every validation step function). replaces warn_count, stop_count, notify_count, warn_fraction, stop_fraction, notify_fraction arguments. function allows evaluation functions (given fns argument) reaction exceeding thresholds specified warn_at, stop_at, notify_at. using validation step functions directly data (.e., use create_agent()), data now passed straight validation step. purpose now mode create warnings throw errors warn stop thresholds exceeded. Across pointblank validation step functions, argument stands table columns normalized columns. incl_na argument, implemented validation step functions, renamed na_pass better indicate purpose (consider encountered NA values passing test units), , use expanded relevant functions.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"new-features-0-3-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"pointblank 0.3.0","text":"’s now possible use vars() certain tidyselect select helpers (e.g., starts_with()) defining columns pointblank validation step functions. conjointly() function new validation step function allows multiple rowwise validation steps performed joint validity testing.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-021","dir":"Changelog","previous_headings":"","what":"pointblank 0.2.1","title":"pointblank 0.2.1","text":"CRAN release: 2019-09-12 Revisions account API changes tidyr 1.0.0. Incorporates corrections related API changes rlang 0.2.0.","code":""},{"path":"https://rstudio.github.io/pointblank/news/index.html","id":"pointblank-01","dir":"Changelog","previous_headings":"","what":"pointblank 0.1","title":"pointblank 0.1","text":"CRAN release: 2017-08-22 First release.","code":""}]
